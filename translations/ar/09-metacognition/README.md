[![تصميم وكلاء متعددون](../../../translated_images/ar/lesson-9-thumbnail.38059e8af1a5b71d.webp)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(انقر على الصورة أعلاه لمشاهدة فيديو هذا الدرس)_
# الإدراك فوق المعرفي في وكلاء الذكاء الاصطناعي

## مقدمة

مرحبًا بك في درس الإدراك فوق المعرفي في وكلاء الذكاء الاصطناعي! هذا الفصل مخصص للمبتدئين الذين يثير فضولهم كيف يمكن لوكلاء الذكاء الاصطناعي التفكير في عمليات تفكيرهم الخاصة. بحلول نهاية هذا الدرس، ستفهم المفاهيم الرئيسية وستكون مزودًا بأمثلة عملية لتطبيق الإدراك فوق المعرفي في تصميم وكلاء الذكاء الاصطناعي.

## أهداف التعلم

بعد إتمام هذا الدرس، ستكون قادرًا على:

1. فهم تداعيات حلقات الاستدلال في تعريفات الوكلاء.
2. استخدام تقنيات التخطيط والتقييم لمساعدة الوكلاء المصححين لأنفسهم.
3. إنشاء وكلاءك الخاصين القادرين على التلاعب بالكود لتحقيق المهام.

## مقدمة في الإدراك فوق المعرفي

يشير الإدراك فوق المعرفي إلى العمليات الإدراكية العليا التي تنطوي على التفكير في التفكير ذاته. بالنسبة لوكلاء الذكاء الاصطناعي، يعني هذا القدرة على تقييم وتعديل أفعالهم بناءً على الوعي الذاتي والتجارب السابقة. يعد الإدراك فوق المعرفي، أو "التفكير في التفكير"، مفهومًا مهمًا في تطوير أنظمة الذكاء الاصطناعي الوكيلية. يشمل ذلك وعي أنظمة الذكاء الاصطناعي بعملياتها الداخلية وقدرتها على المراقبة والتنظيم والتكيف وفقًا لذلك. تمامًا كما نفعل عندما نقرأ الموقف أو ننظر إلى مشكلة. يمكن لهذا الوعي الذاتي أن يساعد أنظمة الذكاء الاصطناعي على اتخاذ قرارات أفضل، وتحديد الأخطاء، وتحسين أدائها مع مرور الوقت - مما يعيدنا مرة أخرى إلى اختبار تورينغ والنقاش حول ما إذا كان الذكاء الاصطناعي سيهيمن في النهاية.

في سياق أنظمة الذكاء الاصطناعي الوكيلية، يمكن للإدراك فوق المعرفي معالجة عدة تحديات، مثل:
- الشفافية: ضمان قدرة أنظمة الذكاء الاصطناعي على شرح استدلالها وقراراتها.
- الاستدلال: تعزيز قدرة أنظمة الذكاء الاصطناعي على تجميع المعلومات واتخاذ قرارات سليمة.
- التكيف: السماح لأنظمة الذكاء الاصطناعي بالتكيف مع بيئات جديدة وظروف متغيرة.
- الإدراك: تحسين دقة أنظمة الذكاء الاصطناعي في التعرف على البيانات وتفسيرها من بيئتها.

### ما هو الإدراك فوق المعرفي؟

الإدراك فوق المعرفي، أو "التفكير في التفكير"، هو عملية إدراكية عليا تشمل الوعي الذاتي والتنظيم الذاتي للعمليات المعرفية للفرد. في مجال الذكاء الاصطناعي، يمنح الإدراك فوق المعرفي الوكلاء القدرة على تقييم وتعديل استراتيجياتهم وأفعالهم، مما يؤدي إلى تحسين قدرة حل المشكلات واتخاذ القرارات. من خلال فهم الإدراك فوق المعرفي، يمكنك تصميم وكلاء ذكاء اصطناعي ليسوا أكثر ذكاءً فحسب، بل أيضًا أكثر تكيّفًا وكفاءة. في الإدراك فوق المعرفي الحقيقي، سترى الذكاء الاصطناعي يستنتج صراحةً حول استدلاله الخاص.

مثال: "فضلت الرحلات الأرخص لأن... قد أكون أفوّت الرحلات المباشرة، لذا دعني أعيد التحقق."  
متابعة كيف ولماذا اختار طريقًا معينًا.  
- ملاحظة أنه ارتكب أخطاء لأنه اعتمد كثيرًا على تفضيلات المستخدم من المرة السابقة، لذا يغير استراتيجيته في اتخاذ القرار وليس التوصية النهائية فقط.  
- تشخيص أنماط مثل، "كلما رأيت المستخدم يذكر 'الاكتظاظ الشديد'، يجب ألا أزيل فقط بعض الأماكن السياحية بل أعكس أيضًا أن طريقتي في اختيار 'أفضل المعالم' معيبة إذا كنت دائمًا أرتب حسب الشعبية."

### أهمية الإدراك فوق المعرفي في وكلاء الذكاء الاصطناعي

يلعب الإدراك فوق المعرفي دورًا حاسمًا في تصميم وكلاء الذكاء الاصطناعي لأسباب متعددة:

![أهمية الإدراك فوق المعرفي](../../../translated_images/ar/importance-of-metacognition.b381afe9aae352f7.webp)

- التأمل الذاتي: يمكن للوكلاء تقييم أدائهم وتحديد مجالات للتحسين.
- القابلية للتكيف: يستطيع الوكلاء تعديل استراتيجياتهم بناءً على التجارب السابقة والبيئات المتغيرة.
- تصحيح الأخطاء: يستطيع الوكلاء اكتشاف وتصحيح الأخطاء autonomously، مما يؤدي إلى نتائج أكثر دقة.
- إدارة الموارد: يمكن للوكلاء تحسين استخدام الموارد، مثل الوقت وقوة الحوسبة، من خلال التخطيط وتقييم أفعالهم.

## مكونات وكيل الذكاء الاصطناعي

قبل الخوض في عمليات الإدراك فوق المعرفي، من الضروري فهم المكونات الأساسية للوكيل الذكي. عادةً ما يتكون وكيل الذكاء الاصطناعي من:

- الشخصية: شخصية وخصائص الوكيل التي تحدد كيفية تفاعله مع المستخدمين.
- الأدوات: القدرات والوظائف التي يمكن للوكيل تنفيذها.
- المهارات: المعرفة والخبرة التي يمتلكها الوكيل.

تعمل هذه المكونات معًا لإنشاء "وحدة خبرة" قادرة على أداء مهام محددة.

**مثال**:  
فكر في وكيل سفر، وهو خدمة توفر تخطيط رحلتك بالإضافة إلى تعديل مسارها بناءً على بيانات الوقت الحقيقي وتجارب رحلات العملاء السابقة.

### مثال: الإدراك فوق المعرفي في خدمة وكيل السفر

تخيل أنك تصمم خدمة وكيل سفر مدعومة بالذكاء الاصطناعي. هذا الوكيل "وكيل السفر"، يساعد المستخدمين في تخطيط عطلاتهم. لدمج الإدراك فوق المعرفي، يحتاج وكيل السفر إلى تقييم وتعديل أفعاله بناءً على الوعي الذاتي والتجارب السابقة. إليك كيف يمكن أن يلعب الإدراك فوق المعرفي دورًا:

#### المهمة الحالية

المهمة الحالية هي مساعدة المستخدم في تخطيط رحلة إلى باريس.

#### خطوات إكمال المهمة

1. **جمع تفضيلات المستخدم**: استفسر من المستخدم عن تواريخ السفر، الميزانية، الاهتمامات (مثل المتاحف، المطبخ، التسوق)، وأي متطلبات خاصة.
2. **استرجاع المعلومات**: ابحث عن خيارات الرحلات، الإقامات، المعالم، والمطاعم التي تتناسب مع تفضيلات المستخدم.
3. **إنشاء التوصيات**: قدم جدولًا شخصيًا بتفاصيل الرحلة، حجوزات الفنادق، والأنشطة المقترحة.
4. **التعديل بناء على التغذية الراجعة**: اطلب ملاحظات المستخدم على التوصيات وأجرِ التعديلات اللازمة.

#### الموارد المطلوبة

- الوصول إلى قواعد بيانات حجز الرحلات والفنادق.
- معلومات عن معالم ومطاعم باريس.
- بيانات تغذية راجعة من المستخدم من التفاعلات السابقة.

#### الخبرة والتأمل الذاتي

يستخدم وكيل السفر الإدراك فوق المعرفي لتقييم أدائه والتعلم من الخبرات السابقة. على سبيل المثال:

1. **تحليل تغذية راجعة المستخدم**: يقوم وكيل السفر بمراجعة ملاحظات المستخدم لتحديد التوصيات التي لاقت استحسانًا وما لم تلاقيه. ويعدل اقتراحاته المستقبلية تبعًا لذلك.
2. **القابلية للتكيف**: إذا ذكر المستخدم سابقًا رفضه للأماكن المزدحمة، سيتجنب وكيل السفر اقتراح الأماكن السياحية المشهورة خلال أوقات الذروة مستقبلًا.
3. **تصحيح الأخطاء**: إذا ارتكب وكيل السفر خطأ في حجز سابق، مثل اقتراح فندق ممتلئ، يتعلم أن يتحقق من التوافر بشكل أكثر دقة قبل تقديم التوصيات.

#### مثال عملي للمطور

إليك مثالًا مبسطًا على كيفية ظهور كود وكيل السفر عند دمجه الإدراك فوق المعرفي:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # البحث عن الرحلات الجوية والفنادق والمعالم السياحية بناءً على التفضيلات
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # تحليل التعليقات وتعديل التوصيات المستقبلية
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# مثال للاستخدام
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### لماذا الإدراك فوق المعرفي مهم

- **التأمل الذاتي**: يمكن للوكلاء تحليل أدائهم وتحديد مجالات التحسين.
- **القابلية للتكيف**: يمكن للوكلاء تعديل الاستراتيجيات بناءً على الملاحظات والظروف المتغيرة.
- **تصحيح الأخطاء**: يمكن للوكلاء اكتشاف الأخطاء وتصحيحها بشكل مستقل.
- **إدارة الموارد**: يمكن للوكلاء تحسين استخدام الموارد مثل الوقت والطاقة الحاسوبية.

من خلال دمج الإدراك فوق المعرفي، يمكن لوكيل السفر تقديم توصيات سفر أكثر تخصيصًا ودقة، مما يعزز تجربة المستخدم الشاملة.

---

## ٢. التخطيط في الوكلاء

يعد التخطيط مكونًا حيويًا في سلوك وكيل الذكاء الاصطناعي. يتضمن تحديد الخطوات اللازمة لتحقيق هدف معين، مع مراعاة الحالة الحالية، الموارد، والعوائق المحتملة.

### عناصر التخطيط

- **المهمة الحالية**: تعريف المهمة بوضوح.
- **خطوات إتمام المهمة**: تقسيم المهمة إلى خطوات قابلة للإدارة.
- **الموارد المطلوبة**: تحديد الموارد اللازمة.
- **الخبرة**: الاستفادة من الخبرات السابقة لإبلاغ التخطيط.

**مثال**:  
فيما يلي خطوات على وكيل السفر اتخاذها لمساعدة المستخدم في تخطيط رحلته بفعالية:

### خطوات وكيل السفر

1. **جمع تفضيلات المستخدم**  
   - اسأل المستخدم عن تفاصيل تواريخ السفر، الميزانية، الاهتمامات، وأي متطلبات خاصة.  
   - أمثلة: "متى تخطط للسفر؟" "ما هو نطاق ميزانيتك؟" "ما الأنشطة التي تستمتع بها أثناء العطلة؟"

2. **استرجاع المعلومات**  
   - ابحث عن خيارات السفر ذات الصلة بناءً على تفضيلات المستخدم.  
   - **الرحلات**: ابحث عن رحلات متاحة ضمن ميزانية وتواريخ السفر المفضلة.  
   - **الإقامات**: اعثر على فنادق أو عقارات إيجار تناسب تفضيلات المستخدم من حيث الموقع والسعر والمرافق.  
   - **المعالم والمطاعم**: حدد المعالم والأنشطة وأماكن تناول الطعام التي تتماشى مع اهتمامات المستخدم.

3. **إنشاء التوصيات**  
   - اجمع المعلومات المسترجعة في جدول زمني مخصص.  
   - قدم تفاصيل مثل خيارات الرحلات، حجوزات الفنادق، والأنشطة المقترحة مع تخصيص التوصيات وفقًا لتفضيلات المستخدم.

4. **عرض الجدول الزمني على المستخدم**  
   - شارك الجدول المقترح مع المستخدم للمراجعة.  
   - مثال: "إليك جدول مقترح لرحلتك إلى باريس، يشمل تفاصيل الرحلات، حجوزات الفنادق، وقائمة الأنشطة والمطاعم الموصى بها. أخبرني برأيك!"

5. **جمع التعليقات**  
   - اطلب ملاحظات المستخدم حول الجدول المقترح.  
   - أمثلة: "هل أعجبتك خيارات الرحلات؟" "هل الفندق مناسب لاحتياجاتك؟" "هل ترغب في إضافة أو إزالة أي نشاطات؟"

6. **التعديل بناءً على التعليقات**  
   - عدل الجدول بناءً على ملاحظات المستخدم.  
   - أجرِ التغييرات اللازمة على توصيات الرحلات، الإقامة، والأنشطة لتتناسب بشكل أفضل مع تفضيلات المستخدم.

7. **التأكيد النهائي**  
   - قدم الجدول الزمني المحدث للمستخدم للتأكيد النهائي.  
   - مثال: "لقد أجريت التعديلات بناءً على ملاحظاتك. إليك الجدول المحدث. هل كل شيء يبدو جيدًا؟"

8. **حجز وتأكيد الحجوزات**  
   - بمجرد موافقة المستخدم على الجدول، تابع بحجز الرحلات، الإقامات، وأي أنشطة مخططة مسبقًا.  
   - أرسل تفاصيل التأكيد للمستخدم.

9. **تقديم الدعم المستمر**  
   - كن متاحًا لمساعدة المستخدم في أي تغييرات أو طلبات إضافية قبل وخلال الرحلة.  
   - مثال: "إذا احتجت إلى أي دعم خلال رحلتك، لا تتردد في التواصل معي في أي وقت!"

### تفاعل نموذجي

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# مثال على الاستخدام داخل طلب حجز
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## ٣. نظام RAG التصحيحي

لنبدأ أولًا بفهم الفرق بين أداة RAG وتحميل السياق الاستباقي

![RAG مقابل تحميل السياق](../../../translated_images/ar/rag-vs-context.9eae588520c00921.webp)

### التوليد المعزز بالاسترجاع (RAG)

يجمع RAG بين نظام استرجاع ونموذج توليدي. عندما يتم إجراء استعلام، يقوم نظام الاسترجاع بجلب الوثائق أو البيانات ذات الصلة من مصدر خارجي، وتُستخدم هذه المعلومات المسترجعة لتعزيز الإدخال للنموذج التوليدي. هذا يساعد النموذج على إنتاج ردود أكثر دقة وذات صلة بالسياق.

في نظام RAG، يسترجع الوكيل المعلومات ذات الصلة من قاعدة معرفة ويستخدمها لتوليد ردود أو أفعال مناسبة.

### نهج RAG التصحيحي

يركز نهج RAG التصحيحي على استخدام تقنيات RAG لتصحيح الأخطاء وتحسين دقة وكلاء الذكاء الاصطناعي. يشمل ذلك:

1. **تقنية التنبيه**: استخدام تنبيهات محددة لإرشاد الوكيل في استرجاع المعلومات ذات الصلة.
2. **الأداة**: تنفيذ خوارزميات وآليات تمكن الوكيل من تقييم مدى صلة المعلومات المسترجعة وتوليد ردود دقيقة.
3. **التقييم**: تقييم أداء الوكيل باستمرار وإجراء التعديلات لتحسين دقته وكفاءته.

#### مثال: RAG التصحيحي في وكيل البحث

فكر في وكيل بحث يسترجع معلومات من الويب للرد على استفسارات المستخدم. قد يشمل نهج RAG التصحيحي:

1. **تقنية التنبيه**: صياغة استعلامات البحث بناءً على مدخلات المستخدم.
2. **الأداة**: استخدام معالجة اللغة الطبيعية وخوارزميات التعلم الآلي لترتيب وتصفية نتائج البحث.
3. **التقييم**: تحليل ملاحظات المستخدم لتحديد وتصحيح عدم دقة المعلومات المسترجعة.

### RAG التصحيحي في وكيل السفر

يعزز RAG التصحيحي (التوليد المعزز بالاسترجاع) قدرة الذكاء الاصطناعي على استرجاع وتوليد المعلومات أثناء تصحيح أي أخطاء. دعنا نرى كيف يمكن لوكيل السفر استخدام نهج RAG التصحيحي لتقديم توصيات سفر أكثر دقة وملاءمة.

يشمل ذلك:

- **تقنية التنبيه:** استخدام تنبيهات محددة لإرشاد الوكيل في استرجاع المعلومات ذات الصلة.
- **الأداة:** تنفيذ خوارزميات وآليات تسمح للوكيل بتقييم مدى ربط المعلومات المسترجعة وتوليد ردود دقيقة.
- **التقييم:** تقييم أداء الوكيل باستمرار وإجراء التعديلات لتحسين دقته وكفاءته.

#### خطوات تنفيذ RAG التصحيحي في وكيل السفر

1. **التفاعل الأولي مع المستخدم**  
   - يجمع وكيل السفر التفضيلات الأولية من المستخدم، مثل الوجهة، تواريخ السفر، الميزانية، والاهتمامات.  
   - مثال:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **استرجاع المعلومات**  
   - يسترجع وكيل السفر معلومات حول الرحلات، الإقامات، المعالم، والمطاعم بناءً على تفضيلات المستخدم.  
   - مثال:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **توليد التوصيات الأولية**  
   - يستخدم وكيل السفر المعلومات المسترجعة لإنشاء جدول زمني مخصص.  
   - مثال:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **جمع ملاحظات المستخدم**  
   - يطلب وكيل السفر ملاحظات المستخدم حول التوصيات الأولية.  
   - مثال:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **عملية RAG التصحيحية**  
   - **تقنية التنبيه**: يشكل وكيل السفر استعلامات بحث جديدة بناءً على ملاحظات المستخدم.  
     - مثال:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **الأداة**: يستخدم وكيل السفر خوارزميات لترتيب وتصفية نتائج البحث الجديدة، مع التركيز على الصلة بناءً على ملاحظات المستخدم.  
     - مثال:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **التقييم**: يقوم وكيل السفر بتقييم مدى ربط ودقة توصياته باستمرار من خلال تحليل ملاحظات المستخدم وإجراء التعديلات اللازمة.  
     - مثال:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### مثال عملي

إليك مثال كود بايثون مبسط يدمج نهج RAG التصحيحي في وكيل السفر:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# مثال على الاستخدام
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### تحميل السياق الاستباقي
تحميل السياق بشكل استباقي ينطوي على تحميل سياق أو معلومات خلفية ذات صلة في النموذج قبل معالجة الاستعلام. هذا يعني أن النموذج لديه وصول إلى هذه المعلومات من البداية، مما يمكنه من توليد استجابات أكثر وعيًا دون الحاجة إلى استرجاع بيانات إضافية أثناء العملية.

إليك مثال مبسط لكيفية ظهور تحميل السياق الاستباقي لتطبيق وكيل سفر بلغة بايثون:

```python
class TravelAgent:
    def __init__(self):
        # تحميل الوجهات الشهيرة ومعلوماتها مسبقًا
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # جلب معلومات الوجهة من السياق المحمل مسبقًا
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# مثال للاستخدام
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### التفسير

1. **التهيئة (طريقة `__init__`)**: تقوم فئة `TravelAgent` بتحميل قاموس يحتوي على معلومات حول وجهات سياحية شهيرة مثل باريس وطوكيو ونيويورك وسيدني. يشمل هذا القاموس تفاصيل مثل البلد، العملة، اللغة، والمعالم الرئيسية لكل وجهة.

2. **استرجاع المعلومات (طريقة `get_destination_info`)**: عندما يستفسر المستخدم عن وجهة معينة، تجلب طريقة `get_destination_info` المعلومات ذات الصلة من قاموس السياق المحمّل مسبقًا.

عن طريق تحميل السياق مسبقًا، يمكن لتطبيق وكيل السفر الرد بسرعة على استفسارات المستخدمين دون الحاجة لاسترجاع هذه المعلومات من مصدر خارجي في الوقت الفعلي. هذا يجعل التطبيق أكثر كفاءة واستجابة.

### بدء خطة بهدف قبل التكرار

بدء خطة بهدف يعني الشروع بهدف واضح أو نتيجة مستهدفة من البداية. عبر تحديد هذا الهدف مقدمًا، يمكن للنموذج استخدامه كمبدأ توجيهي خلال العملية التكرارية. هذا يساعد على ضمان أن كل تكرار يقرب من تحقيق النتيجة المرجوة، مما يجعل العملية أكثر كفاءة وتركيزًا.

إليك مثال على كيفية بدء خطة سفر بهدف قبل التكرار لوكيل سفر بلغة بايثون:

### السيناريو

يريد وكيل السفر تخطيط عطلة مخصصة لعميل. الهدف هو إنشاء مسار سفر يزيد من رضا العميل بناءً على تفضيلاته وميزانيته.

### الخطوات

1. تحديد تفضيلات العميل وميزانيته.
2. بدء الخطة الأولية بناءً على هذه التفضيلات.
3. التكرار لتنقيح الخطة، مع تحسين رضا العميل.

#### كود بايثون

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# مثال على الاستخدام
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### شرح الكود

1. **التهيئة (طريقة `__init__`)**: يتم تهيئة فئة `TravelAgent` مع قائمة من الوجهات المحتملة، كل منها يحتوي على سمات مثل الاسم، التكلفة، ونوع النشاط.

2. **بدء الخطة (طريقة `bootstrap_plan`)**: تنشئ هذه الطريقة خطة سفر أولية بناءً على تفضيلات العميل وميزانيته. تتكرر عبر قائمة الوجهات وتضيفها إلى الخطة إذا كانت تتوافق مع تفضيلات العميل وتتناسب مع الميزانية.

3. **مطابقة التفضيلات (طريقة `match_preferences`)**: تتحقق هذه الطريقة إذا كانت الوجهة تطابق تفضيلات العميل.

4. **تكرار الخطة (طريقة `iterate_plan`)**: تنقيح الخطة الأولية بمحاولة استبدال كل وجهة في الخطة بمطابقة أفضل، مع مراعاة تفضيلات العميل وقيود الميزانية.

5. **حساب التكلفة (طريقة `calculate_cost`)**: تحسب هذه الطريقة التكلفة الكلية للخطة الحالية، بما يشمل وجهة محتملة جديدة.

#### مثال على الاستخدام

- **الخطة الأولية**: ينشئ وكيل السفر خطة مبدئية بناءً على تفضيلات العميل في المعالم السياحية وميزانية 2000 دولار.
- **الخطة المنقحة**: يقوم وكيل السفر بتكرار الخطة، مع تحسين التوافق مع تفضيلات العميل والميزانية.

ببدء الخطة بهدف واضح (مثل تعظيم رضا العميل) والتكرار لتنقيح الخطة، يمكن لوكيل السفر إنشاء مسار سفر مخصص ومحسّن للعميل. هذا النهج يضمن توافق خطة السفر مع تفضيلات العميل وميزانيته من البداية ويتحسن مع كل تكرار.

### الاستفادة من نماذج اللغة الكبيرة لإعادة الترتيب والتقييم

يمكن استخدام نماذج اللغة الكبيرة (LLMs) في إعادة الترتيب والتقييم عبر تقييم مدى صلة وجودة المستندات المسترجعة أو الاستجابات المولدة. إليك كيف يعمل ذلك:

**الاسترجاع:** تجلب خطوة الاسترجاع الأولية مجموعة من المستندات أو الاستجابات المحتملة بناءً على الاستعلام.

**إعادة الترتيب:** تقوم الـ LLM بتقييم هذه الخيارات وإعادة ترتيبها بناءً على مدى الصلة والجودة. هذه الخطوة تضمن عرض المعلومات الأكثر صلة وجودة أولًا.

**التقييم:** تعطي الـ LLM درجات لكل خيار تعكس مدى صلته وجودته. هذا يساعد في اختيار أفضل استجابة أو مستند للمستخدم.

باستخدام نماذج اللغة الكبيرة لإعادة الترتيب والتقييم، يمكن للنظام تقديم معلومات أكثر دقة وذات صلة سياقية، مما يحسن تجربة المستخدم العامة.

إليك مثالًا على كيفية استخدام وكيل السفر لنموذج لغة كبير (LLM) لإعادة الترتيب والتقييم لوجهات السفر بناءً على تفضيلات المستخدم بلغة بايثون:

#### السيناريو - السفر بناءً على التفضيلات

يريد وكيل السفر التوصية بأفضل وجهات السفر لعميل بناءً على تفضيلاته. ستساعد الـ LLM في إعادة ترتيب وتقييم الوجهات لضمان عرض أنسب الخيارات.

#### الخطوات:

1. جمع تفضيلات المستخدم.
2. استرجاع قائمة بالوجهات المحتملة.
3. استخدام الـ LLM لإعادة الترتيب والتقييم بناءً على تفضيلات المستخدم.

إليك كيف يمكنك تحديث المثال السابق لاستخدام خدمات Azure OpenAI:

#### المتطلبات

1. يجب أن يكون لديك اشتراك في Azure.
2. إنشاء مورد Azure OpenAI والحصول على مفتاح API الخاص بك.

#### مثال كود بايثون

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # إنشاء موجه لـ Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # تحديد الرؤوس والحمولة للطلب
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # استدعاء واجهة برمجة التطبيقات Azure OpenAI للحصول على الوجهات المعاد ترتيبها والمُدرجة بالنقاط
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # استخراج التوصيات وإرجاعها
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# مثال للاستخدام
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### شرح الكود - حجز التفضيلات

1. **التهيئة**: يتم تهيئة فئة `TravelAgent` مع قائمة وجهات سفر محتملة، كل وجهة تحتوي على سمات مثل الاسم والوصف.

2. **الحصول على التوصيات (طريقة `get_recommendations`)**: تنشئ هذه الطريقة طلبًا لخدمة Azure OpenAI بناءً على تفضيلات المستخدم وتقوم بإرسال طلب HTTP من نوع POST إلى واجهة API الخاصة بـ Azure OpenAI للحصول على الوجهات المعاد ترتيبها والمقيّمة.

3. **إنشاء الطلب (طريقة `generate_prompt`)**: تبني هذه الطريقة طلبًا لـ Azure OpenAI، يشمل تفضيلات المستخدم وقائمة الوجهات، مع توجيه النموذج لإعادة ترتيب وتقييم الوجهات استنادًا إلى هذه التفضيلات.

4. **استدعاء API**: يتم استخدام مكتبة `requests` لإرسال طلب HTTP من نوع POST إلى نقطة نهاية Azure OpenAI. يحتوي الرد على الوجهات المعاد ترتيبها والمقيّمة.

5. **مثال على الاستخدام**: يجمع وكيل السفر تفضيلات المستخدم (مثل الاهتمام بالمعالم السياحية والثقافة المتنوعة) ويستخدم خدمة Azure OpenAI للحصول على توصيات وجهات السفر المعاد ترتيبها والمقيّمة.

تأكد من استبدال `your_azure_openai_api_key` بمفتاح API الحقيقي الخاص بك في Azure OpenAI و`https://your-endpoint.com/...` بعنوان نقطة النهاية الفعلية لنشر Azure OpenAI الخاص بك.

باستخدام نموذج اللغة الكبير لإعادة الترتيب والتقييم، يمكن لوكيل السفر تقديم توصيات سفر أكثر تخصيصًا وذات صلة للعميل، مما يعزز تجربته الإجمالية.

### RAG: تقنية التهيئة مقابل الأداة

الـ Retrieval-Augmented Generation (RAG) يمكن أن يكون كل من تقنية تهيئة وأداة في تطوير وكلاء الذكاء الاصطناعي. فهم الفرق بين الاثنين يمكن أن يساعدك على استغلال RAG بشكل أكثر فعالية في مشاريعك.

#### RAG كتقنية تهيئة

**ما هي؟**

- كتقنية تهيئة، تتضمن RAG صياغة استعلامات أو طلبات محددة لتوجيه استرجاع المعلومات ذات الصلة من مجموعة أو قاعدة بيانات كبيرة. ثم تُستخدم هذه المعلومات لتوليد استجابات أو إجراء عمليات.

**كيف تعمل؟**

1. **صياغة الطلبات**: إنشاء طلبات أو استعلامات منظمة بشكل جيد بناءً على المهمة الحالية أو مدخلات المستخدم.
2. **استرجاع المعلومات**: استخدام الطلبات للبحث عن بيانات ذات صلة من قاعدة معرفة أو مجموعة بيانات موجودة.
3. **توليد الاستجابة**: دمج المعلومات المسترجعة مع نماذج الذكاء الاصطناعي التوليدية لإنتاج استجابة شاملة ومتناسقة.

**مثال في وكيل السفر**:

- مدخل المستخدم: "أريد زيارة المتاحف في باريس."
- الطلب: "ابحث عن أفضل المتاحف في باريس."
- المعلومات المسترجعة: تفاصيل عن متحف اللوفر، متحف أورسيه، إلخ.
- الاستجابة المولدة: "إليك بعض أفضل المتاحف في باريس: متحف اللوفر، متحف أورسيه، ومركز بومبيدو."

#### RAG كأداة

**ما هي؟**

- كأداة، RAG هو نظام متكامل ي automatis عملية الاسترجاع والتوليد، مما يسهل على المطورين تنفيذ وظائف الذكاء الاصطناعي المعقدة دون صياغة طلبات يدوية لكل استعلام.

**كيف تعمل؟**

1. **التكامل**: تضمين RAG داخل هيكلية وكيل الذكاء الاصطناعي، مما يمكّنه من التعامل تلقائيًا مع مهام الاسترجاع والتوليد.
2. **الأتمتة**: تدير الأداة كامل العملية، من استلام إدخال المستخدم إلى توليد الاستجابة النهائية، دون الحاجة لطلبات صريحة لكل خطوة.
3. **الكفاءة**: تحسن أداء الوكيل عبر تبسيط عملية الاسترجاع والتوليد، مما يمكن من استجابات أسرع وأكثر دقة.

**مثال في وكيل السفر**:

- مدخل المستخدم: "أريد زيارة المتاحف في باريس."
- أداة RAG: تسترجع تلقائيًا معلومات عن المتاحف وتولد استجابة.
- الاستجابة المولدة: "إليك بعض أفضل المتاحف في باريس: متحف اللوفر، متحف أورسيه، ومركز بومبيدو."

### المقارنة

| الجانب                 | تقنية التهيئة                                       | الأداة                                               |
|------------------------|----------------------------------------------------|-----------------------------------------------------|
| **يدوي مقابل تلقائي**  | صياغة يدوية للطلبات لكل استعلام.                   | عملية مؤتمتة للاسترجاع والتوليد.                      |
| **التحكم**             | توفر تحكمًا أكبر في عملية الاسترجاع.               | تبسط وأتمتة عملية الاسترجاع والتوليد.                |
| **المرونة**            | تسمح بطلبات مخصصة بناءً على الاحتياجات المحددة.    | أكثر كفاءة للتطبيقات واسعة النطاق.                    |
| **التعقيد**            | تتطلب صياغة وتعديل الطلبات.                        | أسهل للتكامل داخل هيكل وكيل ذكاء اصطناعي.            |

### أمثلة عملية

**مثال تقنية التهيئة:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**مثال الأداة:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### تقييم الصلة

تقييم الصلة هو جانب أساسي من أداء وكيل الذكاء الاصطناعي. فهو يضمن أن المعلومات المسترجعة والمولدة من قبل الوكيل مناسبة ودقيقة ومفيدة للمستخدم. دعونا نستكشف كيفية تقييم الصلة في وكلاء الذكاء الاصطناعي، بما في ذلك أمثلة عملية وتقنيات.

#### المفاهيم الأساسية في تقييم الصلة

1. **الوعي بالسياق**:
   - يجب أن يفهم الوكيل سياق استعلام المستخدم لاسترجاع وتوليد معلومات ذات صلة.
   - مثال: إذا طلب المستخدم "أفضل المطاعم في باريس"، يجب أن يأخذ الوكيل في الاعتبار تفضيلات المستخدم مثل نوع المطبخ والميزانية.

2. **الدقة**:
   - يجب أن تكون المعلومات المقدمة من الوكيل صحيحة وحدثّة.
   - مثال: التوصية بالمطاعم المفتوحة حاليًا والتي تحظى بمراجعات جيدة بدلاً من الخيارات القديمة أو المغلقة.

3. **نية المستخدم**:
   - يجب أن يستنتج الوكيل نية المستخدم من وراء الاستعلام لتقديم أكثر المعلومات صلة.
   - مثال: إذا طلب المستخدم "فنادق بأسعار معقولة"، يجب على الوكيل إعطاء أولوية للخيارات الاقتصادية.

4. **حلقة التغذية الراجعة**:
   - جمع وتحليل ملاحظات المستخدم بصفة مستمرة تساعد الوكيل على تحسين عملية تقييم الصلة.
   - مثال: دمج تقييمات المستخدمين وملاحظاتهم على التوصيات السابقة لتحسين الردود المستقبلية.

#### تقنيات عملية لتقييم الصلة

1. **تسجيل الصلة**:
   - تعيين درجة صلة لكل عنصر مسترجع بناءً على مدى توافقه مع استعلام وتفضيلات المستخدم.
   - مثال:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **التصفية والترتيب**:
   - تصفية العناصر غير ذات الصلة وترتيب الباقي بناءً على درجات الصلة.
   - مثال:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # إرجاع أفضل 10 عناصر ذات صلة
     ```

3. **معالجة اللغة الطبيعية (NLP)**:
   - استخدام تقنيات معالجة اللغة لفهم استعلام المستخدم واسترجاع المعلومات ذات الصلة.
   - مثال:

     ```python
     def process_query(query):
         # استخدم معالجة اللغة الطبيعية لاستخراج المعلومات الرئيسية من استعلام المستخدم
         processed_query = nlp(query)
         return processed_query
     ```

4. **دمج ملاحظات المستخدم**:
   - جمع ملاحظات المستخدم على التوصيات المقدمة واستخدامها لضبط تقييمات الصلة المستقبلية.
   - مثال:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### مثال: تقييم الصلة في وكيل السفر

إليك مثالًا عمليًا لكيفية تقييم وكيل السفر لصلّة توصيات السفر:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # إرجاع أعلى 10 عناصر ذات صلة

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# مثال على الاستخدام
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### البحث مع النية

البحث مع النية ينطوي على فهم وتفسير الهدف أو الغرض الكامن وراء استعلام المستخدم لاسترجاع وتوليد أكثر المعلومات صلة وفائدة. هذا المنهج يتجاوز مجرد مطابقة الكلمات المفتاحية ويركز على فهم الاحتياجات الحقيقية وسياق المستخدم.

#### المفاهيم الأساسية في البحث مع النية

1. **فهم نية المستخدم**:
   - يمكن تصنيف نية المستخدم إلى ثلاثة أنواع رئيسية: معلوماتية، ملاحية، وتعامُلية.
     - **النية المعلوماتية**: يسعى المستخدم لمعلومات حول موضوع معين (مثل: "ما هي أفضل المتاحف في باريس؟").
     - **النية الملاحية**: يريد المستخدم الانتقال إلى موقع أو صفحة محددة (مثل: "الموقع الرسمي لمتحف اللوفر").
     - **النية التعامُلية**: يهدف المستخدم إلى إجراء عملية مثل حجز رحلة أو شراء (مثل: "حجز رحلة إلى باريس").
  
2. **الوعي بالسياق**:
   - تحليل سياق استعلام المستخدم يساعد في تحديد نيته بدقة، بما في ذلك التفاعلات السابقة، تفضيلات المستخدم، والتفاصيل الخاصة بالاستعلام الحالي.

3. **معالجة اللغة الطبيعية (NLP)**:
   - تُستخدم تقنيات NLP لفهم وتفسير الاستعلامات بلغة طبيعية يقدمها المستخدمون. يشمل ذلك مهام مثل التعرف على الكيانات، تحليل المشاعر، وتحليل الاستعلامات.

4. **التخصيص**:
   - تخصيص نتائج البحث بناءً على تاريخ المستخدم، تفضيلاته، وملاحظاته يعزز من صلة المعلومات المسترجعة.

#### مثال عملي: البحث مع النية في وكيل السفر

لنأخذ وكيل السفر كمثال لنرى كيف يمكن تطبيق البحث مع النية.

1. **جمع تفضيلات المستخدم**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **فهم نية المستخدم**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **الوعي بالسياق**
   ```python
   def analyze_context(query, user_history):
       # دمج الاستعلام الحالي مع تاريخ المستخدم لفهم السياق
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **البحث وتخصيص النتائج**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # منطق بحث نموذجي للنوايا الإعلامية
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # منطق بحث نموذجي للنوايا التنقلية
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # منطق بحث نموذجي للنوايا التفاعلية
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # منطق تخصيص نموذجي
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # إرجاع أفضل 10 نتائج مخصصة
   ```

5. **مثال على الاستخدام**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. توليد الكود كأداة

تستخدم وكلاء توليد الكود نماذج الذكاء الاصطناعي لكتابة وتنفيذ الكود، مما يحل المشكلات المعقدة ويؤتمت المهام.

### وكلاء توليد الكود

تستخدم وكلاء توليد الكود نماذج الذكاء الاصطناعي التوليدي لكتابة وتنفيذ الكود. يمكن لهؤلاء الوكلاء حل المشكلات المعقدة، وأتمتة المهام، وتوفير رؤى قيمة من خلال إنشاء وتشغيل الكود بلغات برمجة مختلفة.

#### التطبيقات العملية

1. **توليد الكود تلقائيًا**: إنشاء مقتطفات كود لمهام محددة، مثل تحليل البيانات، وسحب الويب، أو التعلم الآلي.
2. **SQL كطريقة RAG**: استخدام استعلامات SQL لاسترجاع البيانات والتعامل معها من قواعد البيانات.
3. **حل المشكلات**: إنشاء وتنفيذ كود لحل مشكلات محددة، مثل تحسين الخوارزميات أو تحليل البيانات.

#### مثال: وكيل توليد الكود لتحليل البيانات

تخيل أنك تصمم وكيل توليد كود. إليك كيف قد يعمل:

1. **المهمة**: تحليل مجموعة بيانات لتحديد الاتجاهات والأنماط.
2. **الخطوات**:
   - تحميل مجموعة البيانات إلى أداة تحليل البيانات.
   - إنشاء استعلامات SQL لتصفية وتجميع البيانات.
   - تنفيذ الاستعلامات واسترجاع النتائج.
   - استخدام النتائج لإنشاء تصورات ورؤى.
3. **الموارد المطلوبة**: الوصول إلى مجموعة البيانات، وأدوات تحليل البيانات، وقدرات SQL.
4. **الخبرة**: استخدام نتائج التحليلات السابقة لتحسين دقة وملاءمة التحليلات المستقبلية.

### مثال: وكيل توليد الكود لوكيل السفر

في هذا المثال، سنصمم وكيل توليد كود، وكيل السفر، لمساعدة المستخدمين في تخطيط رحلاتهم عن طريق توليد وتنفيذ كود. يمكن لهذا الوكيل التعامل مع مهام مثل جلب خيارات السفر، تصفية النتائج، وتجميع خطة الرحلة باستخدام الذكاء الاصطناعي التوليدي.

#### نظرة عامة على وكيل توليد الكود

1. **جمع تفضيلات المستخدم**: يجمع مدخلات المستخدم مثل الوجهة، تواريخ السفر، الميزانية، والاهتمامات.
2. **توليد كود لجلب البيانات**: ينشئ مقتطفات كود لاسترجاع بيانات حول الرحلات، الفنادق، والمعالم السياحية.
3. **تنفيذ الكود المولد**: يشغل الكود المولد لجلب المعلومات في الوقت الفعلي.
4. **توليد خطة الرحلة**: يجمع البيانات المسترجعة في خطة سفر مخصصة.
5. **التعديل بناءً على الملاحظات**: يستقبل ملاحظات المستخدم ويعيد توليد الكود إذا لزم الأمر لتحسين النتائج.

#### التنفيذ خطوة بخطوة

1. **جمع تفضيلات المستخدم**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **توليد كود لجلب البيانات**

   ```python
   def generate_code_to_fetch_data(preferences):
       # مثال: إنشاء كود للبحث عن الرحلات الجوية بناءً على تفضيلات المستخدم
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # مثال: إنشاء كود للبحث عن الفنادق
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **تنفيذ الكود المولد**

   ```python
   def execute_code(code):
       # تنفيذ الكود المُولد باستخدام exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **توليد خطة الرحلة**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **التعديل بناءً على الملاحظات**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # ضبط التفضيلات بناءً على ملاحظات المستخدم
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # إعادة توليد وتنفيذ الكود مع التفضيلات المحدثة
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### الاستفادة من الوعي البيئي والتفكير المنطقي

يمكن أن يحسن فهم مخطط الجدول عملية إنشاء الاستعلامات من خلال الاستفادة من الوعي البيئي والتفكير المنطقي.

إليك مثالًا على كيفية القيام بذلك:

1. **فهم المخطط**: يقوم النظام بفهم مخطط الجدول ويستخدم هذه المعلومات كأساس لإنشاء الاستعلامات.
2. **التعديل بناءً على الملاحظات**: يضبط النظام تفضيلات المستخدم بناءً على الملاحظات ويفكر في الحقول التي يجب تحديثها في المخطط.
3. **إنشاء وتنفيذ الاستعلامات**: يقوم النظام بإنشاء وتنفيذ استعلامات لجلب بيانات الرحلات والفنادق المحدثة بناءً على التفضيلات الجديدة.

إليك مثالًا محدّثًا على كود بايثون يدمج هذه المفاهيم:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # ضبط التفضيلات بناءً على ملاحظات المستخدم
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # الاستدلال بناءً على المخطط لضبط تفضيلات أخرى ذات صلة
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # منطق مخصص لضبط التفضيلات بناءً على المخطط والملاحظات
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # توليد كود لجلب بيانات الرحلات بناءً على التفضيلات المحدثة
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # توليد كود لجلب بيانات الفنادق بناءً على التفضيلات المحدثة
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # محاكاة تنفيذ الكود وإرجاع بيانات وهمية
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # توليد مسار الرحلة استنادًا إلى الرحلات الجوية، الفنادق، والمعالم
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# مثال للمخطط
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# مثال للاستخدام
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# إعادة توليد وتنفيذ الكود مع التفضيلات المحدثة
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### الشرح - الحجز بناءً على الملاحظات

1. **الوعي بالمخطط**: يحدد قاموس `schema` كيفية تعديل التفضيلات بناءً على الملاحظات. يتضمن حقولًا مثل `favorites` و`avoid` مع التعديلات المقابلة.
2. **تعديل التفضيلات (`adjust_based_on_feedback` method)**: تعدل هذه الطريقة التفضيلات بناءً على ملاحظات المستخدم والمخطط.
3. **التعديلات بناءً على البيئة (`adjust_based_on_environment` method)**: تخصص هذه الطريقة التعديلات استنادًا إلى المخطط والملاحظات.
4. **إنشاء وتنفيذ الاستعلامات**: ينشئ النظام الكود لجلب بيانات الرحلات والفنادق المحدثة بناءً على التفضيلات المعدلة ويُحاكي تنفيذ هذه الاستعلامات.
5. **توليد خطة الرحلة**: ينشئ النظام خطة جديدة بناءً على بيانات الرحلات والفنادق والمعالم السياحية الجديدة.

من خلال جعل النظام واعيًا بالبيئة ومنطقيًا استنادًا إلى المخطط، يمكنه إنشاء استعلامات أدق وأكثر ملاءمة، مما يؤدي إلى توصيات سفر أفضل وتجربة مستخدم أكثر تخصيصًا.

### استخدام SQL كطريقة توليد مدعومة بالاسترجاع (RAG)

تعد لغة SQL (لغة الاستعلام الهيكلية) أداة قوية للتفاعل مع قواعد البيانات. عند استخدامها كجزء من نهج توليد مدعوم بالاسترجاع (RAG)، يمكن لـ SQL استرجاع بيانات ذات صلة من قواعد البيانات لإعلام وإنشاء ردود أو إجراءات في وكلاء الذكاء الاصطناعي. دعونا نستكشف كيف يمكن استخدام SQL كطريقة RAG في سياق وكيل السفر.

#### المفاهيم الأساسية

1. **التفاعل مع قاعدة البيانات**:
   - تُستخدم SQL لاستعلام قواعد البيانات، واسترجاع المعلومات ذات الصلة، والتلاعب بالبيانات.
   - مثال: جلب تفاصيل الرحلات، ومعلومات الفنادق، والمعالم السياحية من قاعدة بيانات السفر.

2. **الاندماج مع RAG**:
   - تُولد استعلامات SQL بناءً على مدخلات وتفضيلات المستخدم.
   - تُستخدم البيانات المسترجعة بعد ذلك لتوليد توصيات أو إجراءات مخصصة.

3. **إنشاء استعلامات ديناميكية**:
   - ينشئ وكيل الذكاء الاصطناعي استعلامات SQL ديناميكية بناءً على السياق واحتياجات المستخدم.
   - مثال: تخصيص استعلامات SQL لتصفية النتائج بناءً على الميزانية، والتواريخ، والاهتمامات.

#### التطبيقات

- **توليد الكود التلقائي**: إنشاء مقتطفات الكود لمهام محددة.
- **SQL كطريقة RAG**: استخدام استعلامات SQL لمعالجة البيانات.
- **حل المشكلات**: إنشاء وتنفيذ كود لحل المشاكل.

**مثال**:
وكيل تحليل بيانات:

1. **المهمة**: تحليل مجموعة بيانات لاكتشاف الاتجاهات.
2. **الخطوات**:
   - تحميل مجموعة البيانات.
   - توليد استعلامات SQL لتصفية البيانات.
   - تنفيذ الاستعلامات واسترجاع النتائج.
   - توليد التصورات والرؤى.
3. **الموارد**: الوصول إلى مجموعة البيانات، وقدرات SQL.
4. **الخبرة**: استخدام النتائج السابقة لتحسين التحليلات المستقبلية.

#### مثال عملي: استخدام SQL في وكيل السفر

1. **جمع تفضيلات المستخدم**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **توليد استعلامات SQL**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **تنفيذ استعلامات SQL**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **توليد التوصيات**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### مثال على استعلامات SQL

1. **استعلام الرحلات**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **استعلام الفنادق**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **استعلام المعالم السياحية**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

من خلال استخدام SQL كجزء من تقنية توليد مدعوم بالاسترجاع (RAG)، يمكن لوكلاء الذكاء الاصطناعي مثل وكيل السفر استرجاع البيانات ذات الصلة واستخدامها ديناميكيًا لتقديم توصيات دقيقة وشخصية.

### مثال على التفكير الميتا معرفي

لكي نوضح تطبيقًا للتفكير الميتا معرفي، دعونا ننشئ وكيلًا بسيطًا *ينعكس على عملية اتخاذ قراراته* أثناء حل مشكلة. في هذا المثال، سنبني نظامًا حيث يحاول الوكيل تحسين اختيار الفندق، لكنه بعد ذلك يقيّم تفكيره الخاص ويعدل استراتيجيته عند ارتكابه لأخطاء أو اختيارات غير مثالية.

سنحاكي هذا باستخدام مثال أساسي حيث يختار الوكيل الفنادق بناءً على مزيج من السعر والجودة، لكنه "ينعكس" على قراراته ويعدل على ذلك وفقًا لذلك.

#### كيف يوضح هذا التفكير الميتا معرفي:

1. **القرار المبدئي**: يختار الوكيل أرخص فندق، بدون فهم تأثير الجودة.
2. **التفكير والتقييم**: بعد الاختيار الأولي، يراجع الوكيل ما إذا كان الفندق "سيئًا" باستخدام ملاحظات المستخدم. إذا وجد أن جودة الفندق كانت منخفضة جدًا، فإنه ينعكس على تفكيره.
3. **تعديل الاستراتيجية**: يعدل الوكيل استراتيجيته بناءً على التفكير، حيث يتحول من "الأرخص" إلى "الأعلى جودة"، وبالتالي يحسن عملية اتخاذ القرار في المرات القادمة.

إليك مثالًا:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # يخزن الفنادق التي تم اختيارها سابقًا
        self.corrected_choices = []  # يخزن الاختيارات المصححة
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # الاستراتيجيات المتاحة

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # لنفترض أن لدينا بعض ردود الفعل من المستخدم تخبرنا ما إذا كان الاختيار الأخير جيدًا أم لا
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # تعديل الاستراتيجية إذا كان الاختيار السابق غير مرضٍ
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# محاكاة قائمة بالفنادق (السعر والجودة)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# إنشاء وكيل
agent = HotelRecommendationAgent()

# الخطوة 1: يوصي الوكيل بفندق باستخدام استراتيجية "الأرخص"
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# الخطوة 2: يتأمل الوكيل في الاختيار ويعدل الاستراتيجية إذا لزم الأمر
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# الخطوة 3: يوصي الوكيل مرة أخرى، هذه المرة باستخدام الاستراتيجية المعدلة
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### قدرات التفكير الميتا معرفي للوكلاء

النقطة الأساسية هنا هي قدرة الوكيل على:
- تقييم اختياراته السابقة وعملية اتخاذ القرار.
- تعديل استراتيجيته بناءً على ذلك الانعكاس، أي التفكير الميتا معرفي في التطبيق.

هذا شكل بسيط من التفكير الميتا معرفي حيث يكون النظام قادرًا على تعديل عملية تفكيره بناءً على الملاحظات الداخلية.

### الخلاصة

التفكير الميتا معرفي هو أداة قوية يمكنها تعزيز قدرات وكلاء الذكاء الاصطناعي بشكل كبير. من خلال دمج العمليات الميتا معرفية، يمكنك تصميم وكلاء أكثر ذكاءً وقابلية للتكيف وكفاءة. استخدم الموارد الإضافية لاستكشاف عالم التفكير الميتا معرفي الرائع في وكلاء الذكاء الاصطناعي.

### هل لديك المزيد من الأسئلة حول نمط تصميم التفكير الميتا معرفي؟

انضم إلى [Microsoft Foundry Discord](https://aka.ms/ai-agents/discord) لتلتقي بمتعلمين آخرين، وتحضر ساعات المكتب، وتحصل على إجابات لأسئلتك حول وكلاء الذكاء الاصطناعي.

## الدرس السابق

[نمط تصميم الوكيل المتعدد](../08-multi-agent/README.md)

## الدرس التالي

[وكلاء الذكاء الاصطناعي في الإنتاج](../10-ai-agents-production/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**تنبيه**:  
تمت ترجمة هذا المستند باستخدام خدمة الترجمة الآلية [Co-op Translator](https://github.com/Azure/co-op-translator). بينما نسعى لتحقيق الدقة، يرجى العلم أن الترجمات الآلية قد تحتوي على أخطاء أو عدم دقة. يجب اعتبار المستند الأصلي بلغته الأصلية المصدر المعتمد. للمعلومات الحساسة أو المهمة، يُنصح بالاستعانة بخدمات الترجمة البشرية المهنية. نحن غير مسؤولين عن أي سوء فهم أو تفسير ناتج عن استخدام هذه الترجمة.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->