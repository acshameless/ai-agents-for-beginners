[![Multi-Agent Design](../../../translated_images/bg/lesson-9-thumbnail.38059e8af1a5b71d.webp)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(Кликнете върху изображението по-горе, за да гледате видеото на този урок)_
# Метакогниция при AI агенти

## Въведение

Добре дошли в урока за метакогниция при AI агенти! Тази глава е предназначена за начинаещи, които се интересуват от това как AI агентите могат да мислят за собствените си мисловни процеси. В края на този урок ще разберете ключови концепции и ще бъдете оборудвани с практически примери за прилагане на метакогниция в дизайна на AI агенти.

## Цели на обучението

След завършване на този урок ще можете да:

1. Разберете последствията от цикли на разсъждение в дефинициите на агенти.
2. Използвате техники за планиране и оценка, за да помогнете на самокоригиращи се агенти.
3. Създавате собствени агенти, способни да манипулират код за изпълнение на задачи.

## Въведение в Метакогницията

Метакогницията се отнася до когнитивните процеси от по-висок ред, които включват мислене за собственото мислене. За AI агентите това означава способността да оценяват и коригират действията си въз основа на самосъзнание и предишен опит. Метакогницията, или "мислене за мисленето," е важна концепция в развитието на агентни AI системи. Тя включва AI системи, които са наясно със собствените си вътрешни процеси и могат да наблюдават, регулират и адаптират поведението си съответно. Подобно на това как ние "четем стаята" или разглеждаме проблем. Това самосъзнание може да помогне на AI системите да вземат по-добри решения, да откриват грешки и да подобряват представянето си с времето — връщайки се отново към теста на Тюринг и дебата дали AI ще ни завземе.

В контекста на агентните AI системи, метакогницията може да помогне в решаването на няколко предизвикателства, като:
- Прозрачност: Осигуряване на възможността AI системите да обясняват своето разсъждение и решения.
- Разсъждение: Подобряване на способността на AI системите да синтезират информация и да вземат здрави решения.
- Адаптация: Позволяване на AI системите да се приспособяват към нови среди и променящи се условия.
- Възприятие: Подобряване на точността на AI системите в разпознаване и интерпретиране на данни от околната среда.

### Какво е Метакогниция?

Метакогницията, или "мислене за мисленето," е когнитивен процес от по-висок ред, който включва самосъзнание и саморегулация на собствения когнитивен процес. В областта на AI, метакогницията дава възможност на агентите да оценяват и адаптират своите стратегии и действия, водейки до подобрени възможности за решаване на проблеми и вземане на решения. Като разберете метакогницията, можете да проектирате AI агенти, които са не само по-интелигентни, но и по-адаптивни и ефективни. При истинска метакогниция AI би разсъждавал изрично за своето собствено разсъждение.

Пример: „Предпочетох по-евтини полети, защото… може би изпускам директни полети, затова нека проверя отново.“
Следене как и защо е избрал определен маршрут.
- Забелязване, че е направил грешки, защото е разчитал прекалено много на потребителските предпочитания от миналия път, затова променя своята стратегия за вземане на решения, а не само крайната препоръка.
- Диагностициране на модели като: „Всеки път, когато видя потребителя да споменава „прекалено натоварено“, трябва не само да премахна определени атракции, но и да осъзная, че методът ми на избиране на „топ атракции“ е дефектен, ако винаги ги класирам по популярност.“

### Значение на Метакогницията при AI Агентите

Метакогницията играе ключова роля в дизайна на AI агенти по няколко причини:

![Importance of Metacognition](../../../translated_images/bg/importance-of-metacognition.b381afe9aae352f7.webp)

- Саморефлексия: Агентите могат да оценят собственото си представяне и да идентифицират области за подобрение.
- Адаптивност: Агентите могат да коригират своите стратегии, основавайки се на минал опит и променящи се среди.
- Корекция на грешки: Агентите могат автономно да откриват и коригират грешки, водещо до по-точни резултати.
- Управление на ресурси: Агентите могат да оптимизират използването на ресурси като време и изчислителна мощ чрез планиране и оценка на действията.

## Компоненти на AI Агент

Преди да започнем с метакогнитивните процеси, е важно да разберем основните компоненти на AI агент. Типичен AI агент се състои от:

- Личност: Личността и характеристиките на агента, които определят как взаимодейства с потребителите.
- Инструменти: Възможностите и функциите, които агентът може да изпълнява.
- Умения: Знанията и експертизата, които агентът притежава.

Тези компоненти работят заедно, за да създадат „единица експертиза“, която може да изпълнява специфични задачи.

**Пример**:
Помислете за туристически агент — агенция, която не само планира вашата почивка, но и коригира маршрута си въз основа на данни в реално време и предишен опит от пътувания на клиенти.

### Пример: Метакогниция в Туристическа Агентска Услуга

Представете си, че проектирате туристическа агентска услуга, базирана на AI. Този агент, „Туристически агент“, помага на потребителите при планиране на ваканциите им. За да включите метакогниция, Туристическият агент трябва да оценява и адаптира действията си въз основа на самосъзнание и предишен опит. Ето как метакогницията може да играе роля:

#### Текуща задача

Текущата задача е да помогне на потребител да планира пътуване до Париж.

#### Стъпки за изпълнение на задачата

1. **Събиране на предпочитания на потребителя**: Попитайте потребителя за дати на пътуване, бюджет, интереси (напр. музеи, кухня, пазаруване) и конкретни изисквания.
2. **Извличане на информация**: Потърсете възможности за полети, настаняване, атракции и ресторанти, които отговарят на предпочитанията на потребителя.
3. **Генериране на препоръки**: Предложете персонализиран план с детайли за полети, резервации в хотели и предложени дейности.
4. **Корекция въз основа на обратна връзка**: Попитайте потребителя за мнение за препоръките и направете необходимите корекции.

#### Необходими ресурси

- Достъп до бази данни за полети и хотелски резервации.
- Информация за забележителности и ресторанти в Париж.
- Данни за обратна връзка от предишни взаимодействия.

#### Опит и саморефлексия

Туристическият агент използва метакогниция, за да оцени представянето си и да се учи от миналия опит. Например:

1. **Анализ на обратната връзка от потребителите**: Туристическият агент разглежда обратната връзка, за да определи кои препоръки са били добре приети и кои — не. Той коригира бъдещите си предложения съответно.
2. **Адаптивност**: Ако потребителят е споменал, че не харесва претъпканите места, Туристическият агент ще избягва да препоръчва популярни туристически обекти в пиков час.
3. **Корекция на грешки**: Ако агентът е направил грешка при минала резервация, например препоръчал е хотел, който е бил изцяло зает, той се учи да проверява наличността по-строго преди да направи препоръка.

#### Практически пример за разработчик

Ето опростен пример за това как може да изглежда кода на Туристически агент с интегрирана метакогниция:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # Търсете полети, хотели и атракции въз основа на предпочитанията
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # Анализирайте отзивите и коригирайте бъдещите препоръки
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Пример за използване
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### Защо е важна метакогницията

- **Саморефлексия**: Агентите могат да анализират представянето си и да откриват области за подобрение.
- **Адаптивност**: Агентите могат да променят стратегии по базирани на обратна връзка и променящи се условия.
- **Корекция на грешки**: Агентите могат автономно да откриват и поправят грешки.
- **Управление на ресурси**: Агентите могат да оптимизират използването на ресурси като време и изчислителна мощ.

Чрез включване на метакогниция, Туристическият агент може да предоставя по-персонализирани и точни препоръки за пътуване, подобрявайки общото изживяване на потребителя.

---

## 2. Планиране при агенти

Планирането е ключов компонент от поведението на AI агента. То включва очертаване на стъпките, необходими за постигане на цел, като се вземат предвид текущото състояние, ресурсите и възможните препятствия.

### Елементи на планиране

- **Текуща задача**: Определете ясно задачата.
- **Стъпки за изпълнение на задачата**: Разделете задачата на управляеми стъпки.
- **Необходими ресурси**: Идентифицирайте ресурсите, които са необходими.
- **Опит**: Използвайте минал опит, за да информирате планирането.

**Пример**:
Ето стъпките, които Туристическият агент трябва да предприеме, за да помогне на потребителя да планира пътуването си ефективно:

### Стъпки за Туристически агент

1. **Събиране на предпочитанията на потребителя**
   - Попитайте потребителя за детайли относно датите на пътуване, бюджета, интересите и всякакви конкретни изисквания.
   - Примери: „Кога планирате да пътувате?“ „Какъв е вашият бюджет?“ „Кои дейности предпочитате на почивка?“

2. **Извличане на информация**
   - Потърсете релевантни опции за пътуване въз основа на предпочитанията на потребителя.
   - **Полети**: Потърсете налични полети в рамките на бюджета и предпочитаните дати за пътуване.
   - **Настаняване**: Намерете хотели или наеми, които отговарят на предпочитанията по местоположение, цена и удобства.
   - **Атракции и ресторанти**: Идентифицирайте популярни атракции, дейности и заведения за хранене, съобразени с интересите на потребителя.

3. **Генериране на препоръки**
   - Съберете намерената информация в персонализиран план.
   - Осигурете детайли като варианти за полети, резервации в хотели и предложени дейности, като адаптирате препоръките към потребителските предпочитания.

4. **Представяне на плана на потребителя**
   - Споделете предложеното пътуване за преглед с потребителя.
   - Пример: „Ето предложен план за вашето пътуване до Париж. Включва подробности за полети, хотелски резервации и списък с препоръчани дейности и ресторанти. Кажете ми вашето мнение!“

5. **Събиране на обратна връзка**
   - Попитайте потребителя за мнение относно предложеното пътуване.
   - Примери: „Харесвате ли опциите за полети?“ „Хотелът подходящ ли е за вашите нужди?“ „Има ли дейности, които искате да добавите или премахнете?“

6. **Корекция на база обратната връзка**
   - Коригирайте плана според обратната връзка от потребителя.
   - Направете необходимите промени в препоръките за полети, настаняване и дейности, за да съответстват по-добре на предпочитанията.

7. **Крайно потвърждение**
   - Покажете обновения план за крайно одобрение от потребителя.
   - Пример: „Направих корекциите според вашите коментари. Ето обновения план. Изглежда ли ви добре?“

8. **Резервация и потвърждаване**
   - След одобрение от потребителя, пристъпете към резервация на полети, настаняване и предварително планирани дейности.
   - Изпратете потвърждения на потребителя.

9. **Продължаваща подкрепа**
   - Бъдете на разположение, за да помогнете при промени или допълнителни заявки преди и по време на пътуването.
   - Пример: „Ако имате нужда от допълнителна помощ по време на пътуването, не се колебайте да се свържете с мен по всяко време!“

### Пример за взаимодействие

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Пример за използване в рамките на заявка за резервиране
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. Корективна RAG система

Първо, нека започнем с разликата между RAG инструмент и превантивно зареждане на контекст

![RAG vs Context Loading](../../../translated_images/bg/rag-vs-context.9eae588520c00921.webp)

### Retrieval-Augmented Generation (RAG)

RAG комбинира система за извличане с генеративен модел. Когато е направена заявка, системата за извличане намира релевантни документи или данни от външен източник, и тази извлечена информация се използва за обогатяване на входа към генеративния модел. Това помага на модела да генерира по-точни и контекстуално релевантни отговори.

В RAG система агентът извлича релевантна информация от база знания и я използва за генериране на подходящи отговори или действия.

### Подход Корективен RAG

Подходът Корективен RAG се фокусира върху използването на RAG техники за коригиране на грешки и подобряване на точността на AI агентите. Това включва:

1. **Техника на подканване**: Използване на специфични подканвания, за да се насочи агентът към извличане на релевантна информация.
2. **Инструмент**: Прилагане на алгоритми и механизми, които позволяват на агента да оценява релевантността на извлечената информация и да генерира точни отговори.
3. **Оценка**: Непрекъснато оценяване на представянето на агента и правене на корекции за подобряване на точността и ефективността.

#### Пример: Корективен RAG при търсещ агент

Разгледайте търсещ агент, който извлича информация от уеб, за да отговаря на потребителски заявки. Подходът Корективен RAG може да включва:

1. **Техника на подканване**: Формулиране на търсещи заявки въз основа на входа на потребителя.
2. **Инструмент**: Използване на обработка на естествен език и машинно обучение за класиране и филтриране на резултатите от търсенето.
3. **Оценка**: Анализиране на обратната връзка от потребителя за идентифициране и корекция на неточности в извлечената информация.

### Корективен RAG в Туристически агент

Корективният RAG (Retrieval-Augmented Generation) подобрява способността на AI да извлича и генерира информация, като същевременно коригира неточности. Нека видим как Туристическият агент може да използва подхода Корективен RAG, за да предоставя по-точни и релевантни препоръки за пътуване.

Това включва:

- **Техника на подканване:** Използване на специфични подканвания, за да насочи агента в извличането на релевантна информация.
- **Инструмент:** Прилагане на алгоритми и механизми, които позволяват на агента да оценява релевантността на извлечената информация и да генерира точни отговори.
- **Оценка:** Непрекъснато оценяване на представянето на агента и правене на корекции за подобряване на точността и ефективността.

#### Стъпки за прилагане на Корективен RAG в Туристически агент

1. **Първоначално взаимодействие с потребителя**
   - Туристическият агент събира начални предпочитания от потребителя, като дестинация, дати за пътуване, бюджет и интереси.
   - Пример:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **Извличане на информация**
   - Туристическият агент извлича информация за полети, настаняване, атракции и ресторанти въз основа на предпочитанията на потребителя.
   - Пример:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **Генериране на първоначални препоръки**
   - Туристическият агент използва извлечената информация за създаване на персонализиран план.
   - Пример:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **Събиране на обратна връзка от потребителя**
   - Туристическият агент иска мнение на потребителя относно първоначалните препоръки.
   - Пример:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **Процес Корективен RAG**
   - **Техника на подканване**: Туристическият агент формулира нови търсещи заявки според обратната връзка от потребителя.
     - Пример:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **Инструмент**: Туристическият агент използва алгоритми за класиране и филтриране на новите резултати, като поставя акцент върху релевантността според обратната връзка.
     - Пример:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **Оценка**: Туристическият агент непрекъснато оценява релевантността и точността на препоръките чрез анализ на обратната връзка и прави необходими корекции.
     - Пример:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### Практически пример

Ето един опростен пример на Python код, който внедрява подхода Корективен RAG в Туристически агент:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# Пример за използване
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### Превантивно зареждане на контекст
Предварителното зареждане на контекста включва зареждане на релевантна контекстна или фонова информация в модела преди обработка на заявка. Това означава, че моделът има достъп до тази информация от самото начало, което може да му помогне да генерира по-информирани отговори, без да се налага да извлича допълнителни данни по време на процеса.

Ето един опростен пример за това как може да изглежда предварителното зареждане на контекста за приложение на туристически агент в Python:

```python
class TravelAgent:
    def __init__(self):
        # Предварително зареждане на популярни дестинации и тяхната информация
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # Извличане на информация за дестинации от предварително зареден контекст
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# Пример за използване
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### Обяснение

1. **Инициализация (`__init__` метод)**: Класът `TravelAgent` предварително зарежда речник, съдържащ информация за популярни дестинации като Париж, Токио, Ню Йорк и Сидни. Този речник включва детайли като страна, валута, език и основни атракции за всяка дестинация.

2. **Извличане на информация (`get_destination_info` метод)**: Когато потребител запитва за конкретна дестинация, методът `get_destination_info` извлича релевантната информация от предварително заредения речник с контекст.

Чрез предварително зареждане на контекста, приложението на туристическия агент може бързо да отговаря на потребителски запитвания, без да се налага да извлича тази информация от външен източник в реално време. Това прави приложението по-ефективно и отзивчиво.

### Иницииране на план с цел преди итерация

Инициирането на план с цел включва започване с ясна цел или очакван резултат. Чрез дефиниране на тази цел предварително, моделът може да я използва като водещ принцип през целия итеративен процес. Това помага да се гарантира, че всяка итерация приближава към постигането на желания резултат, като прави процеса по-ефективен и фокусиран.

Ето пример как може да инициирате пътуване с цел преди итерация за туристически агент в Python:

### Сценарий

Туристически агент иска да планира персонализирана ваканция за клиент. Целта е да се създаде пътуване, което максимизира удовлетвореността на клиента на базата на неговите предпочитания и бюджет.

### Стъпки

1. Дефиниране на предпочитанията и бюджета на клиента.
2. Иницииране на първоначалния план на база тези предпочитания.
3. Итерация за усъвършенстване на плана, оптимизирайки удовлетвореността на клиента.

#### Python код

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# Пример за използване
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### Обяснение на кода

1. **Инициализация (`__init__` метод)**: Класът `TravelAgent` се инициализира със списък от потенциални дестинации, всяка със съответни атрибути като име, цена и тип активност.

2. **Иницииране на план (`bootstrap_plan` метод)**: Този метод създава първоначален план за пътуване на база предпочитанията и бюджета на клиента. Той преминава през списъка с дестинации и ги добавя към плана, ако съответстват на предпочитанията на клиента и са в рамките на бюджета.

3. **Съответствие на предпочитанията (`match_preferences` метод)**: Този метод проверява дали дадена дестинация съвпада с предпочитанията на клиента.

4. **Итерация на плана (`iterate_plan` метод)**: Този метод усъвършенства първоначалния план като се опитва да замени всяка дестинация в плана с по-добро съвпадение, като взема предвид предпочитанията на клиента и бюджета.

5. **Изчисляване на цена (`calculate_cost` метод)**: Този метод изчислява общата стойност на текущия план, включително потенциална нова дестинация.

#### Примерна употреба

- **Първоначален план**: Туристическият агент създава първоначален план на базата на предпочитанията на клиента за разглеждане на забележителности и бюджет от 2000 долара.
- **Усъвършенстван план**: Туристическият агент итеративно подобрява плана, оптимизирайки спрямо предпочитанията и бюджета на клиента.

Чрез иницииране на плана с ясна цел (например максимизиране на удовлетвореността на клиента) и итерация за усъвършенстване, туристическият агент може да създаде персонализиран и оптимизиран маршрут за клиента. Този подход гарантира, че планът отговаря на предпочитанията и бюджета на клиента от самото начало и се подобрява с всяка итерация.

### Използване на големи езикови модели (LLM) за преподреждане и оценяване

Големите езикови модели (LLM) могат да се използват за преподреждане и оценяване чрез оценка на релевантността и качеството на извлечените документи или генерирани отговори. Ето как работи:

**Извличане:** Началният етап извлича набор от кандидати – документи или отговори на базата на заявката.

**Преподреждане:** LLM оценява тези кандидати и ги преподрежда спрямо тяхната релевантност и качество. Тази стъпка гарантира, че най-релевантната и качествена информация се показва първо.

**Оценяване:** LLM присвоява оценки на всеки кандидат, отразявайки тяхната релевантност и качество. Това помага при избора на най-добрия отговор или документ за потребителя.

Чрез използване на LLM за преподреждане и оценяване системата може да предостави по-точна и контекстуално релевантна информация, подобрявайки общото потребителско преживяване.

Ето пример как един туристически агент може да използва голям езиков модел (LLM) за преподреждане и оценяване на туристически дестинации според потребителските предпочитания в Python:

#### Сценарий – Пътуване според предпочитания

Туристически агент иска да препоръча най-добрите туристически дестинации на клиент въз основа на неговите предпочитания. LLM ще помогне да се преподредят и оценят дестинациите, за да се гарантира, че се показват най-релевантните опции.

#### Стъпки:

1. Събиране на потребителски предпочитания.
2. Извличане на списък с потенциални туристически дестинации.
3. Използване на LLM за преподреждане и оценяване на дестинациите спрямо потребителските предпочитания.

Ето как може да актуализирате предишния пример, за да използвате Azure OpenAI Services:

#### Изисквания

1. Трябва да имате Azure абонамент.
2. Създайте Azure OpenAI ресурс и получите API ключ.

#### Примерен Python код

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Генерирайте подсказка за Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # Дефинирайте заглавките и съдържанието на заявката
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # Извикайте Azure OpenAI API, за да получите пренаредените и оценени дестинации
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # Извлечете и върнете препоръките
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# Пример за използване
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### Обяснение на кода – Preference Booker

1. **Инициализация**: Класът `TravelAgent` се инициализира със списък от потенциални туристически дестинации, всяка с атрибути като име и описание.

2. **Получаване на препоръки (`get_recommendations` метод)**: Този метод генерира prompt за Azure OpenAI услугата на базата на предпочитанията на потребителя и прави HTTP POST заявка към Azure OpenAI API, за да получи преподредени и оценени дестинации.

3. **Генериране на prompt (`generate_prompt` метод)**: Този метод конструира prompt за Azure OpenAI, включващ потребителските предпочитания и списъка с дестинации. Prompt-ът насочва модела да преподреди и оцени дестинациите според предоставените предпочитания.

4. **API повикване**: Използва се библиотеката `requests` за извършване на HTTP POST заявка към Azure OpenAI API крайна точка. Отговорът съдържа преподредени и оценени дестинации.

5. **Примерна употреба**: Туристическият агент събира потребителски предпочитания (напр. интерес към разглеждане на забележителности и разнообразна култура) и използва Azure OpenAI услугата, за да получи препоръки за дестинации, преподредени и оценени.

Не забравяйте да замените `your_azure_openai_api_key` с вашия реален Azure OpenAI API ключ и `https://your-endpoint.com/...` с реалния URL адрес на вашето Azure OpenAI разполагане.

Чрез използване на LLM за преподреждане и оценяване, туристическият агент може да предлага по-персонализирани и релевантни пътешественически препоръки на клиентите, подобрявайки общото им преживяване.

### RAG: Техника за промптиране срещу инструмент

Retrieval-Augmented Generation (RAG) може да бъде както техника за промптиране, така и инструмент в разработката на AI агенти. Разбирането на разликата между двете може да ви помогне да използвате RAG по-ефективно във вашите проекти.

#### RAG като техника за промптиране

**Какво е това?**

- Като техника за промптиране, RAG включва формулиране на специфични заявки или промптове, които да насочват извличането на релевантна информация от голям корпус или база данни. Тази информация след това се използва за генериране на отговори или действия.

**Как работи:**

1. **Формулиране на промптове:** Създават се добре структурирани промптове или заявки на база задачата или входа на потребителя.
2. **Извличане на информация:** Промптовете се използват за търсене на релевантни данни от предварително съществуваща база знания или набор от данни.
3. **Генериране на отговор:** Комбинира се извлечената информация с генеративни AI модели за създаване на пълен и смислен отговор.

**Пример в туристически агент**:

- Вход от потребител: "Искам да посетя музеи в Париж."
- Промпт: "Намери най-добрите музеи в Париж."
- Извлечена информация: Детайли за Лувъра, Музея д’Орсе и др.
- Генериран отговор: "Ето някои от най-добрите музеи в Париж: Лувър, Музей д’Орсе и Център Помпиду."

#### RAG като инструмент

**Какво е това?**

- Като инструмент, RAG е интегрирана система, която автоматизира процеса на извличане и генериране, улеснявайки разработчиците при реализиране на сложни AI функционалности без необходимост от ръчно създаване на промптове за всяка заявка.

**Как работи:**

1. **Интеграция:** Вгражда RAG в архитектурата на AI агента, което позволява автоматично обработване на задачи за извличане и генериране.
2. **Автоматизация:** Инструментът управлява целия процес от приемане на входа на потребителя до генериране на крайния отговор, без нужда от явни промптове за всяка стъпка.
3. **Ефективност:** Подобрява производителността на агента, като оптимизира процеса на извличане и генериране, позволявайки по-бързи и точни отговори.

**Пример в туристически агент**:

- Вход от потребител: "Искам да посетя музеи в Париж."
- Инструмент RAG: Автоматично извлича информация за музеите и генерира отговор.
- Генериран отговор: "Ето някои от най-добрите музеи в Париж: Лувър, Музей д’Орсе и Център Помпиду."

### Сравнение

| Аспект                  | Техника за промптиране                                    | Инструмент                                           |
|-------------------------|------------------------------------------------------------|-----------------------------------------------------|
| **Ръчно срещу Автоматично** | Ръчно формулиране на промптове за всяка заявка.          | Автоматизиран процес за извличане и генериране.     |
| **Контрол**              | По-голям контрол върху процеса на извличане.               | Оптимизира и автоматизира извличането и генерирането.|
| **Гъвкавост**            | Позволява персонализирани промптове според конкретни нужди.| По-ефективен за мащабни приложения.                 |
| **Сложност**             | Изисква създаване и настройване на промптове.              | По-лесен за интеграция в архитектурата на AI агент.|


### Практически примери

**Пример за техника за промптиране:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**Пример за инструмент:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### Оценяване на релевантността

Оценяването на релевантността е ключов аспект от изпълнението на AI агентите. То гарантира, че информацията, извлечена и генерирана от агента, е подходяща, точна и полезна за потребителя. Нека разгледаме как да оценим релевантността при AI агенти, като включим практически примери и техники.

#### Ключови концепции при оценяване на релевантността

1. **Съзнание за контекста**:
   - Агентът трябва да разбира контекста на заявката на потребителя, за да извлича и генерира релевантна информация.
   - Пример: Ако потребителят иска „най-добрите ресторанти в Париж“, агентът трябва да вземе предвид предпочитанията му, като вид кухня и бюджет.

2. **Точност**:
   - Информацията, предоставена от агента, трябва да е фактически коректна и актуална.
   - Пример: Да се препоръчват ресторанти, които в момента са отворени и имат добри отзиви, а не остарели или затворени.

3. **Интенция на потребителя**:
   - Агентът трябва да разгадава намерението зад заявката, за да предостави най-релевантната информация.
   - Пример: Ако потребителят търси „бюджетни хотели“, агентът трябва да приоритизира достъпни опции.

4. **Цикъл на обратна връзка**:
   - Непрекъснатото събиране и анализиране на потребителска обратна връзка помага на агента да усъвършенства процеса на оценяване на релевантността.
   - Пример: Включване на оценки и обратна връзка от потребители за предишни препоръки с цел подобряване на бъдещите отговори.

#### Практически техники за оценяване на релевантността

1. **Оценяване по релевантност**:
   - Присвояване на оценка на релевантност на всеки извлечен елемент на база колко добре съвпада със заявката и предпочитанията на потребителя.
   - Пример:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **Филтриране и класиране**:
   - Филтриране на нерелевантни елементи и класиране на останалите според оценките им за релевантност.
   - Пример:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # Върни топ 10 най-свързани елемента
     ```

3. **Обработка на естествен език (NLP)**:
   - Използване на NLP техники за разбиране на заявката на потребителя и извличане на релевантна информация.
   - Пример:

     ```python
     def process_query(query):
         # Използвайте НЛП, за да извлечете ключова информация от заявката на потребителя
         processed_query = nlp(query)
         return processed_query
     ```

4. **Интеграция на потребителска обратна връзка**:
   - Събиране на обратна връзка от потребители за предоставените препоръки и използване за настройка на бъдещите оценки на релевантността.
   - Пример:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### Пример: Оценяване на релевантността в туристически агент

Ето един практичен пример как туристически агент може да оцени релевантността на препоръките за пътуване:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # Върнете топ 10 релевантни елемента

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# Пример за използване
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### Търсене с интенция

Търсенето с интенция включва разбиране и интерпретиране на основната цел или мотив зад заявката на потребителя, за да се извлече и генерира най-подходящата и полезна информация. Този подход надхвърля просто съвпадение на ключови думи и се фокусира върху улавяне на реалните нужди и контекста на потребителя.

#### Ключови концепции при търсене с интенция

1. **Разбиране на потребителската интенция**:
   - Потребителската интенция може да се категоризира в три основни типа: информационна, навигационна и транзакционна.
     - **Информационна интенция**: Потребителят търси информация по тема (напр. „Кои са най-добрите музеи в Париж?“).
     - **Навигационна интенция**: Потребителят иска да посети конкретен сайт или страница (напр. „Официален уебсайт на Лувъра“).
     - **Транзакционна интенция**: Потребителят желае да извърши транзакция, например да резервира полет или да направи покупка (напр. „Резервирай полет до Париж“).

2. **Осъзнаване на контекста**:
   - Анализиране на контекста на заявката на потребителя, включително предишни взаимодействия, предпочитания и конкретни детайли от текущата заявка.

3. **Обработка на естествен език (NLP)**:
   - Използват се техники за обработка на естествен език за разбиране и интерпретация на естествените езикови заявки на потребителя. Това включва задачи като разпознаване на обекти, анализ на настроения и обработка на заявките.

4. **Персонализация**:
   - Персонализиране на резултатите от търsenето спрямо историята, предпочитанията и обратната връзка на потребителя повишава релевантността на извлечената информация.

#### Практически пример: Търсене с интенция в туристически агент

Нека използваме Travel Agent като пример за имплементиране на търсене с интенция.

1. **Събиране на потребителски предпочитания**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Разбиране на потребителската интенция**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **Осъзнаване на контекста**
   ```python
   def analyze_context(query, user_history):
       # Комбинирайте текущата заявка с историята на потребителя, за да разберете контекста
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **Търсене и персонализиране на резултатите**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # Примерна логика за търсене при информационен намерение
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # Примерна логика за търсене при навигационно намерение
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # Примерна логика за търсене при транзакционно намерение
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # Примерна логика за персонализация
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # Връща топ 10 персонализирани резултата
   ```

5. **Пример за използване**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. Генериране на код като инструмент

Агентите, генериращи код, използват AI модели за писане и изпълнение на код, решавайки сложни проблеми и автоматизирайки задачи.

### Агенти, генериращи код

Агентите, генериращи код, използват генеративни AI модели за писане и изпълнение на код. Тези агенти могат да решават сложни проблеми, да автоматизират задачи и да предоставят ценни прозрения чрез генериране и изпълнение на код на различни програмни езици.

#### Практически приложения

1. **Автоматизирано генериране на код**: Генериране на кодови фрагменти за специфични задачи, като анализ на данни, уеб скрейпинг или машинно обучение.
2. **SQL като RAG**: Използване на SQL заявки за извличане и манипулиране на данни от бази данни.
3. **Решаване на проблеми**: Създаване и изпълнение на код за решаване на конкретни проблеми, като оптимизиране на алгоритми или анализ на данни.

#### Пример: Агент, генериращ код за анализ на данни

Представете си, че проектирате агент, генериращ код. Ето как може да работи:

1. **Задача**: Анализ на набор от данни за идентифициране на тенденции и модели.
2. **Стъпки**:
   - Зареждане на набора от данни в инструмент за анализ на данни.
   - Генериране на SQL заявки за филтриране и агрегиране на данните.
   - Изпълнение на заявките и извличане на резултатите.
   - Използване на резултатите за генериране на визуализации и прозрения.
3. **Необходими ресурси**: Достъп до набора от данни, инструменти за анализ на данни и SQL възможности.
4. **Опит**: Използване на предишни резултати от анализи за подобряване на точността и релевантността на бъдещи анализи.

### Пример: Агент, генериращ код за туристически агент

В този пример ще проектираме агент, генериращ код, Travel Agent, за да помага на потребителите с планирането на пътуване чрез генериране и изпълнение на код. Този агент може да обработва задачи като извличане на опции за пътуване, филтриране на резултати и съставяне на план с помощта на генеративен AI.

#### Преглед на агента, генериращ код

1. **Събиране на потребителски предпочитания**: Събира входни данни от потребителя като дестинация, дати на пътуване, бюджет и интереси.
2. **Генериране на код за извличане на данни**: Генерира кодови фрагменти за извличане на информация за полети, хотели и атракции.
3. **Изпълнение на генерирания код**: Изпълнява генерирания код за извличане на актуална информация.
4. **Генериране на план за пътуване**: Обединява извлечените данни в персонализиран план за пътуване.
5. **Коригиране въз основа на обратна връзка**: Получава обратна връзка от потребителя и при необходимост генерира наново кода за подобряване на резултатите.

#### Стъпка по стъпка изпълнение

1. **Събиране на потребителски предпочитания**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генериране на код за извличане на данни**

   ```python
   def generate_code_to_fetch_data(preferences):
       # Пример: Генериране на код за търсене на полети според предпочитанията на потребителя
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # Пример: Генериране на код за търсене на хотели
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **Изпълнение на генерирания код**

   ```python
   def execute_code(code):
       # Изпълнете генерирания код с помощта на exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **Генериране на план за пътуване**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **Коригиране въз основа на обратна връзка**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # Коригирайте предпочитанията според обратната връзка от потребителя
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # Генерирайте отново и изпълнете кода с актуализирани предпочитания
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### Използване на осъзнатост за средата и разсъждения

На базата на схемата на таблицата може да се подобри процесът на генериране на заявки чрез използване на осъзнатост за средата и разсъждения.

Ето пример как това може да се направи:

1. **Разбиране на схемата**: Системата разбира схемата на таблицата и използва тази информация, за да обоснове генерирането на заявки.
2. **Корекции въз основа на обратна връзка**: Системата коригира потребителските предпочитания според обратната връзка и разсъждава кои полета в схемата трябва да бъдат актуализирани.
3. **Генериране и изпълнение на заявки**: Системата генерира и изпълнява заявки за извличане на актуализирани данни за полети и хотели въз основа на новите предпочитания.

Ето актуализиран Python примерен код, който включва тези концепции:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # Коригирайте предпочитанията въз основа на обратната връзка от потребителя
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # Обосновка въз основа на схемата за коригиране на други свързани предпочитания
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # Персонализирана логика за коригиране на предпочитания въз основа на схемата и обратната връзка
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # Генерирайте код за извличане на данни за полети въз основа на актуализираните предпочитания
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # Генерирайте код за извличане на данни за хотели въз основа на актуализираните предпочитания
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # Симулирайте изпълнението на кода и върнете примерни данни
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # Генерирайте маршрут въз основа на полети, хотели и атракции
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# Примерна схема
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# Примерна употреба
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# Прегенерирайте и изпълнете кода с актуализирани предпочитания
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### Обяснение - Резервация на база обратна връзка

1. **Осъзнатост за схемата**: Речникът `schema` дефинира как предпочитанията трябва да се коригират въз основа на обратна връзка. Включва полета като `favorites` и `avoid` с отговарящи корекции.
2. **Коригиране на предпочитанията (метод `adjust_based_on_feedback`)**: Този метод коригира предпочитанията според обратната връзка на потребителя и схемата.
3. **Корекции въз основа на средата (метод `adjust_based_on_environment`)**: Този метод персонализира корекциите според схемата и обратната връзка.
4. **Генериране и изпълнение на заявки**: Системата генерира код за извличане на актуализирани данни за полети и хотели според коригираните предпочитания и симулира изпълнението на тези заявки.
5. **Генериране на план за пътуване**: Системата създава актуализиран план за пътуване въз основа на новите данни за полети, хотели и атракции.

Чрез осигуряване на осъзнатост на средата и разсъждения въз основа на схемата, системата може да генерира по-точни и релевантни заявки, водещи до по-добри препоръки за пътуване и по-персонализирано изживяване на потребителя.

### Използване на SQL като техника за Retrieval-Augmented Generation (RAG)

SQL (Structured Query Language) е мощен инструмент за работа с бази данни. Когато се използва като част от подход Retrieval-Augmented Generation (RAG), SQL може да извлича релевантна информация от бази данни, за да информира и генерира отговори или действия в AI агенти. Нека разгледаме как SQL може да се използва като RAG техника в контекста на туристически агент.

#### Ключови концепции

1. **Взаимодействие с базата данни**:
   - SQL се използва за заявяване на бази данни, извличане на релевантна информация и манипулиране на данни.
   - Пример: Извличане на детайли за полети, информация за хотели и атракции от туристическа база данни.

2. **Интеграция с RAG**:
   - SQL заявки се генерират въз основа на входа от потребителя и предпочитанията му.
   - Извлечените данни се използват за генериране на персонализирани препоръки или действия.

3. **Динамично генериране на заявки**:
   - AI агентът генерира динамични SQL заявки според контекста и нуждите на потребителя.
   - Пример: Персонализиране на SQL заявки, за да филтрират резултати според бюджет, дати и интереси.

#### Приложения

- **Автоматизирано генериране на код**: Генериране на кодови фрагменти за специфични задачи.
- **SQL като RAG**: Използване на SQL заявки за манипулиране на данни.
- **Решаване на проблеми**: Създаване и изпълнение на код за решаване на проблеми.

**Пример**:
Аналитичен агент за данни:

1. **Задача**: Анализ на набор от данни за намиране на тенденции.
2. **Стъпки**:
   - Зареждане на набора от данни.
   - Генериране на SQL заявки за филтриране на данни.
   - Изпълнение на заявки и извличане на резултати.
   - Генериране на визуализации и прозрения.
3. **Ресурси**: Достъп до набор от данни, възможности за SQL.
4. **Опит**: Използване на предишни резултати за подобряване на бъдещи анализи.

#### Практически пример: Използване на SQL в туристически агент

1. **Събиране на потребителски предпочитания**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генериране на SQL заявки**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **Изпълнение на SQL заявки**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **Генериране на препоръки**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### Примерни SQL заявки

1. **Заявка за полети**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **Заявка за хотели**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **Заявка за атракции**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

Използвайки SQL като част от техниката Retrieval-Augmented Generation (RAG), AI агенти като Travel Agent могат динамично да извличат и използват релевантни данни за предоставяне на точни и персонализирани препоръки.

### Пример за метакогниция

За да демонстрираме реализирането на метакогниция, нека създадем прост агент, който *размишлява върху процеса на вземане на решения* по време на решаване на проблем. За този пример ще изградим система, където агентът се опитва да оптимизира избора на хотел, но после оценява собственото си разсъждение и коригира стратегията си, когато прави грешки или непълноценни избори.

Ще симулираме това, използвайки основен пример, където агентът избира хотели на базата на комбинация от цена и качество, но „отразява“ решенията си и се коригира съответно.

#### Как това илюстрира метакогницията:

1. **Първоначално решение**: Агентът ще избере най-евтиния хотел, без да разбира влиянието на качеството.
2. **Размисъл и оценка**: След първоначалния избор, агентът проверява дали хотелът е „лош“ избор чрез обратна връзка от потребителя. Ако установи, че качеството на хотела е било твърде ниско, той размишлява върху разсъжденията си.
3. **Коригиране на стратегията**: Агентът коригира стратегията си въз основа на размишленията, като превключва от „най-евтин“ към „най-високо качество“, подобрявайки процеса на вземане на решения в бъдещи итерации.

Ето пример:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # Съхранява избраните по-рано хотели
        self.corrected_choices = []  # Съхранява коригираните избори
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # Налични стратегии

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # Да предположим, че имаме обратна връзка от потребителя, която ни казва дали последният избор е бил добър или не
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # Коригиране на стратегията, ако предишният избор е бил неудовлетворителен
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# Симулира списък с хотели (цена и качество)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# Създаване на агент
agent = HotelRecommendationAgent()

# Стъпка 1: Агентът препоръчва хотел, използвайки стратегията "най-евтин"
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# Стъпка 2: Агентът се замисля за избора и при необходимост коригира стратегията
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# Стъпка 3: Агентът препоръчва отново, този път използвайки коригираната стратегия
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### Метакогнитивни способности на агентите

Основното тук е способността на агента да:
- Оценява предишните си избори и процеса на вземане на решения.
- Коригира стратегията си въз основа на този размисъл, т.е. метакогниция в действие.

Това е проста форма на метакогниция, при която системата може да коригира процеса си на разсъждение въз основа на вътрешна обратна връзка.

### Заключение

Метакогницията е мощен инструмент, който може значително да подобри възможностите на AI агенти. Чрез включване на метакогнитивни процеси може да проектирате агенти, които са по-интелигентни, адаптивни и ефективни. Използвайте допълнителните ресурси, за да изследвате по-задълбочено завладяващия свят на метакогницията в AI агенти.

### Имате още въпроси относно шаблона за дизайн на метакогниция?

Присъединете се към [Microsoft Foundry Discord](https://aka.ms/ai-agents/discord), за да се срещнете с други обучаващи се, да посетите офис часове и да получите отговори на въпросите си за AI агенти.

## Предишен урок

[Multi-Agent Design Pattern](../08-multi-agent/README.md)

## Следващ урок

[AI Agents in Production](../10-ai-agents-production/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**Отказ от отговорност**:  
Този документ е преведен с помощта на AI преводаческа услуга [Co-op Translator](https://github.com/Azure/co-op-translator). Въпреки че се стремим към точност, моля, имайте предвид, че автоматичните преводи може да съдържат грешки или неточности. Оригиналният документ на неговия роден език трябва да се счита за авторитетен източник. За критична информация се препоръчва професионален превод от човек. Ние не носим отговорност за каквито и да било недоразумения или неправилни тълкувания, произтичащи от използването на този превод.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->