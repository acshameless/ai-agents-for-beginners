[![תכנון מרובה סוכנים](../../../translated_images/he/lesson-9-thumbnail.38059e8af1a5b71d.webp)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(לחץ על התמונה למעלה לצפייה בסרטון של השיעור הזה)_
# מטה־קוגניציה בסוכני בינה מלאכותית

## מבוא

ברוכים הבאים לשיעור על מטה־קוגניציה בסוכני בינה מלאכותית! פרק זה מיועד למתחילים הסקרנים לגבי איך סוכנים של בינה מלאכותית יכולים "לחשוב" על תהליכי החשיבה שלהם עצמם. בסוף השיעור הזה, תבינו מושגים מרכזיים ותהיו מצוידים בדוגמאות מעשיות ליישום מטה־קוגניציה בעיצוב סוכנים.

## מטרות הלמידה

לאחר השלמת שיעור זה, תדעו:

1. להבין את השלכות הלולאות של נימוק בהגדרות סוכן.
2. להשתמש בטכניקות תכנון והערכה כדי לסייע לסוכנים התוקנים בעצמם.
3. ליצור סוכנים משלכם המסוגלים למניפולציה של קוד כדי לבצע משימות.

## מבוא למטה־קוגניציה

מטה־קוגניציה מתייחסת לתהליכים קוגניטיביים מתקדמים המעורבים במחשבה על המחשבה עצמה. עבור סוכני בינה מלאכותית, זאת אומרת היכולת להעריך ולהתאים את פעולותיהם על בסיס מודעות עצמית וניסיון עבר. מטה־קוגניציה, או "מחשבה על המחשבה", הוא מושג חשוב בפיתוח מערכות בינה סוכנית. זה כולל מערכות בינה שמודעות לתהליכים הפנימיים שלהן ויכולות לנטר, לווסת ולהתאים את ההתנהגות שלהן בהתאם. בדומה לאופן שבו אנחנו קוראים את החדר או בוחנים בעיה. המודעות העצמית הזו יכולה לעזור למערכות בינה לקבל החלטות טובות יותר, לזהות שגיאות ולשפר את הביצועים שלהן לאורך זמן — שוב מקשרת חזרה למבחן טיורינג ולדיון האם בינה מלאכותית תשתלט.

בהקשר של מערכות בינה סוכניות, מטה־קוגניציה יכולה לסייע בטיפול בכמה אתגרים, כגון:
- שקיפות: הבטחת יכולת המערכות להסביר את הנימוק וההחלטות שלהן.
- נימוק: חיזוק היכולת של המערכות לסנתז מידע ולקבל החלטות מושכלות.
- התאמה: מתן אפשרות למערכות להתאים עצמן לסביבות חדשות ולתנאים משתנים.
- תפיסה: שיפור דיוק המערכות בזיהוי ופירוש נתונים מהסביבה שלהן.

### מהי מטה־קוגניציה?

מטה־קוגניציה, או "מחשבה על המחשבה", היא תהליך קוגניטיבי מתוצב שמערב מודעות עצמית וויסות עצמי של תהליכים קוגניטיביים. בתחום הבינה המלאכותית, מטה־קוגניציה מאפשרת לסוכנים להעריך ולהתאים את האסטרטגיות והפעולות שלהם, מה שמוביל לשיפור בפתרון בעיות ובקבלת החלטות. על ידי הבנת מטה־קוגניציה, תוכלו לעצב סוכני בינה שלא רק חכמים יותר, אלא גם גמישים ויעילים יותר. במטה־קוגניציה אמיתית, תראו את הבינה חושבת במפורש על הנימוקים שלה עצמם.

דוגמה: "העדפתי טיסות זולות יותר כי… אולי אני מפספס טיסות ישירות, אז בואו אבדוק שוב.".
מעקב אחרי איך או למה היא בחרה במסלול מסוים.
- לציין שהיא עשתה טעויות כי היא הסתמכה יותר מדי על העדפות המשתמש מהמקרה הקודם, ולכן היא משנה את אסטרטגיית קבלת ההחלטות ולא רק את ההמלצה הסופית.
- לאבחן דפוסים כמו: "כל פעם שאני רואה שהמשתמש מזכיר 'יותר מדי צפוף', לא רק שאסיר אטרקציות מסוימות אלא גם אשקף שהשיטה שלי לבחירת 'אטרקציות מובילות' פגומה אם אני תמיד מדורג לפי פופולריות."

### חשיבות המטה־קוגניציה בסוכני בינה

מטה־קוגניציה משחקת תפקיד מרכזי בעיצוב סוכני בינה ממספר סיבות:

![חשיבות המטה־קוגניציה](../../../translated_images/he/importance-of-metacognition.b381afe9aae352f7.webp)

- התבוננות עצמית: סוכנים יכולים להעריך את הביצועים שלהם ולזהות נקודות לשיפור.
- הסתגלות: סוכנים יכולים לשנות אסטרטגיות בהתבסס על ניסיונות עבר וסביבות משתנות.
- תיקון שגיאות: סוכנים יכולים לזהות ולתקן שגיאות באופן אוטונומי, מה שמוביל לתוצאות מדויקות יותר.
- ניהול משאבים: סוכנים יכולים לייעל שימוש במשאבים, כגון זמן וכוח חישוב, באמצעות תכנון והערכה של פעולותיהם.

## מרכיבים של סוכן בינה מלאכותית

לפני שנצלול לתהליכים מטה־קוגניטיביים, חשוב להבין את המרכיבים הבסיסיים של סוכן בינה מלאכותית. סוכן בינה מלאכותית בדרך כלל מורכב מ:

- פרסונה: האישיות והתכונות של הסוכן, שמגדירות כיצד הוא מתקשר עם משתמשים.
- כלים: היכולות והפונקציות שהסוכן יכול לבצע.
- כישורים: הידע והמומחיות שהסוכן מחזיק.

מרכיבים אלה פועלים יחד ליצירת "יחידת מומחיות" שיכולה לבצע משימות ספציפיות.

**דוגמה**:
תארו לעצמכם סוכן נסיעות, שירות סוכנות שאינו רק מתכנן את החופשה שלכם אלא גם מתאים את נתיבו בהתבסס על נתונים בזמן אמת וניסיון מסע לקוחות בעבר.

### דוגמה: מטה־קוגניציה בשירות סוכן נסיעות

דמיינו שאתם מעצבים שירות סוכן נסיעות המופעל באמצעות בינה מלאכותית. סוכן זה, "סוכן נסיעות", מסייע למשתמשים בתכנון חופשותיהם. כדי לשלב מטה־קוגניציה, סוכן הנסיעות צריך להעריך ולהתאים את פעולותיו על בסיס מודעות עצמית וניסיון עבר. כך מטה־קוגניציה יכולה לשחק תפקיד:

#### המשימה הנוכחית

המשימה הנוכחית היא לעזור למשתמש לתכנן נסיעה לפריז.

#### שלבים להשלמת המשימה

1. **איסוף העדפות משתמש**: שאל את המשתמש לגבי תאריכי הנסיעה, התקציב, תחומי העניין (למשל מוזיאונים, קולינריה, קניות), וכל דרישה ספציפית.
2. **שליפת מידע**: חפש אפשרויות טיסה, מקומות לינה, אטרקציות ומסעדות המתאימות להעדפות המשתמש.
3. **יצירת המלצות**: ספק מסלול מותאם אישית עם פרטי טיסה, הזמנות מלון ופעילויות מוצעות.
4. **התאמה בהסתמך על משוב**: שאל את המשתמש על המשוב לגבי ההמלצות ובצע התאמות נחוצות.

#### משאבים נדרשים

- גישה למסדי נתוני טיסות והזמנות מלון.
- מידע על אטרקציות ומסעדות פריזאיות.
- נתוני משוב משתמשים מאינטראקציות קודמות.

#### ניסיון והתבוננות עצמית

סוכן הנסיעות משתמש במטה־קוגניציה כדי להעריך את ביצועיו וללמוד מניסיונות קודמים. לדוגמה:

1. **ניתוח משוב משתמשים**: סוכן הנסיעות סוקר את משוב המשתמשים כדי לקבוע אילו המלצות זכו לקבלה ואילו לא. הוא מתאים את ההצעות העתידיות בהתאם.
2. **יכולת הסתגלות**: אם משתמש ציין בעבר אי־חיבה למקומות צפופים, סוכן הנסיעות יימנע מהמלצת מוקדי תיירות פופולריים בשעות שיא בעתיד.
3. **תיקון שגיאות**: אם סוכן הנסיעות ביצע טעות בהזמנה בעבר, כגון המלצה על מלון שהיה מלא, הוא ילמד לבדוק זמינות ביתר קפדנות לפני מתן המלצות.

#### דוגמה מעשית למפתח

הנה דוגמה מפושטת כיצד הקוד של סוכן הנסיעות עשוי להיראות בעת שילוב מטה־קוגניציה:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # חפש טיסות, מלונות ואטרקציות בהתאם להעדפות
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # נתח משוב והתאם המלצות עתידיות
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# דוגמה לשימוש
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### מדוע מטה־קוגניציה חשובה

- **התבוננות עצמית**: סוכנים יכולים לנתח את ביצועיהם ולזהות אזורים לשיפור.
- **הסתגלות**: סוכנים יכולים לשנות אסטרטגיות בהתבסס על משוב ותנאים משתנים.
- **תיקון שגיאות**: סוכנים יכולים לזהות ולתקן טעויות באופן אוטונומי.
- **ניהול משאבים**: סוכנים יכולים לייעל שימוש במשאבים, כגון זמן וכוח חישוב.

על ידי שילוב מטה־קוגניציה, סוכן הנסיעות יכול לספק המלצות מותאמות ומדויקות יותר, ולשפר את חוויית המשתמש הכוללת.

---

## 2. תכנון בסוכנים

תכנון הוא מרכיב קריטי בהתנהגות סוכני בינה מלאכותית. הוא כולל פירוט השלבים הנדרשים להשגת מטרה, בהתחשב במצב הנוכחי, במשאבים ובמכשולים אפשריים.

### רכיבי תכנון

- **המשימה הנוכחית**: להגדיר את המשימה בצורה ברורה.
- **שלבים להשלמת המשימה**: לפרק את המשימה לצעדים ניתנים לניהול.
- **משאבים נדרשים**: לזהות את המשאבים הנחוצים.
- **ניסיון**: להשתמש בניסיונות עבר כדי ליידע את התכנון.

**דוגמה**:
להלן השלבים שסוכן הנסיעות צריך לבצע כדי לסייע למשתמש בתכנון הנסיעה ביעילות:

### שלבים עבור סוכן הנסיעות

1. **איסוף העדפות משתמש**
   - שאל את המשתמש לגבי פרטי תאריכי הנסיעה, התקציב, תחומי העניין וכל דרישה ספציפית.
   - דוגמאות: "מתי אתה מתכנן לנסוע?" "מה טווח התקציב שלך?" "אילו פעילויות אתה נהנה בחופשה?"

2. **שליפת מידע**
   - חפש אפשרויות טיול רלוונטיות בהתבסס על העדפות המשתמש.
   - **טיסות**: חפש טיסות זמינות במסגרת התקציב ותאריכי הנסיעה המועדפים של המשתמש.
   - **לינות**: מצא בתי מלון או נכסי השכרה התואמים את העדפות המשתמש למיקום, מחיר ושירותים.
   - **אטרקציות ומסעדות**: זהה אטרקציות פופולריות, פעילויות ואפשרויות אוכל התואמות לתחומי העניין של המשתמש.

3. **יצירת המלצות**
   - כנס את המידע שנשלף לתוך מסלול מותאם אישית.
   - ספק פרטים כגון אפשרויות טיסה, הזמנות למלון והמלצות על פעילויות, תוך התאמת ההמלצות להעדפות המשתמש.

4. **הצגת המסלול למשתמש**
   - שתף את המסלול המוצע עם המשתמש לעיונו.
   - דוגמה: "הנה מסלול מוצע עבור הנסיעה שלך לפריז. הוא כולל פרטי טיסה, הזמנות מלון ורשימת פעילויות ומסעדות מומלצות. ספר לי מה דעתך!"

5. **איסוף משוב**
   - שאל את המשתמש עבור משוב על המסלול המוצע.
   - דוגמאות: "האם אתה אוהב את אפשרויות הטיסה?" "האם המלון מתאים לצרכיך?" "האם יש פעילויות שתרצה להוסיף או להסיר?"

6. **התאמה על סמך משוב**
   - שנה את המסלול בהתבסס על משוב המשתמש.
   - בצע שינויים נחוצים בהמלצות טיסה, לינה ופעילויות כדי להתאים טוב יותר להעדפות המשתמש.

7. **אישור סופי**
   - הצג את המסלול המעודכן למשתמש לאישור סופי.
   - דוגמה: "ביצעתי את ההתאמות בהתבסס על המשוב שלך. הנה המסלול המעודכן. האם הכל נראה בסדר?"

8. **הזמנה ואישור הזמנות**
   - לאחר שמשתמש מאשר את המסלול, המשך להזמין טיסות, לינות וכל פעילויות מתוכננות מראש.
   - שלח פרטי אישור למשתמש.

9. **מתן תמיכה שוטפת**
   - הישאר זמין לסייע למשתמש בכל שינוי או בקשה נוספת לפני ובמהלך הנסיעה.
   - דוגמה: "אם תזדקק לעזרה נוספת במהלך הנסיעה, אל תהסס לפנות אליי בכל זמן!"

### דוגמת אינטראקציה

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# דוגמה לשימוש בתוך בקשה לבוז
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. מערכת RAG מתקנת

ראשית נתחיל בהבנת ההבדל בין RAG Tool לבין Pre-emptive Context Load

![RAG vs Context Loading](../../../translated_images/he/rag-vs-context.9eae588520c00921.webp)

### שליפת תוספת יצירה (Retrieval-Augmented Generation, RAG)

RAG משלב מערכת שליפה עם מודל יצירתי. כאשר נשאלת שאילתה, מערכת השליפה מביאה מסמכים או נתונים רלוונטיים ממקור חיצוני, והמידע שנשלף משמש להעשיר את הקלט למודל היצירתי. זה עוזר למודל לייצר תגובות מדויקות ורלוונטיות יותר להקשר.

במערכת RAG, הסוכן מושך מידע רלוונטי מבסיס ידע ומשתמש בו כדי ליצור תגובות או פעולות מתאימות.

### גישת RAG מתקנת

גישת RAG מתקנת מתמקדת בשימוש בטכניקות RAG לתיקון שגיאות ולשיפור הדיוק של סוכני בינה. זה כולל:

1. **טכניקת פירמוט (Prompting)**: שימוש בפירמוטים ספציפיים כדי לכוון את הסוכן בשליפת מידע רלוונטי.
2. **כלי**: יישום אלגוריתמים ומנגנונים המאפשרים לסוכן להעריך את הרלוונטיות של המידע שנשלף ולייצר תגובות מדויקות.
3. **הערכה**: הערכת ביצועי הסוכן באופן רציף וביצוע התאמות לשיפור הדיוק והיעילות שלו.

#### דוגמה: RAG מתקנת בסוכן חיפוש

שקלו סוכן חיפוש שמושך מידע מהרשת כדי לענות על שאילתות משתמשים. גישת RAG מתקנת עשויה לכלול:

1. **טכניקת פירמוט**: ניסוח שאילתות חיפוש בהתבסס על קלט המשתמש.
2. **כלי**: שימוש בעיבוד שפה טבעית ואלגוריתמי למידה מכונה כדי לדרג ולסנן תוצאות חיפוש.
3. **הערכה**: ניתוח משוב משתמשים כדי לזהות ולתקן אי־דיוקים במידע שנשלף.

### RAG מתקנת בסוכן נסיעות

RAG מתקנת (Retrieval-Augmented Generation) משפרת את יכולת הבינה לשלוף ולייצר מידע תוך תיקון אי־דיוקים. בואו נראה כיצד סוכן הנסיעות יכול להשתמש בגישת RAG מתקנת כדי לספק המלצות נסיעה מדויקות ורלוונטיות יותר.

זה כולל:

- **טכניקת פירמוט:** שימוש בפירמוטים ספציפיים כדי לכוון את הסוכן בשליפת מידע רלוונטי.
- **כלי:** יישום אלגוריתמים ומנגנונים שמאפשרים לסוכן להעריך את הרלוונטיות של המידע שנשלף וליצור תגובות מדויקות.
- **הערכה:** הערכת ביצועי הסוכן באופן רציף וביצוע התאמות לשיפור הדיוק והיעילות שלו.

#### שלבים ליישום RAG מתקנת בסוכן הנסיעות

1. **אינטראקציה ראשונית עם המשתמש**
   - סוכן הנסיעות אוסף העדפות ראשוניות מהמשתמש, כגון יעד, תאריכי נסיעה, תקציב ותחומי עניין.
   - דוגמה:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **שליפת מידע**
   - סוכן הנסיעות מושך מידע על טיסות, לינות, אטרקציות ומסעדות בהתבסס על העדפות המשתמש.
   - דוגמה:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **יצירת המלצות ראשוניות**
   - סוכן הנסיעות משתמש במידע שנשלף כדי ליצור מסלול מותאם אישית.
   - דוגמה:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **איסוף משוב המשתמש**
   - סוכן הנסיעות שואל את המשתמש עבור משוב על ההמלצות הראשוניות.
   - דוגמה:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **תהליך RAG מתקנת**
   - **טכניקת פירמוט**: סוכן הנסיעות מנוסח שאילתות חיפוש חדשות בהתבסס על משוב המשתמש.
     - דוגמה:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **כלי**: סוכן הנסיעות משתמש באלגוריתמים לדרג ולסנן תוצאות חיפוש חדשות, תוך הדגשת הרלוונטיות בהתבסס על משוב המשתמש.
     - דוגמה:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **הערכה**: סוכן הנסיעות מעריך באופן רציף את הרלוונטיות והדיוק של ההמלצות שלו על ידי ניתוח משוב המשתמש וביצוע התאמות נחוצות.
     - דוגמה:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### דוגמה מעשית

הנה דוגמת קוד פייתון מפושטת המשלבת את גישת RAG המתקנת בסוכן הנסיעות:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# דוגמה לשימוש
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### טעינת הקשר מקדמית (Pre-emptive Context Load)
טעינת הקשר מוקדמת כוללת טעינת מידע רלוונטי או רקע לתוך המודל לפני עיבוד שאילתה. משמעות הדבר היא שהמודל מקבל גישה למידע זה מההתחלה, מה שיכול לעזור לו להפיק תגובות מושכלות יותר בלי צורך לשלוף נתונים נוספים במהלך התהליך.

להלן דוגמה מפושטת לאופן בו טעינת הקשר מוקדמת עשויה להיראות עבור יישום סוכן נסיעות ב-Python:

```python
class TravelAgent:
    def __init__(self):
        # טען מראש יעדים פופולריים ואת המידע עליהם
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # שלוף מידע על היעד מההקשר שהוטען מראש
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# דוגמה לשימוש
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### הסבר

1. **Initialization (`__init__` method)**: מחלקת `TravelAgent` טוענת מראש מילון המכיל מידע על יעדים פופולריים כגון פריז, טוקיו, ניו יורק וסידני. מילון זה כולל פרטים כמו המדינה, המטבע, השפה והאטרקציות העיקריות לכל יעד.

2. **Retrieving Information (`get_destination_info` method)**: כאשר משתמש שואל על יעד ספציפי, המתודה `get_destination_info` משליפה את המידע הרלוונטי ממילון הקונטקסט הטעון מראש.

על ידי טעינת הקונטקסט מראש, יישום סוכן הנסיעות יכול להגיב במהירות לשאילתות משתמשים מבלי שיהיה צורך לשלוף מידע זה ממקור חיצוני בזמן אמת. הדבר הופך את היישום ליעיל ומהיר יותר.

### איתחול התוכנית עם מטרה לפני איטרציה

איתחול תכנית עם מטרה כולל התחלה עם מטרה ברורה או תוצאה רצויה. על-ידי הגדרת המטרה מראש, המודל יכול להשתמש בה כעיקרון מנחה לאורך תהליך האיטרציה. הדבר עוזר לוודא שכל איטרציה מקרבת את התוצאה הרצויה, מה שהופך את התהליך ליותר יעיל וממוקד.

להלן דוגמה לאופן שבו ניתן לאתחל תכנית נסיעות עם מטרה לפני איטרציה עבור סוכן נסיעות ב-Python:

### תרחיש

סוכן נסיעות רוצה לתכנן חופשה מותאמת אישית ללקוח. המטרה היא ליצור מסלול נסיעות שממקסם את שביעות רצונו של הלקוח בהתבסס על העדפותיו והתקציב.

### שלבים

1. הגדר את העדפות הלקוח ואת התקציב.
2. אתחל את התוכנית ההתחלתית בהתבסס על העדפות אלו.
3. בצע איטרציות לשיפור התוכנית, מתוך אופטימיזציה לשביעות רצון הלקוח.

#### קוד Python

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# דוגמה לשימוש
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### הסבר הקוד

1. **Initialization (`__init__` method)**: מחלקת `TravelAgent` מאותחלת עם רשימה של יעדים אפשריים, שכל אחד מהם בעל מאפיינים כמו שם, עלות וסוג פעילות.

2. **Bootstrapping the Plan (`bootstrap_plan` method)**: מתודה זו יוצרת תכנית נסיעות ראשונית בהתבסס על העדפות ותקציב הלקוח. היא מריצה איטרציה על רשימת היעדים ומוסיפה אותם לתוכנית אם הם תואמים להעדפות הלקוח ומתאימים לתקציב.

3. **Matching Preferences (`match_preferences` method)**: מתודה זו בודקת האם יעד תואם את העדפות הלקוח.

4. **Iterating the Plan (`iterate_plan` method)**: מתודה זו מחדשת את התכנית הראשונית על ידי ניסיון להחליף כל יעד בתוכנית בהתאמה טובה יותר, תוך התחשבות בעדפות הלקוח ובמגבלות התקציב.

5. **Calculating Cost (`calculate_cost` method)**: מתודה זו מחשבת את העלות הכוללת של התוכנית הנוכחית, כולל יעד חדש אפשרי.

#### דוגמה לשימוש

- **תוכנית ראשונית**: סוכן הנסיעות יוצר תוכנית ראשונית על בסיס העדפות הלקוח לביקור באתרים ותקציב של $2000.
- **תוכנית משופרת**: סוכן הנסיעות מבצע איטרציות על התוכנית, וממקסם את ההתאמה להעדפות הלקוח ותקציבו.

על-ידי איתחול התוכנית עם מטרה ברורה (למשל: מיקסום שביעות רצון הלקוח) וביצוע איטרציות לשיפור התוכנית, סוכן הנסיעות יכול ליצור מסלול נסיעות מותאם וממוטב ללקוח. גישה זו מבטיחה שהתוכנית תתאים להעדפות ולתקציב הלקוח מההתחלה ותשתפר בכל איטרציה.

### ניצול מודלים לשוניים גדולים (LLMs) למיון מחדש ולמתן ציונים

מודלים לשוניים גדולים (LLMs) יכולים לשמש למיון מחדש ולמתן ציונים על ידי הערכת הרלוונטיות והאיכות של מסמכים שנשלפו או תגובות שנוצרו. כך זה עובד:

**שליפה:** שלב השליפה הראשוני מביא סט של מסמכים מועמדים או תגובות בהתבסס על השאילתה.

**מיון מחדש:** ה-LLM מעריך את המועמדים האלה וממיין אותם מחדש על בסיס הרלוונטיות והאיכות שלהם. שלב זה מבטיח שמידע הרלוונטי והאיכותי ביותר יוצג ראשון.

**מתן ציונים:** ה-LLM מקצה ציונים לכל מועמד, המשקפים את הרלוונטיות והאיכות שלהם. זה עוזר בבחירת התשובה או המסמך הטוב ביותר עבור המשתמש.

על-ידי ניצול LLMs למיון מחדש ולמתן ציונים, המערכת יכולה לספק מידע מדויק יותר ורלוונטי באופן הקשרי, מה שמשפר את חוויית המשתמש הכוללת.

להלן דוגמה לאופן שבו סוכן נסיעות עשוי להשתמש במודל לשוני גדול (LLM) למיון מחדש ולמתן ציונים ליעדי נסיעות בהתבסס על העדפות משתמש ב-Python:

#### תרחיש - נסיעות בהתבסס על העדפות

סוכן נסיעות רוצה להמליץ ללקוח על היעדים הטובים ביותר בהתבסס על העדפותיו. ה-LLM יעזור למיין מחדש ולתת ציונים ליעדים כדי להבטיח שהאפשרויות הרלוונטיות ביותר יוצגו.

#### שלבים:

1. איסוף העדפות המשתמש.
2. שלוף רשימת יעדי נסיעות אפשריים.
3. השתמש ב-LLM למיון מחדש ולמתן ציונים ליעדים בהתבסס על העדפות המשתמש.

הנה כיצד ניתן לעדכן את הדוגמה הקודמת לשימוש ב-Azure OpenAI Services:

#### דרישות

1. עליך שיהיה לך מנוי ל-Azure.
2. צור משאב Azure OpenAI וקבל את מפתח ה-API שלך.

#### דוגמת קוד Python

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # צור פרומפט עבור Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # הגדר את הכותרות ואת גוף הבקשה
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # קרא ל-API של Azure OpenAI כדי לקבל את היעדים הממוינים מחדש ומדורגים
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # חלץ והחזר את ההמלצות
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# דוגמה לשימוש
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### הסבר הקוד - בורר העדפות

1. **Initialization**: מחלקת `TravelAgent` מאותחלת עם רשימה של יעדי נסיעות אפשריים, שלכל אחד מהם מאפיינים כמו שם ותיאור.

2. **Getting Recommendations (`get_recommendations` method)**: מתודה זו יוצרת פרומפט עבור שירות Azure OpenAI בהתבסס על העדפות המשתמש ומבצעת בקשת HTTP POST ל-API של Azure OpenAI כדי לקבל יעדים ממונים מחדש ומדורגים.

3. **Generating Prompt (`generate_prompt` method)**: מתודה זו בונה פרומפט ל-Azure OpenAI, הכולל את העדפות המשתמש ואת רשימת היעדים. הפרומפט מכוון את המודל למיין מחדש ולתת ציונים ליעדים בהתבסס על ההעדפות שניתנו.

4. **API Call**: ספריית `requests` משמשת לביצוע בקשת HTTP POST לנקודת הקצה של ה-API של Azure OpenAI. התשובה מכילה את היעדים הממוינים מחדש ואת הציונים שלהם.

5. **Example Usage**: סוכן הנסיעות אוסף את העדפות המשתמש (למשל, עניין בביקור באתרים ותרבות מגוונת) ומשתמש בשירות Azure OpenAI כדי לקבל המלצות ליעדי נסיעות שממוינים מחדש ומדורגים.

וודא להחליף `your_azure_openai_api_key` במפתח ה-API האמיתי של Azure OpenAI ואת `https://your-endpoint.com/...` בכתובת ה-URL של נקודת הקצה של הפריסה שלך של Azure OpenAI.

על-ידי ניצול ה-LLM למיון מחדש ולמתן ציונים, סוכן הנסיעות יכול לספק המלצות נסיעה אישיות ורלוונטיות יותר ללקוחות, ובכך לשפר את חווייתם הכוללת.

### RAG: טכניקת יצירת פרומפטים מול כלי

Retrieval-Augmented Generation (RAG) יכולה להיות הן טכניקת יצירת פרומפטים והן כלי בפיתוח סוכני בינה מלאכותית. הבנת ההבחנה בין השניים יכולה לעזור לך לנצל את RAG באופן יעיל יותר בפרויקטים שלך.

#### RAG כתכניקת יצירת פרומפטים

**מה זה?**

- כטכניקת יצירת פרומפטים, RAG כוללת ניסוח שאילתות או פרומפטים ספציפיים להנחיית שליפת מידע רלוונטי ממאגר גדול או מסד נתונים. מידע זה משמש אז ליצירת תגובות או פעולות.

**איך זה עובד:**

1. **ניסוח פרומפטים**: צור פרומפטים או שאילתות מסודרים היטב בהתבסס על המשימה או על קלט המשתמש.
2. **שלוף מידע**: השתמש בפרומפטים כדי לחפש נתונים רלוונטיים ממאגר ידע קיים או מערך נתונים.
3. **ייצור תגובה**: שלב את המידע שנשלף עם מודלים גנרטיביים כדי להפיק תגובה מקיפה וקוהרנטית.

**דוגמה בסוכן נסיעות**:

- קלט משתמש: "אני רוצה לבקר במוזיאונים בפריז."
- פרומפט: "מצא את המוזיאונים המובילים בפריז."
- מידע שנשלף: פרטים על מוזיאון הלובר, Musée d'Orsay, וכו'.
- תגובה שנוצרה: "להלן כמה מהמוזיאונים המובילים בפריז: מוזיאון הלובר, Musée d'Orsay, ו-Centre Pompidou."

#### RAG ככלי

**מה זה?**

- ככלי, RAG הוא מערכת משולבת שמאוטומטת את תהליך השליפה והייצור, מה שמקל על מפתחים להטמיע פונקציות AI מורכבות ללא הצורך לנסח פרומפטים ידנית עבור כל שאילתה.

**איך זה עובד:**

1. **אינטגרציה**: הטמע את RAG בתוך ארכיטקטורת סוכן ה-AI, מה שמאפשר לו לטפל באוטומטיות במשימות השליפה והייצור.
2. **אוטומציה**: הכלי מנהל את כל התהליך, מקבלת קלט המשתמש ועד לייצור התגובה הסופית, ללא צורך בפרומפטים מפורשים לכל שלב.
3. **יעילות**: משפר את ביצועי הסוכן על ידי ייעול תהליך השליפה והייצור, ומאפשר תגובות מהירות ומדויקות יותר.

**דוגמה בסוכן נסיעות**:

- קלט משתמש: "אני רוצה לבקר במוזיאונים בפריז."
- כלי RAG: מחלץ אוטומטית מידע על מוזיאונים ומייצר תגובה.
- תגובה שנוצרה: "להלן כמה מהמוזיאונים המובילים בפריז: מוזיאון הלובר, Musée d'Orsay, ו-Centre Pompidou."

### השוואה

| Aspect                 | Prompting Technique                                        | Tool                                                  |
|------------------------|-------------------------------------------------------------|-------------------------------------------------------|
| **Manual vs Automatic**| ניסוח ידני של פרומפטים עבור כל שאילתה.               | תהליך אוטומטי לשליפה ולייצור.       |
| **Control**            | מספק שליטה רבה יותר על תהליך השליפה.             | מייעל ומאוטומט את תהליך השליפה והייצור.|
| **Flexibility**        | מאפשר פרומפטים מותאמים לפי צרכים ספציפיים.      | יעיל יותר ליישומים בקנה-מידה גדול.       |
| **Complexity**         | דורש ניסוח וכיוונון של פרומפטים.                  | קל יותר לשלב בארכיטקטורת סוכן AI. |

### דוגמאות מעשיות

**דוגמת טכניקת יצירת פרומפטים:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**דוגמת כלי:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### הערכת רלוונטיות

הערכת רלוונטיות היא היבט קריטי בביצועי סוכן ה-AI. היא מוודאת שהמידע שנשלף ונוצר על ידי הסוכן הוא מתאים, מדויק ושימושי עבור המשתמש. בואו נבחן כיצד להעריך רלוונטיות בסוכני AI, כולל דוגמאות וטכניקות מעשיות.

#### מושגי מפתח בהערכת רלוונטיות

1. **מודעות להקשר**:
   - הסוכן חייב להבין את ההקשר של שאילתת המשתמש כדי לשלוף ולייצר מידע רלוונטי.
   - דוגמה: אם משתמש שואל 'המסעדות הטובות ביותר בפריז', הסוכן צריך לקחת בחשבון את העדפות המשתמש, כגון סוג המטבח והתקציב.

2. **דיוק**:
   - המידע שמספק הסוכן צריך להיות נכון עובדתית ועדכני.
   - דוגמה: להמליץ על מסעדות הפתוחות כרגע עם ביקורות טובות במקום אופציות מיושנות או שנסגרו.

3. **כוונת המשתמש**:
   - הסוכן צריך להסיק את כוונת המשתמש שמאחורי השאילתה כדי לספק את המידע הרלוונטי ביותר.
   - דוגמה: אם משתמש מבקש 'מלונות ידידותיים לתקציב', הסוכן צריך לתת עדיפות לאופציות חסכוניות.

4. **לולאת משוב**:
   - איסוף וניתוח מתמיד של משוב משתמשים עוזר לסוכן לחדד את תהליך הערכת הרלוונטיות.
   - דוגמה: שילוב דירוגים ומשוב של משתמשים על המלצות קודמות כדי לשפר תגובות עתידיות.

#### טכניקות מעשיות להערכת רלוונטיות

1. **מתן ציון רלוונטיות**:
   - הקצה ציון רלוונטיות לכל פריט שנשלף על בסיס מידת ההתאמה שלו לשאילתה ולהעדפות המשתמש.
   - דוגמה:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **סינון ודירוג**:
   - סנן פריטים לא רלוונטיים ודירג את השאר על סמך ציוני הרלוונטיות שלהם.
   - דוגמה:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # החזר את 10 הפריטים הרלוונטיים ביותר
     ```

3. **עיבוד שפה טבעית (NLP)**:
   - השתמש בטכניקות NLP כדי להבין את שאילתת המשתמש ולשלוף מידע רלוונטי.
   - דוגמה:

     ```python
     def process_query(query):
         # השתמש בעיבוד שפה טבעית כדי לחלץ מידע מפתח משאילתת המשתמש
         processed_query = nlp(query)
         return processed_query
     ```

4. **שילוב משוב משתמשים**:
   - אסוף משוב משתמשים על ההמלצות שסופקו והשתמש בו להתאמת הערכות הרלוונטיות בעתיד.
   - דוגמה:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### דוגמה: הערכת רלוונטיות בסוכן נסיעות

להלן דוגמה מעשית לאופן שבו `TravelAgent` יכול להעריך את הרלוונטיות של המלצות נסיעה:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # החזר את 10 הפריטים הרלוונטיים ביותר

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# דוגמה לשימוש
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### חיפוש עם כוונה

חיפוש עם כוונה כולל הבנה ופרשנות של המטרה או היעד שבבסיס שאילתת המשתמש, כדי לשלוף ולייצר את המידע הרלוונטי והיעיל ביותר. גישה זו חורגת ממאמץ התאמת מילות מפתח ומתמקדת בהבנת הצרכים וההקשר האמיתי של המשתמש.

#### מושגי מפתח בחיפוש עם כוונה

1. **הבנת כוונת המשתמש**:
   - כוונת המשתמש יכולה להיות ממוסגרת לשלושה סוגים עיקריים: אינפורמטיבי, ניווטי וטרנזקציוני.
     - **כוונה אינפורמטיבית**: המשתמש מבקש מידע על נושא (למשל, 'מהם המוזיאונים הטובים ביותר בפריז?').
     - **כוונה ניווטית**: המשתמש רוצה לנווט לאתר או לדף מסוים (למשל, 'האתר הרשמי של מוזיאון הלובר').
     - **כוונה טרנזקציונית**: המשתמש מתכוון לבצע עסקה, כגון הזמנת טיסה או ביצוע רכישה (למשל, 'הזמן טיסה לפריז').

2. **מודעות להקשר**:
   - ניתוח ההקשר של שאילתת המשתמש עוזר לזהות באופן מדויק את כוונתו. זה כולל התחשבות באינטראקציות קודמות, העדפות המשתמש והפרטים הספציפיים של השאילתה הנוכחית.

3. **עיבוד שפה טבעית (NLP)**:
   - טכניקות NLP משומשות כדי להבין ולפרש את שאילתות השפה הטבעית של המשתמשים. זה כולל משימות כמו זיהוי ישויות, ניתוח סנטימנט ופרסינג של שאילתות.

4. **התאמה אישית**:
   - התאמת תוצאות החיפוש בהתבסס על היסטוריית המשתמש, העדפותיו ומשובו משפרת את הרלוונטיות של המידע שנשלף.

#### דוגמה מעשית: חיפוש עם כוונה בסוכן נסיעות

ניקח את `TravelAgent` כדוגמה כדי לראות כיצד חיפוש עם כוונה ניתן ליישם.

1. **איסוף העדפות המשתמש**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **הבנת כוונת המשתמש**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **מודעות להקשר**
   ```python
   def analyze_context(query, user_history):
       # שלב את השאילתה הנוכחית עם היסטוריית המשתמש כדי להבין את ההקשר
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **חיפוש והתאמה אישית של תוצאות**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # לוגיקת חיפוש לדוגמה לכוונת מידע
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # לוגיקת חיפוש לדוגמה לכוונת ניווט
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # לוגיקת חיפוש לדוגמה לכוונת ביצוע עסקה
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # לוגיקת התאמה אישית לדוגמה
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # החזר את 10 התוצאות המותאמות אישית המובילות
   ```

5. **דוגמה לשימוש**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. יצירת קוד ככלי

סוכני יצירת קוד משתמשים במודלים של בינה מלאכותית כדי לכתוב ולהריץ קוד, לפתור בעיות מורכבות ולבצע אוטומציה של משימות.

### סוכני יצירת קוד

סוכני יצירת קוד משתמשים במודלי בינה מלאכותית גנרטיביים כדי לכתוב ולהריץ קוד. סוכנים אלה יכולים לפתור בעיות מורכבות, לבצע אוטומציה של משימות ולספק תובנות חשובות על ידי יצירה והרצה של קוד בשפות תכנות שונות.

#### יישומים מעשיים

1. **יצירת קוד אוטומטית**: יצירת קטעי קוד אוטומטית עבור משימות ספציפיות, כגון ניתוח נתונים, גרידת אתרים או למידת מכונה.
2. **SQL כ-RAG**: השתמש בשאילתות SQL כדי לאחזר ולשנות נתונים ממסדי נתונים.
3. **פתרון בעיות**: צור והרץ קוד כדי לפתור בעיות ספציפיות, כגון אופטימיזציה של אלגוריתמים או ניתוח נתונים.

#### דוגמה: סוכן יצירת קוד לניתוח נתונים

דמיינו שאתם מעצבים סוכן ליצירת קוד. כך זה עשוי לעבוד:

1. **משימה**: לנתח מערך נתונים כדי לזהות מגמות ותבניות.
2. **צעדים**:
   - טען את מערך הנתונים לכלי ניתוח נתונים.
   - הפק שאילתות SQL כדי לסנן ולאגד את הנתונים.
   - הרץ את השאילתות ואחזר את התוצאות.
   - השתמש בתוצאות כדי ליצור ויזואליזציות ותובנות.
3. **משאבים נדרשים**: גישה למערך הנתונים, לכלי ניתוח נתונים וליכולות SQL.
4. **ניסיון**: השתמש בתוצאות ניתוח קודמות כדי לשפר את הדיוק והרלוונטיות של ניתוחים עתידיים.

### דוגמה: סוכן יצירת קוד עבור סוכן נסיעות

בדוגמה זו נעצב סוכן יצירת קוד, Travel Agent, שיעזור למשתמשים לתכנן את נסיעותיהם על ידי יצירה והרצת קוד. סוכן זה יכול לטפל במשימות כגון שליפת אפשרויות נסיעה, סינון תוצאות והרכבת מסלול טיול באמצעות בינה מלאכותית גנרטיבית.

#### סקירה כללית של סוכן יצירת הקוד

1. **איסוף העדפות משתמש**: אוסף קלט מהמשתמש כגון יעד, תאריכי נסיעה, תקציב ותחומי עניין.
2. **יצירת קוד לשליפת נתונים**: מייצר קטעי קוד לאחזור נתונים על טיסות, מלונות ואטרקציות.
3. **הפעלת הקוד שנוצר**: מריץ את הקוד שנוצר כדי לאחזר מידע בזמן אמת.
4. **יצירת מסלול נסיעה**: מרכיב את הנתונים שנשלפו לתוכנית נסיעה מותאמת אישית.
5. **התאמה על סמך משוב**: מקבל משוב מהמשתמש ומייצר מחדש קוד במידת הצורך כדי לחדד את התוצאות.

#### יישום שלב אחר שלב

1. **איסוף העדפות משתמש**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **יצירת קוד לשליפת נתונים**

   ```python
   def generate_code_to_fetch_data(preferences):
       # דוגמה: ליצור קוד לחיפוש טיסות בהתאם להעדפות המשתמש
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # דוגמה: ליצור קוד לחיפוש מלונות
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **הפעלת הקוד שנוצר**

   ```python
   def execute_code(code):
       # הרץ את הקוד שנוצר באמצעות exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **יצירת מסלול נסיעה**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **התאמה על סמך משוב**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # התאם העדפות בהתאם למשוב המשתמש
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # צור מחדש והרץ קוד עם העדפות מעודכנות
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### ניצול מודעות לסביבה והסקת מסקנות

הבנת סכמת הטבלה אכן יכולה לשפר את תהליך יצירת השאילתות על ידי ניצול מודעות סביבתית ויכולת הסקה.

הנה דוגמה לאופן שבו זה יכול להיעשות:

1. **הבנת הסכמה**: המערכת תבין את סכמת הטבלה ותשתמש במידע זה כדי לעגן את יצירת השאילתות.
2. **התאמה על סמך משוב**: המערכת תתאים את העדפות המשתמש על סמך משוב ותבצע הסקה לגבי אילו שדות בסכמה צריכים להתעדכן.
3. **יצירה והפעלת שאילתות**: המערכת תייצר ותפעיל שאילתות כדי לאחזר נתונים מעודכנים על טיסות ומלונות בהתבסס על ההעדפות החדשות.

להלן דוגמת קוד Python מעודכנת המשלבת רעיונות אלה:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # התאם העדפות בהתאם למשוב המשתמש
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # הסקת מסקנות על בסיס הסכימה כדי להתאים העדפות קשורות אחרות
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # לוגיקה מותאמת אישית להתאמת העדפות על בסיס הסכימה והמשוב
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # הפק קוד לשליפת נתוני טיסות על בסיס ההעדפות המעודכנות
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # הפק קוד לשליפת נתוני בתי מלון על בסיס ההעדפות המעודכנות
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # דמה ביצוע הקוד והחזר נתונים מדומים
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # צור מסלול על בסיס טיסות, בתי מלון ואטרקציות
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# דוגמת סכימה
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# דוגמת שימוש
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# צור מחדש והרץ קוד עם ההעדפות המעודכנות
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### הסבר - הזמנות בהתבסס על משוב

1. **מודעות לסכמה**: מילון ה-`schema` מגדיר כיצד יש להתאים העדפות על סמך משוב. הוא כולל שדות כמו `favorites` ו-`avoid`, עם התאמות מתאימות.
2. **התאמת העדפות (`adjust_based_on_feedback` method)**: שיטה זו מתאימה את ההעדפות על סמך משוב מהמשתמש והסכמה.
3. **התאמות מבוססות-סביבה (`adjust_based_on_environment` method)**: שיטה זו מיישמת התאמות מותאמות בהתבסס על הסכמה והמשוב.
4. **יצירה והפעלת שאילתות**: המערכת מייצרת קוד לאחזור נתונים מעודכנים על טיסות ומלונות בהתבסס על ההעדפות המותאמות ומדמה את הרצת השאילתות הללו.
5. **יצירת מסלול**: המערכת יוצרת מסלול מעודכן בהתבסס על נתוני טיסות, מלונות ואטרקציות חדשים.

על ידי הפיכת המערכת למודעת-סביבה והסקת מסקנות בהתבסס על הסכמה, היא יכולה לייצר שאילתות מדויקות ורלוונטיות יותר, מה שמוביל להמלצות נסיעה טובות יותר ולחוויית משתמש מותאמת אישית יותר.

### שימוש ב-SQL כטכניקת Retrieval-Augmented Generation (RAG)

SQL (Structured Query Language) הוא כלי חזק לאינטראקציה עם מסדי נתונים. כאשר משתמשים בו כחלק מגישת Retrieval-Augmented Generation (RAG), SQL יכול לאחזר נתונים רלוונטיים ממסדי נתונים כדי להעשיר וליצור תגובות או פעולות בסוכני בינה מלאכותית. בואו נחקור כיצד ניתן להשתמש ב-SQL כטכניקת RAG בהקשר של Travel Agent.

#### מושגי מפתח

1. **אינטראקציה עם מסד נתונים**:
   - משתמשים ב-SQL כדי לבצע שאילתות למסדי נתונים, לאחזר מידע רלוונטי ולשנות נתונים.
   - דוגמה: שליפת פרטי טיסות, מידע על מלונות ואטרקציות ממסד נתונים תיירותי.

2. **שילוב עם RAG**:
   - שאילתות SQL נוצרות בהתבסס על קלט והעדפות המשתמש.
   - הנתונים שנשלפו משמשים אז ליצירת המלצות מותאמות אישית או לביצוע פעולות.

3. **יצירת שאילתות דינמית**:
   - הסוכן מבוסס ה-AI מייצר שאילתות SQL דינמיות בהתבסס על ההקשר וצורכי המשתמש.
   - דוגמה: התאמת שאילתות SQL כדי לסנן תוצאות על פי תקציב, תאריכים ותחומי עניין.

#### יישומים

- **יצירת קוד אוטומטית**: יצירת קטעי קוד למשימות ספציפיות.
- **SQL כ-RAG**: השתמש בשאילתות SQL כדי לעבד נתונים.
- **פתרון בעיות**: צור והרץ קוד לפתירת בעיות.

**דוגמה**:
סוכן לניתוח נתונים:

1. **משימה**: לנתח מערך נתונים כדי למצוא מגמות.
2. **שלבים**:
   - טען את מערך הנתונים.
   - הפק שאילתות SQL כדי לסנן נתונים.
   - הרץ שאילתות ואחזר תוצאות.
   - צרו ויזואליזציות ותובנות.
3. **משאבים**: גישה למערך נתונים, יכולות SQL.
4. **ניסיון**: השתמש בתוצאות קודמות כדי לשפר ניתוחים עתידיים.

#### דוגמה מעשית: שימוש ב-SQL ב-Travel Agent

1. **איסוף העדפות משתמש**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **יצירת שאילתות SQL**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **הפעלת שאילתות SQL**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **יצירת המלצות**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### דוגמת שאילתות SQL

1. **שאילתת טיסות**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **שאילתת מלון**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **שאילתת אטרקציות**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

על ידי שימוש ב-SQL כחלק מטכניקת Retrieval-Augmented Generation (RAG), סוכני AI כמו Travel Agent יכולים לאחזר ולנצל באופן דינמי נתונים רלוונטיים כדי לספק המלצות מדויקות ומותאמות אישית.

### דוגמה למטה-קוגניציה

על מנת להדגים מימוש של מטה-קוגניציה, ניצור סוכן פשוט שמרהה על תהליך קבלת ההחלטות שלו בזמן פתרון בעיה. בדוגמה זו נבנה מערכת שבה סוכן מנסה למטב את בחירת המלון, אך לאחר מכן מעריך את ההסקות שלו ומתאים את האסטרטגיה שלו כאשר הוא עושה שגיאות או בחירות לא אופטימליות.

נמחיש זאת באמצעות דוגמה בסיסית שבה הסוכן בוחר מלונות לפי שילוב של מחיר ואיכות, אך הוא ירהר בהחלטותיו ויתאים את עצמו בהתאם.

#### כיצד זה ממחיש מטה-קוגניציה:

1. **החלטה ראשונית**: הסוכן יבחר במלון הזול ביותר, מבלי להבין את השפעת האיכות.
2. **הרהור והערכה**: לאחר הבחירה הראשונית, הסוכן יבדוק האם המלון היה בחירה "רע" באמצעות משוב מהמשתמש. אם ימצא שאיכות המלון הייתה נמוכה מדי, הוא ישקף את שיקוליו.
3. **התאמת אסטרטגיה**: הסוכן מתאים את האסטרטגיה שלו בהתבסס על ההרהור, ועובר מ"מהזול ביותר" ל"בהתבסס על האיכות הגבוהה ביותר", ובכך משפר את תהליך קבלת ההחלטות בבחירות עתידיות.

הנה דוגמה:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # מאחסן את המלונות שנבחרו קודם
        self.corrected_choices = []  # מאחסן את הבחירות המתוקנות
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # אסטרטגיות זמינות

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # נניח שיש לנו משוב מהמשתמש שמספר אם הבחירה האחרונה הייתה טובה או לא
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # התאמת אסטרטגיה אם הבחירה הקודמת הייתה לא מספקת
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# סימולציה של רשימת מלונות (מחיר ואיכות)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# יצירת סוכן
agent = HotelRecommendationAgent()

# שלב 1: הסוכן ממליץ על מלון באמצעות האסטרטגיה "הזול ביותר"
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# שלב 2: הסוכן משקף את הבחירה ומתאים את האסטרטגיה אם יש צורך
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# שלב 3: הסוכן ממליץ שוב, הפעם משתמש באסטרטגיה שהותאמה
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### יכולות מטה-קוגניציה של הסוכן

המפתח כאן הוא יכולתו של הסוכן ל:
- להעריך את בחירותיו הקודמות ותהליך קבלת ההחלטות שלו.
- להתאים את האסטרטגיה שלו בהתבסס על ההרהור — כלומר, מטה-קוגניציה בפעולה.

זוהי צורה פשוטה של מטה-קוגניציה שבה המערכת מסוגלת להתאים את תהליך ההסקה שלה על סמך משוב פנימי.

### מסקנה

מטה-קוגניציה היא כלי רב-עוצמה שיכול לשפר משמעותית את יכולות סוכני הבינה המלאכותית. על ידי שילוב תהליכים מטה-קוגניטיביים, תוכלו לעצב סוכנים חכמים, אדפטיביים ויעילים יותר. השתמשו במשאבים הנוספים כדי לחקור עוד את העולם המרתק של מטה-קוגניציה בסוכני בינה מלאכותית.

### יש לכם שאלות נוספות לגבי תבנית העיצוב של מטה-קוגניציה?

הצטרפו ל-[Microsoft Foundry Discord](https://aka.ms/ai-agents/discord) כדי להיפגש עם לומדים אחרים, להשתתף בשעות פתוחות ולקבל תשובות לשאלות על סוכני AI.

## שיעור קודם

[תבנית עיצוב רב-סוכנית](../08-multi-agent/README.md)

## השיעור הבא

[סוכני בינה מלאכותית בסביבת ייצור](../10-ai-agents-production/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
הצהרת אחריות:
מסמך זה תורגם באמצעות שירות תרגום מבוסס בינה מלאכותית [Co-op Translator](https://github.com/Azure/co-op-translator). אף שאנו שואפים לדיוק, יש לשים לב כי תרגומים אוטומטיים עלולים להכיל שגיאות או אי-דיוקים. יש להתייחס למסמך המקורי בשפתו כמקור הסמכות. למידע קריטי מומלץ תרגום מקצועי על ידי מתרגם אנושי. איננו אחראים לכל אי-הבנה או פרשנות שגויה הנובעים מהשימוש בתרגום זה.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->