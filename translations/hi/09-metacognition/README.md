[![मल्टी-एजेंट डिज़ाइन](../../../translated_images/hi/lesson-9-thumbnail.38059e8af1a5b71d.webp)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(इस पाठ का वीडियो देखने हेतु ऊपर की छवि पर क्लिक करें)_
# AI एजेंट्स में मेटाकॉग्निशन

## परिचय

AI एजेंट्स में मेटाकॉग्निशन पर पाठ में आपका स्वागत है! यह अध्याय शुरुआती लोगों के लिए डिज़ाइन किया गया है जो यह जानना चाहते हैं कि AI एजेंट्स अपने सोचने की प्रक्रियाओं के बारे में कैसे सोच सकते हैं। इस पाठ के अंत तक, आप मुख्य अवधारणाओं को समझ जाएंगे और AI एजेंट डिजाइन में मेटाकॉग्निशन को लागू करने के लिए व्यावहारिक उदाहरणों से लैस होंगे।

## सीखने के लक्ष्य

इस पाठ को पूरा करने के बाद, आप सक्षम होंगे:

1. एजेंट परिभाषाओं में तर्क चक्रों के प्रभावों को समझना।
2. स्व-सुधार करने वाले एजेंट्स में सहायता करने के लिए योजना और मूल्यांकन तकनीकों का उपयोग करना।
3. ऐसे एजेंट बनाना जो कार्यों को पूरा करने के लिए कोड को संशोधित कर सकें।

## मेटाकॉग्निशन का परिचय

मेटाकॉग्निशन उन उच्च स्तरीय संज्ञानात्मक प्रक्रियाओं को संदर्भित करता है जो किसी के अपने सोचने के बारे में सोचने से संबंधित होती हैं। AI एजेंट्स के लिए, इसका मतलब है कि वे अपने कार्यों का स्व-सजगता और पिछले अनुभवों के आधार पर मूल्यांकन और समायोजन कर सकें। मेटाकॉग्निशन, या "सोच के बारे में सोच", एजेंटिक AI सिस्टम के विकास में एक महत्वपूर्ण अवधारणा है। इसमें AI सिस्टम अपने आंतरिक प्रक्रियाओं के प्रति जागरूक होते हैं और अपने व्यवहार की निगरानी, नियमन, और अनुकूलन करने में सक्षम होते हैं। ठीक वैसे ही जैसे हम जब माहौल पढ़ते हैं या किसी समस्या को देखते हैं। यह स्व-जागरूकता AI सिस्टम को बेहतर निर्णय लेने, त्रुटियों की पहचान करने, और समय के साथ अपने प्रदर्शन में सुधार करने में मदद कर सकती है—फिर से ट्यूरिंग टेस्ट और AI के अधिग्रहण को लेकर बहस से जुड़ती है।

एजेंटिक AI सिस्टम के संदर्भ में, मेटाकॉग्निशन कई चुनौतियों को संबोधित करने में मदद कर सकता है, जैसे:
- पारदर्शिता: सुनिश्चित करना कि AI सिस्टम अपने तर्क और निर्णय समझा सकें।
- तर्क: AI सिस्टम की जानकारी को संश्लेषित करने और सही निर्णय लेने की क्षमता बढ़ाना।
- अनुकूलन: AI सिस्टम को नए पर्यावरण और बदलती परिस्थितियों के अनुसार समायोजित करने देना।
- धारणा: AI सिस्टम की पर्यावरण से डेटा को पहचानने और व्याख्या करने की सटीकता बढ़ाना।

### मेटाकॉग्निशन क्या है?

मेटाकॉग्निशन, या "सोच के बारे में सोच," एक उच्च स्तरीय संज्ञानात्मक प्रक्रिया है जिसमें स्वयं की संज्ञानात्मक प्रक्रियाओं की जागरूकता और नियंत्रण शामिल है। AI के क्षेत्र में, मेटाकॉग्निशन एजेंट्स को अपनी रणनीतियों और क्रियाओं का मूल्यांकन और अनुकूलन करने का अधिकार देता है, जिससे समस्या समाधान और निर्णय लेने की क्षमताएं बेहतर होती हैं। मेटाकॉग्निशन को समझकर, आप ऐसे AI एजेंट डिजाइन कर सकते हैं जो न केवल अधिक बुद्धिमान हों बल्कि अधिक अनुकूलनीय और कुशल भी हों। सच्चे मेटाकॉग्निशन में, आप AI को उसके अपने तर्क पर स्पष्ट रूप से सोचते हुए देखेंगे।

उदाहरण: "मैंने सस्ती उड़ानों को प्राथमिकता दी क्योंकि… हो सकता है मैं सीधे उड़ानों से चूक रहा हूँ, इसलिए मैं पुनः जांच करता हूँ।"
किसी निश्चित मार्ग को चुनने के कारण या तरीके को ट्रैक करना।
- यह नोट करना कि उसने गलतियाँ कीं क्योंकि उसने पिछली बार उपयोगकर्ता की प्राथमिकताओं पर अधिक भरोसा किया, इसलिए यह केवल अंतिम सिफारिश नहीं बल्कि निर्णय-निर्माण रणनीति को संशोधित करता है।
- पैटर्न का निदान करना जैसे, "जब भी मैं उपयोगकर्ता को 'बहुत भीड़' कहते देखता हूँ, तो मुझे न केवल कुछ आकर्षण हटाने चाहिए बल्कि यह भी सोचना चाहिए कि मेरा 'शीर्ष आकर्षण' चुनने का तरीका त्रुटिपूर्ण है यदि मैं हमेशा लोकप्रियता के आधार पर रैंक करता हूँ।"

### AI एजेंट्स में मेटाकॉग्निशन का महत्व

मेटाकॉग्निशन AI एजेंट डिज़ाइन में कई कारणों से महत्वपूर्ण भूमिका निभाता है:

![मेटाकॉग्निशन का महत्व](../../../translated_images/hi/importance-of-metacognition.b381afe9aae352f7.webp)

- आत्म-परावर्तन: एजेंट अपनी खुद की कार्यक्षमता का आकलन कर सुधार के क्षेत्र पहचान सकते हैं।
- अनुकूलन क्षमता: एजेंट पिछले अनुभवों और बदलते वातावरण के आधार पर अपनी रणनीतियों को बदला सकते हैं।
- त्रुटि सुधार: एजेंट स्वयं त्रुटियां पहचान कर सुधार कर सकते हैं, जिससे परिणाम अधिक सटीक होते हैं।
- संसाधन प्रबंधन: एजेंट अपनी कार्रवाईयां योजना और मूल्यांकन करके संसाधनों, जैसे समय और कंप्यूटेशनल शक्ति, का अनुकूलन कर सकते हैं।

## AI एजेंट के घटक

मेटाकॉग्निटिव प्रक्रियाओं में जाने से पहले, AI एजेंट के मूल घटकों को समझना आवश्यक है। एक AI एजेंट आमतौर पर निम्नलिखित से बना होता है:

- पर्सोना: एजेंट की व्यक्ति-स्वरूपता और विशेषताएं, जो यह परिभाषित करती हैं कि वह उपयोगकर्ताओं से कैसे संवाद करता है।
- टूल्स: वे क्षमताएँ और कार्य जो एजेंट कर सकता है।
- कौशल: वह ज्ञान और विशेषज्ञता जो एजेंट के पास होती है।

ये घटक एक साथ मिलकर "विशेषज्ञता इकाई" बनाते हैं जो विशिष्ट कार्य कर सकती है।

**उदाहरण**:
एक ट्रैवल एजेंट की कल्पना करें, जो न केवल आपकी छुट्टियों की योजना बनाता है बल्कि असली समय के डेटा और पिछले ग्राहक यात्रा अनुभवों के आधार पर अपने मार्ग को समायोजित भी करता है।

### उदाहरण: ट्रैवल एजेंट सेवा में मेटाकॉग्निशन

कल्पना करें कि आप AI से संचालित एक ट्रैवल एजेंट सेवा डिज़ाइन कर रहे हैं। यह एजेंट, "ट्रैवल एजेंट," उपयोगकर्ताओं की छुट्टियों की योजना बनाने में सहायता करता है। मेटाकॉग्निशन को शामिल करने के लिए, ट्रैवल एजेंट को स्व-जागरूकता और पिछले अनुभवों के आधार पर अपनी कार्रवाइयों का मूल्यांकन और समायोजन करना होगा। मेटाकॉग्निशन की भूमिका कुछ इस प्रकार हो सकती है:

#### वर्तमान कार्य

वर्तमान कार्य एक उपयोगकर्ता की पेरिस यात्रा योजना बनाने में मदद करना है।

#### कार्य पूरा करने के कदम

1. **उपयोगकर्ता की प्राथमिकताएं प्राप्त करना**: उपयोगकर्ता से उनके यात्रा तिथियों, बजट, रुचियों (जैसे संग्रहालय, व्यंजन, शॉपिंग), और किसी विशेष आवश्यकता के बारे में पूछें।
2. **सूचना एकत्र करना**: उपयोगकर्ता की प्राथमिकताओं से मेल खाने वाले उड़ान विकल्प, आवास, आकर्षण, और रेस्टोरेंट्स खोजें।
3. **सिफारिशें बनाना**: उड़ान विवरण, होटल आरक्षण, और सुझाए गए गतिविधियों के साथ एक व्यक्तिगत यात्रा कार्यक्रम प्रदान करें।
4. **प्रतिक्रिया के आधार पर समायोजन करना**: उपयोगकर्ता से सिफारिशों पर प्रतिक्रिया पूछें और आवश्यक समायोजन करें।

#### आवश्यक संसाधन

- उड़ान और होटल बुकिंग डेटाबेस तक पहुँच।
- पेरिस के आकर्षण और रेस्टोरेंट्स की जानकारी।
- पिछली बातचीतों से उपयोगकर्ता प्रतिक्रिया डेटा।

#### अनुभव और आत्म-परावर्तन

ट्रैवल एजेंट मेटाकॉग्निशन का उपयोग अपनी कार्यक्षमता का मूल्यांकन करने और पिछले अनुभवों से सीखने के लिए करता है। उदाहरण के लिए:

1. **उपयोगकर्ता प्रतिक्रिया का विश्लेषण**: ट्रैवल एजेंट यह देखता है कि किन सिफारिशों को उपयोगकर्ताओं ने पसंद किया और किन्हें नहीं। इसके अनुसार भविष्य की सिफारिशें समायोजित करता है।
2. **अनुकूलन क्षमता**: यदि किसी उपयोगकर्ता ने पहले भीड़-भाड़ वाले स्थानों को नापसंद किया है, तो ट्रैवल एजेंट भविष्य में पीक टाइम में लोकप्रिय पर्यटन स्थलों की सिफारिश नहीं करेगा।
3. **त्रुटि सुधार**: यदि ट्रैवल एजेंट ने पिछली बुकिंग में कोई गलती की जैसे कि एक पूरी तरह बुक होटल सुझाना, तो वह आगे से उपलब्धता अधिक कड़ाई से जांचना सीखता है।

#### व्यावहारिक डेवलपर उदाहरण

यहाँ एक सरल उदाहरण है कि ट्रैवल एजेंट पर मेटाकॉग्निशन कोड दिख सकता है:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # प्राथमिकताओं के आधार पर उड़ान, होटल, और आकर्षण खोजें
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # प्रतिक्रिया का विश्लेषण करें और भविष्य की सिफारिशों को समायोजित करें
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# उदाहरण उपयोग
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### मेटाकॉग्निशन क्यों महत्वपूर्ण है

- **आत्म-परावर्तन**: एजेंट अपनी कार्यक्षमता का विश्लेषण कर सुधार के क्षेत्र पहचान सकते हैं।
- **अनुकूलन क्षमता**: एजेंट फ़ीडबैक और बदलती परिस्थितियों के अनुसार रणनीतियों को संशोधित कर सकते हैं।
- **त्रुटि सुधार**: एजेंट स्वतः ही गलतियाँ पहचान कर सुधार कर सकते हैं।
- **संसाधन प्रबंधन**: एजेंट समय और कंप्यूटेशनल शक्ति जैसे संसाधनों का अनुकूलन कर सकते हैं।

मेटाकॉग्निशन को शामिल करके, ट्रैवल एजेंट अधिक व्यक्तिगत और सटीक यात्रा सिफारिशें प्रदान कर सकता है, जिससे समग्र उपयोगकर्ता अनुभव बेहतर होता है।

---

## 2. एजेंट्स में योजना बनाना

योजना बनाना AI एजेंट व्यवहार का एक महत्वपूर्ण घटक है। यह लक्ष्य प्राप्ति के लिए आवश्यक कदमों को परिभाषित करता है, वर्तमान स्थिति, संसाधनों, और संभावित बाधाओं को ध्यान में रखता है।

### योजना के तत्व

- **वर्तमान कार्य**: कार्य को स्पष्ट रूप से परिभाषित करें।
- **कार्यों को पूरा करने के कदम**: कार्य को प्रबंधनीय चरणों में विभाजित करें।
- **आवश्यक संसाधन**: आवश्यक संसाधनों की पहचान करें।
- **अनुभव**: योजना बनाने के लिए पिछले अनुभवों का उपयोग करें।

**उदाहरण**:
ट्रैवल एजेंट को एक उपयोगकर्ता की यात्रा योजना बनाने में प्रभावी सहायता के लिए निम्नलिखित चरण लेने होंगे:

### ट्रैवल एजेंट के कदम

1. **उपयोगकर्ता की प्राथमिकताएं एकत्र करें**
   - उपयोगकर्ता से यात्रा तिथि, बजट, रुचियां, और कोई विशेष आवश्यकताओं के बारे में पूछें।
   - उदाहरण: "आप कब यात्रा करने की योजना बना रहे हैं?" "आपका बजट कितना है?" "आप छुट्टियों में किन गतिविधियों का आनंद लेते हैं?"

2. **सूचना प्राप्त करें**
   - उपयोगकर्ता की प्राथमिकताओं के आधार पर प्रासंगिक यात्रा विकल्प खोजें।
   - **उड़ानें**: उपयोगकर्ता के बजट और पसंदीदा यात्रा तिथियों के भीतर उपलब्ध उड़ानों की तलाश करें।
   - **आवास**: ऐसे होटल या किराये की संपत्तियां खोजें जो स्थान, मूल्य, और सुविधाओं के लिए उपयोगकर्ता की प्राथमिकताओं के अनुरूप हों।
   - **आकर्षण और रेस्टोरेंट्स**: लोकप्रिय आकर्षण, गतिविधियाँ, और भोजन के विकल्प ढूंढें जो उपयोगकर्ता की रुचि से मेल खाते हों।

3. **सिफारिशें बनाएं**
   - प्राप्त जानकारी को एक व्यक्तिगत यात्रा कार्यक्रम में संकलित करें।
   - उपयोगकर्ता की पसंद के अनुसार उड़ान विकल्प, होटल आरक्षण, और सुझाए गए गतिविधियाँ प्रदान करें।

4. **योजना उपयोगकर्ता को प्रस्तुत करें**
   - प्रस्तावित यात्रा कार्यक्रम उपयोगकर्ता की समीक्षा के लिए साझा करें।
   - उदाहरण: "यह आपकी पेरिस यात्रा के लिए एक सुझाया गया कार्यक्रम है। इसमें उड़ान विवरण, होटल बुकिंग, और सुझाई गई गतिविधियों और रेस्टोरेंट्स की सूची शामिल है। कृपया अपनी राय दें!"

5. **प्रतिक्रिया संग्रह करें**
   - उपयोगकर्ता से प्रस्तावित योजना पर प्रतिक्रिया पूछें।
   - उदाहरण: "क्या आपको ये उड़ान विकल्प पसंद आए?" "क्या यह होटल आपकी आवश्यकताओं के अनुरूप है?" "क्या आप कोई गतिविधियाँ जोड़ना या हटाना चाहेंगे?"

6. **प्रतिक्रिया के आधार पर समायोजन करें**
   - उपयोगकर्ता की प्रतिक्रिया के आधार पर योजना में संशोधन करें।
   - उड़ान, आवास, और गतिविधि सिफारिशों में आवश्यक परिवर्तन करें ताकि वे उपयोगकर्ता की प्राथमिकताओं से अधिक मेल खाएँ।

7. **अंतिम पुष्टि**
   - अंतिम पुष्टि के लिए संशोधित योजना उपयोगकर्ता को प्रस्तुत करें।
   - उदाहरण: "मैंने आपकी प्रतिक्रिया के अनुसार समायोजन किए हैं। यह अपडेटेड योजना है। क्या सबकुछ आपके अनुसार ठीक है?"

8. **बुकिंग और पुष्टिकरण करें**
   - उपयोगकर्ता की मंजूरी मिलते ही उड़ानें, आवास, और पूर्व-योजित गतिविधियाँ बुक करें।
   - पुष्टि विवरण उपयोगकर्ता को भेजें।

9. **लगातार सहायता प्रदान करें**
   - यात्रा के दौरान और उससे पहले किसी भी परिवर्तन या अतिरिक्त अनुरोध में उपयोगकर्ता की सहायता के लिए उपलब्ध रहें।
   - उदाहरण: "यदि आपको अपनी यात्रा के दौरान कोई और सहायता चाहिए, तो मुझे कभी भी संपर्क करें!"

### उदाहरण संवाद

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# बुकिंग अनुरोध के भीतर उदाहरण उपयोग
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. सुधारात्मक RAG प्रणाली

सबसे पहले RAG टूल और पूर्व-संकल्पना संदर्भ लोड के बीच अंतर को समझते हैं।

![RAG बनाम संदर्भ लोडिंग](../../../translated_images/hi/rag-vs-context.9eae588520c00921.webp)

### पुनर्प्राप्ति-संपूरक जेनरेशन (RAG)

RAG पुनर्प्राप्ति प्रणाली को जनरेटिव मॉडल के साथ जोड़ता है। जब कोई प्रश्न किया जाता है, तो पुनर्प्राप्ति प्रणाली बाहरी स्रोत से संबंधित दस्तावेज़ या डेटा लाती है, और इस पुनःप्राप्त जानकारी का उपयोग इनपुट को बढ़ाने के लिए किया जाता है। यह मॉडल को अधिक सटीक और संदर्भानुकूल प्रतिक्रियाएँ उत्पन्न करने में मदद करता है।

RAG प्रणाली में, एजेंट ज्ञान आधार से प्रासंगिक जानकारी पुनः प्राप्त करता है और इसका उपयोग उपयुक्त उत्तर या क्रियाएं उत्पन्न करने के लिए करता है।

### सुधारात्मक RAG दृष्टिकोण

सुधारात्मक RAG दृष्टिकोण RAG तकनीकों का उपयोग करके AI एजेंट की त्रुटियों को सुधारने और उनकी सटीकता बढ़ाने पर केंद्रित होता है। इसमें शामिल हैं:

1. **प्रॉम्प्टिंग तकनीक**: एजेंट को प्रासंगिक जानकारी पुनः प्राप्त करने के लिए विशिष्ट संकेतों का उपयोग करना।
2. **उपकरण**: ऐसे एल्गोरिदम और तंत्र लागू करना जो एजेंट को पुनः प्राप्त जानकारी की प्रासंगिकता का मूल्यांकन करने और सटीक उत्तर देने में सक्षम बनाएं।
3. **मूल्यांकन**: एजेंट के प्रदर्शन का निरंतर आकलन करना और उसकी सटीकता एवं दक्षता सुधारने के लिए समायोजन करना।

#### उदाहरण: खोज एजेंट में सुधारात्मक RAG

कल्पना करें कि एक खोज एजेंट उपयोगकर्ता के प्रश्नों का उत्तर देने के लिए वेब से जानकारी प्राप्त करता है। सुधारात्मक RAG विधि में शामिल हो सकता है:

1. **प्रॉम्प्टिंग तकनीक**: उपयोगकर्ता की इनपुट के आधार पर खोज प्रश्न तैयार करना।
2. **उपकरण**: प्राकृतिक भाषा प्रसंस्करण और मशीन लर्निंग एल्गोरिदम का उपयोग करके खोज परिणामों को रैंक और फ़िल्टर करना।
3. **मूल्यांकन**: उपयोगकर्ता प्रतिक्रिया का विश्लेषण करके पुनः प्राप्त जानकारी में त्रुटियों को पहचानना और सुधारना।

### ट्रैवल एजेंट में सुधारात्मक RAG

सुधारात्मक RAG (Retrieval-Augmented Generation) AI की जानकारी पुनः प्राप्त और उत्पन्न करने की क्षमता को सुधारते हुए किसी भी त्रुटि को सही करने में सक्षम बनाता है। देखें कि ट्रैवल एजेंट अधिक सटीक और प्रासंगिक यात्रा सिफारिशें देने हेतु सुधारात्मक RAG दृष्टिकोण का उपयोग कैसे कर सकता है।

इसमें शामिल हैं:

- **प्रॉम्प्टिंग तकनीक:** एजेंट को प्रासंगिक जानकारी पुनः प्राप्त करने हेतु विशिष्ट संकेत देना।
- **उपकरण:** ऐसे एल्गोरिदम और तंत्र जिसका उपयोग एजेंट पुनः प्राप्त जानकारी की प्रासंगिकता का मूल्यांकन और सही उत्तर जारी करने में करता है।
- **मूल्यांकन:** एजेंट के प्रदर्शन का निरंतर आकलन और सटीकता तथा दक्षता सुधारने के लिए समायोजन।

#### ट्रैवल एजेंट में सुधारात्मक RAG लागू करने के कदम

1. **प्रारंभिक उपयोगकर्ता इंटरैक्शन**
   - ट्रैवल एजेंट उपयोगकर्ता से प्रारंभिक प्राथमिकताएं एकत्र करता है, जैसे गंतव्य, यात्रा तिथियाँ, बजट, और रुचियाँ।
   - उदाहरण:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **सूचना पुनः प्राप्ति**
   - ट्रैवल एजेंट उपयोगकर्ता की प्राथमिकताओं के आधार पर उड़ानों, आवास, आकर्षण, और रेस्टोरेंट्स की जानकारी पुनः प्राप्त करता है।
   - उदाहरण:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **प्रारंभिक सिफारिशें तैयार करना**
   - ट्रैवल एजेंट पुनः प्राप्त जानकारी का उपयोग करके एक व्यक्तिगत यात्रा कार्यक्रम तैयार करता है।
   - उदाहरण:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **उपयोगकर्ता प्रतिक्रिया संग्रहण**
   - ट्रैवल एजेंट प्रारंभिक सिफारिशों पर उपयोगकर्ता से प्रतिक्रिया मांगता है।
   - उदाहरण:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **सुधारात्मक RAG प्रक्रिया**
   - **प्रॉम्प्टिंग तकनीक**: ट्रैवल एजेंट उपयोगकर्ता प्रतिक्रिया के आधार पर नए खोज प्रश्न तैयार करता है।
     - उदाहरण:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **उपकरण**: ट्रैवल एजेंट नए खोज परिणामों को रैंक और फ़िल्टर करने के लिए एल्गोरिदम का उपयोग करता है, उपयोगकर्ता प्रतिक्रिया के आधार पर प्रासंगिकता पर जोर देता है।
     - उदाहरण:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **मूल्यांकन**: ट्रैवल एजेंट उपयोगकर्ता प्रतिक्रिया का विश्लेषण कर सिफारिशों की प्रासंगिकता और सटीकता का निरंतर मूल्यांकन करता है और आवश्यक समायोजन करता है।
     - उदाहरण:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### व्यावहारिक उदाहरण

यहां ट्रैवल एजेंट में सुधारात्मक RAG दृष्टिकोण को शामिल करते हुए एक सरल Python कोड उदाहरण है:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# उदाहरण उपयोग
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### पूर्व-संकल्पना संदर्भ लोड
पूर्व-संदर्भ लोड में मॉडल द्वारा क्वेरी को प्रोसेस करने से पहले प्रासंगिक संदर्भ या पृष्ठभूमि जानकारी लोड करना शामिल होता है। इसका मतलब है कि मॉडल को इस जानकारी की शुरुआत से ही पहुँच होती है, जिससे इसे प्रक्रिया के दौरान अतिरिक्त डेटा प्राप्त करने की आवश्यकता नहीं होती और यह अधिक सूचित उत्तर उत्पन्न कर सकता है।

यहाँ एक सरल उदाहरण प्रस्तुत है कि Python में ट्रैवल एजेंट एप्लिकेशन के लिए पूर्व-संदर्भ लोड कैसा दिख सकता है:

```python
class TravelAgent:
    def __init__(self):
        # लोकप्रिय गंतव्यों और उनकी जानकारी को पहले से लोड करें
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # पहले से लोड किए गए संदर्भ से गंतव्य जानकारी प्राप्त करें
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# उपयोग का उदाहरण
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### व्याख्या

1. **प्रारंभिककरण (`__init__` मेथड)**: `TravelAgent` क्लास एक डिक्शनरी को प्री-लोड करती है जिसमें लोकप्रिय गंतव्यों जैसे पेरिस, टोक्यो, न्यूयॉर्क, और सिडनी की जानकारी होती है। इस डिक्शनरी में प्रत्येक गंतव्य के लिए देश, मुद्रा, भाषा, और प्रमुख आकर्षण जैसी जानकारियां शामिल होती हैं।

2. **सूचना प्राप्त करना (`get_destination_info` मेथड)**: जब कोई उपयोगकर्ता किसी विशिष्ट गंतव्य के बारे में प्रश्न करता है, तो `get_destination_info` मेथड प्री-लोड किए गए संदर्भ डिक्शनरी से संबंधित जानकारी प्राप्त करता है।

संदर्भ को प्री-लोड करके, ट्रैवल एजेंट एप्लिकेशन उपयोगकर्ता के प्रश्नों का तुरंत उत्तर दे सकता है बिना इसे रियल-टाइम में किसी बाहरी स्रोत से जानकारी प्राप्त करने की जरूरत पड़े। यह एप्लिकेशन को अधिक कुशल और प्रतिक्रियाशील बनाता है।

### उद्देश्य के साथ योजना बनाना और फिर पुनरावृत्ति करना

किसी योजना को उद्देश्य के साथ शुरू करना मतलब है कि शुरुआत में ही एक स्पष्ट लक्ष्य या अंत परिणाम निर्धारित करना। इस लक्ष्य को पहले से परिभाषित करके, मॉडल इसे पुनरावृत्ति प्रक्रिया के दौरान मार्गदर्शक सिद्धांत के रूप में उपयोग कर सकता है। इससे सुनिश्चित होता है कि प्रत्येक पुनरावृत्ति वांछित परिणाम के करीब होती है, जो प्रक्रिया को अधिक प्रभावी और केंद्रित बनाता है।

यहाँ एक उदाहरण है कि Python में ट्रैवल एजेंट के लिए कैसे आप यात्रा योजना को उद्देश्य के साथ शुरू करके पुनरावृत्त कर सकते हैं:

### परिदृश्य

एक ट्रैवल एजेंट अपने क्लाइंट के लिए एक अनुकूलित छुट्टी योजना बनाना चाहता है। उद्देश्य है क्लाइंट की पसंद और बजट के आधार पर उनकी संतुष्टि को अधिकतम करने वाला यात्रा कार्यक्रम बनाना।

### चरण

1. क्लाइंट की पसंद और बजट निर्धारित करें।
2. इन प्राथमिकताओं के आधार पर प्रारंभिक योजना बनाएं।
3. योजना को पुनरावृत्त करें, क्लाइंट की संतुष्टि के लिए ऑप्टिमाइज़ करते हुए।

#### पायथन कोड

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# उदाहरण उपयोग
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### कोड व्याख्या

1. **प्रारंभिककरण (`__init__` मेथड)**: `TravelAgent` क्लास संभावित गंतव्यों की एक सूची के साथ इनिशियलाइज़ होती है, जिनमें नाम, लागत, और गतिविधि प्रकार जैसे गुण होते हैं।

2. **योजना बनाना (`bootstrap_plan` मेथड)**: यह मेथड क्लाइंट की पसंद और बजट के आधार पर प्रारंभिक यात्रा योजना बनाती है। यह गंतव्यों की सूची के माध्यम से पुनरावृत्त करता है और यदि वे क्लाइंट की पसंदों से मेल खाते हैं और बजट में फिट होते हैं, तो उन्हें योजना में जोड़ता है।

3. **पसंद मिलाना (`match_preferences` मेथड)**: यह मेथड जांचती है कि क्या कोई गंतव्य क्लाइंट की पसंदों से मेल खाता है।

4. **योजना पुनरावृत्ति (`iterate_plan` मेथड)**: यह मेथड प्रारंभिक योजना को सुधारती है, प्रत्येक गंतव्य को बेहतर विकल्प से बदलने का प्रयास करती है, क्लाइंट की पसंदों और बजट प्रतिबंधों को ध्यान में रखते हुए।

5. **लागत की गणना (`calculate_cost` मेथड)**: यह मेथड वर्तमान योजना की कुल लागत की गणना करती है, जिसमें संभावित नया गंतव्य भी शामिल होता है।

#### उदाहरण उपयोग

- **प्रारंभिक योजना**: ट्रैवल एजेंट क्लाइंट की सैर-सपाटा पसंद और $2000 के बजट के आधार पर प्रारंभिक योजना बनाता है।
- **परिष्कृत योजना**: ट्रैवल एजेंट योजना को पुनरावृत्त करता है, क्लाइंट की पसंद और बजट के लिए ऑप्टिमाइज़ करता है।

एक स्पष्ट लक्ष्य के साथ योजना को शुरू करके (जैसे क्लाइंट की संतुष्टि को अधिकतम करना) और योजना को पुनरावृत्त करके सुधार कर, ट्रैवल एजेंट क्लाइंट के लिए एक अनुकूलित और ऑप्टिमाइज़्ड यात्रा कार्यक्रम बना सकता है। यह सुनिश्चित करता है कि यात्रा योजना शुरू से ही क्लाइंट की पसंद और बजट के अनुरूप हो और प्रत्येक पुनरावृत्ति के साथ बेहतर हो।

### LLM का लाभ उठाना: पुनः रैंकिंग और स्कोरिंग के लिए

बड़े भाषा मॉडल (LLMs) पुनः रैंकिंग और स्कोरिंग के लिए इस्तेमाल किए जा सकते हैं ताकि प्राप्त दस्तावेज़ों या जनित प्रतिक्रियाओं की प्रासंगिकता और गुणवत्ता का मूल्यांकन किया जा सके। यह इस प्रकार काम करता है:

**प्राप्ति:** प्रारंभिक प्राप्ति चरण क्वेरी के आधार पर उम्मीदवार दस्तावेज़ों या प्रतिक्रियाओं का एक सेट प्राप्त करता है।

**पुनः रैंकिंग:** LLM इन उम्मीदवारों का मूल्यांकन करता है और उनकी प्रासंगिकता और गुणवत्ता के आधार पर उन्हें पुनः रैंक करता है। यह सुनिश्चित करता है कि सबसे प्रासंगिक और उच्च गुणवत्ता वाली जानकारी पहले प्रस्तुत की जाए।

**स्कोरिंग:** LLM प्रत्येक उम्मीदवार को प्रासंगिकता और गुणवत्ता दर्शाते हुए स्कोर प्रदान करता है। यह उपयोगकर्ता के लिए सर्वश्रेष्ठ प्रतिक्रिया या दस्तावेज़ चुनने में मदद करता है।

LLMs का पुनः रैंकिंग और स्कोरिंग के लिए उपयोग करके, प्रणाली अधिक सटीक और संदर्भ से संबंधित जानकारी प्रदान कर सकती है, जिससे समग्र उपयोगकर्ता अनुभव बेहतर होता है।

यहाँ एक उदाहरण है कि कैसे एक ट्रैवल एजेंट Python में LLM का उपयोग करके उपयोगकर्ता की प्राथमिकताओं के आधार पर यात्रा स्थलों को पुनः रैंक और स्कोर कर सकता है:

#### परिदृश्य - प्राथमिकताओं के आधार पर यात्रा

एक ट्रैवल एजेंट क्लाइंट की प्राथमिकताओं के आधार पर सर्वश्रेष्ठ यात्रा स्थलों की सिफारिश करना चाहता है। LLM पुनः रैंकिंग और स्कोरिंग में मदद करेगा ताकि सबसे प्रासंगिक विकल्प प्रस्तुत किए जा सकें।

#### चरण:

1. उपयोगकर्ता की प्राथमिकताएं एकत्र करें।
2. संभावित यात्रा स्थलों की सूची प्राप्त करें।
3. LLM का उपयोग करके उपयोगकर्ता की प्राथमिकताओं के आधार पर स्थलों को पुनः रैंक और स्कोर करें।

पूर्व के उदाहरण को Azure OpenAI Services के उपयोग के लिए इस तरह अपडेट करें:

#### आवश्यकताएँ

1. आपके पास Azure सब्सक्रिप्शन होना चाहिए।
2. एक Azure OpenAI रिसोर्स बनाएँ और अपनी API कुंजी प्राप्त करें।

#### उदाहरण पायथन कोड

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Azure OpenAI के लिए एक प्रॉम्प्ट उत्पन्न करें
        prompt = self.generate_prompt(preferences)
        
        # अनुरोध के लिए हेडर और पेलोड परिभाषित करें
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # रैंक किए गए और स्कोर किए गए गंतव्यों को प्राप्त करने के लिए Azure OpenAI API को कॉल करें
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # सिफारिशों को निकालें और लौटाएं
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# उदाहरण उपयोग
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### कोड व्याख्या - प्राथमिकता बुकर

1. **प्रारंभिककरण**: `TravelAgent` क्लास संभावित यात्रा स्थलों की सूची के साथ इनिशियलाइज़ होती है, जिनमें नाम और विवरण जैसे गुण होते हैं।

2. **सिफारिश प्राप्त करना (`get_recommendations` मेथड)**: यह मेथड उपयोगकर्ता की प्राथमिकताओं के आधार पर Azure OpenAI सेवा के लिए एक प्रॉम्प्ट जनरेट करता है और Azure OpenAI API को HTTP POST अनुरोध भेजकर पुनः रैंक किए गए और स्कोर किए गए स्थलों को प्राप्त करता है।

3. **प्रॉम्प्ट जनरेट करना (`generate_prompt` मेथड)**: यह मेथड Azure OpenAI के लिए एक प्रॉम्प्ट बनाता है, जिसमें उपयोगकर्ता की प्राथमिकताएं और स्थलों की सूची शामिल होती है। प्रॉम्प्ट मॉडल को दिशा देता है कि किस प्रकार दिए गए प्राथमिकताओं के आधार पर स्थलों को पुनः रैंक और स्कोर किया जाए।

4. **API कॉल**: `requests` लाइब्रेरी का उपयोग Azure OpenAI API एंडपॉइंट पर HTTP POST अनुरोध करने के लिए किया जाता है। प्रतिक्रिया में पुनः रैंक किए गए और स्कोर किए गए स्थल होते हैं।

5. **उदाहरण उपयोग**: ट्रैवल एजेंट उपयोगकर्ता की प्राथमिकताएं (जैसे दर्शनीय स्थल और विविध संस्कृति में रुचि) एकत्र करता है और Azure OpenAI सेवा का उपयोग करके यात्रा स्थलों के लिए पुनः रैंक और स्कोर की गई सिफारिशें प्राप्त करता है।

सुनिश्चित करें कि `your_azure_openai_api_key` को अपनी वास्तविक Azure OpenAI API कुंजी से और `https://your-endpoint.com/...` को अपने Azure OpenAI डिप्लॉयमेंट के असली एंडपॉइंट URL से बदल दें।

LLM का पुनः रैंकिंग और स्कोरिंग के लिए लाभ उठाकर, ट्रैवल एजेंट क्लाइंट को अधिक व्यक्तिगत और प्रासंगिक यात्रा सिफारिशें प्रदान कर सकता है, जिससे उनका समग्र अनुभव बेहतर होता है।

### RAG: प्रॉम्प्टिंग तकनीक बनाम टूल

रिट्रीवल-अगमेंटेड जनरेशन (RAG) AI एजेंट्स के विकास में एक प्रॉम्प्टिंग तकनीक और एक टूल दोनों हो सकता है। इनके बीच का अंतर समझना आपको अपने प्रोजेक्ट्स में RAG का अधिक प्रभावी उपयोग करने में मदद कर सकता है।

#### प्रॉम्प्टिंग तकनीक के रूप में RAG

**यह क्या है?**

- एक प्रॉम्प्टिंग तकनीक के रूप में, RAG विशिष्ट क्वेरी या प्रॉम्प्ट तैयार करने में शामिल होता है ताकि बड़े कॉर्पस या डेटाबेस से प्रासंगिक जानकारी प्राप्त की जा सके। फिर इसका उपयोग प्रतिक्रिया या क्रिया उत्पन्न करने के लिए किया जाता है।

**कैसे काम करता है:**

1. **प्रॉम्प्ट तैयार करना**: कार्य या उपयोगकर्ता के इनपुट के आधार पर सुव्यवस्थित प्रॉम्प्ट या क्वेरी बनाएं।
2. **जानकारी प्राप्त करना**: प्रॉम्प्ट का उपयोग करके पूर्व-स्थित ज्ञान आधार या डेटासेट से प्रासंगिक डेटा खोजें।
3. **प्रतिक्रिया उत्पन्न करना**: प्राप्त जानकारी को जनरेटिव AI मॉडलों के साथ मिलाकर व्यापक और सुसंगत प्रतिक्रिया उत्पन्न करें।

**ट्रैवल एजेंट में उदाहरण**:

- उपयोगकर्ता इनपुट: "मैं पेरिस के संग्रहालयों पर जाना चाहता हूँ।"
- प्रॉम्प्ट: "पेरिस के शीर्ष संग्रहालय खोजें।"
- प्राप्त जानकारी: लौवर संग्रहालय, म्यूज़े डोर्से आदि का विवरण।
- उत्पन्न प्रतिक्रिया: "पेरिस के कुछ प्रमुख संग्रहालय हैं: लौवर संग्रहालय, म्यूज़े डोर्से, और सेंटर पोम्पिदू।"

#### टूल के रूप में RAG

**यह क्या है?**

- एक टूल के रूप में, RAG एक एकीकृत प्रणाली है जो पुनः प्राप्ति और जनरेशन प्रक्रिया को स्वचालित करती है, जिससे डेवलपर्स के लिए जटिल AI कार्यक्षमताओं को लागू करना आसान हो जाता है बिना प्रत्येक क्वेरी के लिए मैन्युअल रूप से प्रॉम्प्ट तैयार किए।

**कैसे काम करता है:**

1. **एकीकरण**: AI एजेंट के संरचना में RAG को एम्बेड करें ताकि यह स्वतः पुनः प्राप्ति और जनरेशन कार्य संभाल सके।
2. **स्वचालन**: यह टूल समग्र प्रक्रिया को प्रबंधित करता है, उपयोगकर्ता इनपुट प्राप्त करने से लेकर अंतिम प्रतिक्रिया उत्पन्न करने तक, बिना प्रत्येक चरण के लिए स्पष्ट प्रॉम्प्ट आवश्यक किए।
3. **कुशलता**: एजेंट के प्रदर्शन को बेहतर बनाता है, जिससे पुनः प्राप्ति और जनरेशन प्रक्रिया तेज़ और अधिक सटीक हो जाती है।

**ट्रैवल एजेंट में उदाहरण**:

- उपयोगकर्ता इनपुट: "मैं पेरिस के संग्रहालयों पर जाना चाहता हूँ।"
- RAG टूल: स्वतः संग्रहालयों की जानकारी प्राप्त करता है और प्रतिक्रिया उत्पन्न करता है।
- उत्पन्न प्रतिक्रिया: "पेरिस के कुछ प्रमुख संग्रहालय हैं: लौवर संग्रहालय, म्यूज़े डोर्से, और सेंटर पोम्पिदू।"

### तुलना

| पहलू                   | प्रॉम्प्टिंग तकनीक                                        | टूल                                                  |
|------------------------|------------------------------------------------------------|------------------------------------------------------|
| **मैन्युअल बनाम स्वचालित**  | प्रत्येक क्वेरी के लिए मैन्युअल प्रॉम्प्ट तैयार करना।          | पुनः प्राप्ति और जनरेशन के लिए स्वचालित प्रक्रिया।     |
| **नियंत्रण**            | पुनः प्राप्ति प्रक्रिया पर अधिक नियंत्रण।                   | पुनः प्राप्ति और जनरेशन को सरल और स्वचालित बनाता है।   |
| **लचीलापन**             | विशिष्ट आवश्यकताओं के अनुसार अनुकूलित प्रॉम्प्ट की अनुमति।  | बड़े पैमाने पर कार्यान्वयन के लिए अधिक कुशल।          |
| **जटिलता**             | प्रॉम्प्ट बनाने और संशोधित करने की आवश्यकता।                  | AI एजेंट की वास्तुकला में सहज एकीकरण आसान बनाता है।  |

### व्यावहारिक उदाहरण

**प्रॉम्प्टिंग तकनीक उदाहरण:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**टूल उदाहरण:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### प्रासंगिकता का मूल्यांकन

प्रासंगिकता का मूल्यांकन AI एजेंट के प्रदर्शन का एक महत्वपूर्ण पहलू है। यह सुनिश्चित करता है कि एजेंट द्वारा प्राप्त और उत्पन्न जानकारी उपयोगकर्ता के लिए उपयुक्त, सटीक और उपयोगी हो। आइए देखें कि AI एजेंट में प्रासंगिकता का मूल्यांकन कैसे किया जाता है, व्यावहारिक उदाहरणों और तकनीकों के साथ।

#### प्रासंगिकता मूल्यांकन की प्रमुख अवधारणाएँ

1. **प्रासंगिकता जागरूकता**:
   - एजेंट को उपयोगकर्ता के प्रश्न का संदर्भ समझना चाहिए ताकि वह प्रासंगिक जानकारी प्राप्त और उत्पन्न कर सके।
   - उदाहरण: यदि उपयोगकर्ता "पेरिस के सर्वश्रेष्ठ रेस्तरां" पूछता है, तो एजेंट को उपयोगकर्ता की प्राथमिकताएं जैसे भोजन प्रकार और बजट ध्यान में रखना चाहिए।

2. **सटीकता**:
   - एजेंट द्वारा प्रदान की गई जानकारी तथ्यात्मक रूप से सही और अद्यतन होनी चाहिए।
   - उदाहरण: वर्तमान में खुले हुए और अच्छी समीक्षाओं वाले रेस्तरां की सिफारिश, न कि पुरानी या बंद जगहों की।

3. **उपयोगकर्ता की मंशा**:
   - एजेंट को पूछताछ के पीछे उपयोगकर्ता की मंशा का अनुमान लगाना चाहिए ताकि सबसे प्रासंगिक जानकारी प्रदान कर सके।
   - उदाहरण: यदि उपयोगकर्ता "बजट के अनुकूल होटल" पूछता है, तो एजेंट सस्ते विकल्पों को प्राथमिकता दे।

4. **फीडबैक लूप**:
   - निरंतर उपयोगकर्ता प्रतिक्रिया एकत्रित करना और विश्लेषण करना एजेंट को अपनी प्रासंगिकता मूल्यांकन प्रक्रिया सुधारने में मदद करता है।
   - उदाहरण: पिछली सिफारिशों पर उपयोगकर्ता की रेटिंग और प्रतिक्रिया को सम्मिलित करना ताकि भविष्य की प्रतिक्रियाएं बेहतर हों।

#### प्रासंगिकता मूल्यांकन के व्यावहारिक तकनीकें

1. **प्रासंगिकता स्कोरिंग**:
   - प्रत्येक प्राप्त वस्तु को उपयोगकर्ता के प्रश्न और प्राथमिकताओं से मेल खाने के आधार पर प्रासंगिकता स्कोर दें।
   - उदाहरण:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **फ़िल्टरिंग और रैंकिंग**:
   - अप्रासंगिक वस्तुओं को हटाएं और शेष को उनके प्रासंगिकता स्कोर के अनुसार क्रमबद्ध करें।
   - उदाहरण:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # शीर्ष 10 संबंधित आइटम लौटाएं
     ```

3. **प्राकृतिक भाषा प्रसंस्करण (NLP)**:
   - उपयोगकर्ता के प्रश्न को समझने और प्रासंगिक जानकारी प्राप्त करने के लिए NLP तकनीकों का उपयोग करें।
   - उदाहरण:

     ```python
     def process_query(query):
         # उपयोगकर्ता के प्रश्न से मुख्य जानकारी निकालने के लिए NLP का उपयोग करें
         processed_query = nlp(query)
         return processed_query
     ```

4. **उपयोगकर्ता प्रतिक्रिया एकीकरण**:
   - प्रदान की गई सिफारिशों पर उपयोगकर्ता की प्रतिक्रिया एकत्र करें और इसका उपयोग भविष्य के प्रासंगिकता मूल्यांकन को समायोजित करने के लिए करें।
   - उदाहरण:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### उदाहरण: ट्रैवल एजेंट में प्रासंगिकता का मूल्यांकन

यहाँ एक व्यावहारिक उदाहरण है कि ट्रैवल एजेंट कैसे यात्रा सिफारिशों की प्रासंगिकता का मूल्यांकन कर सकता है:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # शीर्ष 10 प्रासंगिक आइटम वापस करें

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# उदाहरण उपयोग
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### मंशा के साथ खोज

मंशा के साथ खोज का अर्थ है उपयोगकर्ता के प्रश्न के पीछे छुपे उद्देश्य या लक्ष्य को समझना और व्याख्या करना ताकि सबसे प्रासंगिक और उपयोगी जानकारी प्राप्त और उत्पन्न की जा सके। यह दृष्टिकोण केवल कीवर्ड से मेल खाने से आगे निकल कर उपयोगकर्ता की वास्तविक आवश्यकताओं और संदर्भ को समझने पर केंद्रित होता है।

#### मंशा के साथ खोज की प्रमुख अवधारणाएँ

1. **उपयोगकर्ता की मंशा को समझना**:
   - उपयोगकर्ता की मंशा मुख्य रूप से तीन प्रकार की होती है: जानकारी संबंधी, नेविगेशनल, और लेन-देन संबंधी।
     - **जानकारी संबंधी मंशा**: उपयोगकर्ता किसी विषय के बारे में जानकारी चाहता है (जैसे "पेरिस में सर्वश्रेष्ठ म्यूजियम कौन से हैं?")।
     - **नेविगेशनल मंशा**: उपयोगकर्ता किसी विशिष्ट वेबसाइट या पेज पर जाना चाहता है (जैसे "लौवर म्यूजियम आधिकारिक वेबसाइट")।
     - **लेन-देन संबंधी मंशा**: उपयोगकर्ता कोई लेन-देन करना चाहता है, जैसे फ्लाइट बुकिंग या खरीदारी (जैसे "पेरिस के लिए फ्लाइट बुक करें")।

2. **प्रसंग जागरूकता**:
   - उपयोगकर्ता के प्रश्न के संदर्भ का विश्लेषण करने से उनकी मंशा की सटीक पहचान होती है। इसमें पूर्व बातचीत, उपयोगकर्ता की प्राथमिकताएँ, और वर्तमान प्रश्न के विशिष्ट विवरण शामिल हैं।

3. **प्राकृतिक भाषा प्रसंस्करण (NLP)**:
   - NLP तकनीकों का उपयोग उपयोगकर्ताओं द्वारा दिए गए प्राकृतिक भाषा प्रश्नों को समझने और व्याख्या करने के लिए किया जाता है। इसमें एंटिटी मान्यता, संवेग विश्लेषण, और प्रश्न पार्सिंग जैसे कार्य शामिल हैं।

4. **व्यक्तिगतकरण**:
   - उपयोगकर्ता के इतिहास, प्राथमिकताओं, और प्रतिक्रिया के आधार पर सर्च परिणामों को व्यक्तिगत बनाना प्राप्त जानकारी की प्रासंगिकता को बढ़ाता है।

#### व्यावहारिक उदाहरण: ट्रैवल एजेंट में मंशा के साथ खोज

आइए ट्रैवल एजेंट का उदाहरण लें और देखें कि मंशा के साथ खोज कैसे लागू की जा सकती है।

1. **उपयोगकर्ता प्राथमिकताओं का संग्रहण**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **उपयोगकर्ता की मंशा को समझना**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **संदर्भ जागरूकता**
   ```python
   def analyze_context(query, user_history):
       # वर्तमान प्रश्न को उपयोगकर्ता इतिहास के साथ मिलाएं ताकि संदर्भ समझा जा सके
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **खोजें और परिणामों को व्यक्तिगत बनाएं**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # जानकारीपूर्ण इरादे के लिए उदाहरण खोज तर्क
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # मार्गदर्शक इरादे के लिए उदाहरण खोज तर्क
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # लेनदेन इरादे के लिए उदाहरण खोज तर्क
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # उदाहरण निजीकरण तर्क
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # शीर्ष 10 व्यक्तिगत परिणाम लौटाएं
   ```

5. **उदाहरण उपयोग**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. एक टूल के रूप में कोड उत्पन्न करना

कोड जनरेटिंग एजेंट जटिल समस्याओं को हल करने और कार्यों को स्वचालित करने के लिए AI मॉडल का उपयोग करके कोड लिखते और निष्पादित करते हैं।

### कोड जनरेटिंग एजेंट

कोड जनरेटिंग एजेंट जेनरेटिव AI मॉडलों का उपयोग करके कोड लिखते और निष्पादित करते हैं। ये एजेंट विभिन्न प्रोग्रामिंग भाषाओं में कोड जनरेट और रन करके जटिल समस्याओं को हल कर सकते हैं, कार्यों को स्वचालित कर सकते हैं, और मूल्यवान अंतर्दृष्टि प्रदान कर सकते हैं।

#### व्यावहारिक अनुप्रयोग

1. **स्वचालित कोड जनरेशन**: विशिष्ट कार्यों के लिए कोड स्निपेट उत्पन्न करें, जैसे डेटा विश्लेषण, वेब स्क्रैपिंग, या मशीन लर्निंग।
2. **SQL को RAG के रूप में उपयोग करना**: डेटाबेस से डेटा पुनः प्राप्त करने और उसे संशोधित करने के लिए SQL क्वेरी का उपयोग करें।
3. **समस्या समाधान**: विशिष्ट समस्याओं को हल करने के लिए कोड बनाएँ और निष्पादित करें, जैसे एल्गोरिदम का अनुकूलन या डेटा का विश्लेषण।

#### उदाहरण: डेटा विश्लेषण के लिए कोड जनरेटिंग एजेंट

कल्पना करें कि आप एक कोड जनरेटिंग एजेंट डिजाइन कर रहे हैं। यह इस प्रकार काम कर सकता है:

1. **कार्य**: डेटा सेट का विश्लेषण करना और रुझान व पैटर्न पहचानना।
2. **चरण**:
   - डेटा सेट को डेटा विश्लेषण उपकरण में लोड करें।
   - SQL क्वेरी जनरेट करें ताकि डेटा को फ़िल्टर और समेकित किया जा सके।
   - क्वेरियों को निष्पादित करें और परिणाम प्राप्त करें।
   - परिणामों का उपयोग करके विज़ुअलाइज़ेशन और अंतर्दृष्टियाँ जनरेट करें।
3. **आवश्यक संसाधन**: डेटा सेट, डेटा विश्लेषण उपकरण, और SQL क्षमताएं।
4. **अनुभव**: भविष्य के विश्लेषणों की सटीकता और प्रासंगिकता सुधारने के लिए पिछले विश्लेषण परिणामों का उपयोग करें।

### उदाहरण: ट्रैवल एजेंट के लिए कोड जनरेटिंग एजेंट

इस उदाहरण में, हम एक कोड जनरेटिंग एजेंट, ट्रैवल एजेंट, डिजाइन करेंगे जो उपयोगकर्ताओं की यात्रा योजना बनाने में उनके लिए कोड जेनरेट और निष्पादित करेगा। यह एजेंट यात्रा विकल्प प्राप्त करने, परिणामों को फ़िल्टर करने, और जेनरेटिव AI के उपयोग से यात्रा कार्यक्रम बनाना जैसे कार्य कर सकता है।

#### कोड जनरेटिंग एजेंट का अवलोकन

1. **उपयोगकर्ता प्राथमिकताएं एकत्र करना**: गंतव्य, यात्रा तिथियाँ, बजट, और रुचियों जैसे उपयोगकर्ता इनपुट एकत्र करता है।
2. **डेटा प्राप्त करने के लिए कोड जनरेट करना**: उड़ानें, होटलों, और आकर्षणों के बारे में डेटा पुनः प्राप्त करने के लिए कोड स्निपेट उत्पन्न करता है।
3. **जनरेट किए गए कोड का निष्पादन**: वास्तविक समय की जानकारी प्राप्त करने के लिए जनरेट किए गए कोड चलाता है।
4. **यात्रा कार्यक्रम बनाना**: प्राप्त डेटा को एक व्यक्तिगत यात्रा योजना में संकलित करता है।
5. **प्रतिक्रिया के आधार पर समायोजन करना**: उपयोगकर्ता की प्रतिक्रिया प्राप्त करता है और यदि आवश्यक हो तो परिणामों को परिष्कृत करने के लिए कोड फिर से बनाता है।

#### चरण-दर-चरण कार्यान्वयन

1. **उपयोगकर्ता प्राथमिकताएं एकत्र करना**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **डेटा प्राप्त करने के लिए कोड जनरेट करना**

   ```python
   def generate_code_to_fetch_data(preferences):
       # उदाहरण: उपयोगकर्ता वरीयताओं के आधार पर flights खोजने के लिए कोड जनरेट करें
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # उदाहरण: hotels खोजने के लिए कोड जनरेट करें
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **जनरेट किए गए कोड का निष्पादन**

   ```python
   def execute_code(code):
       # exec का उपयोग करके उत्पन्न कोड को निष्पादित करें
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **यात्रा कार्यक्रम बनाना**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **प्रतिक्रिया के आधार पर समायोजन करना**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # उपयोगकर्ता प्रतिक्रिया के आधार पर प्राथमिकताएँ समायोजित करें
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # अपडेट की गई प्राथमिकताओं के साथ कोड पुनः उत्पन्न करें और निष्पादित करें
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### पर्यावरणीय जागरूकता और तर्क को लागू करना

टेबल के स्कीमा के आधार पर क्वेरी जनरेशन प्रक्रिया में पर्यावरणीय जागरूकता और तर्क को लागू करके सुधार किया जा सकता है।

यहां बताया गया है कि इसे कैसे किया जा सकता है:

1. **स्कीमा को समझना**: सिस्टम टेबल के स्कीमा को समझेगा और इस जानकारी का उपयोग क्वेरी जनरेट करने के लिए आधार के रूप में करेगा।
2. **प्रतिक्रिया के आधार पर समायोजन**: सिस्टम उपयोगकर्ता की प्राथमिकताओं को प्रतिक्रिया के आधार पर समायोजित करेगा और तर्क करेगा कि स्कीमा के किन क्षेत्रों को अपडेट किया जाना है।
3. **क्वेरी जनरेट और निष्पादित करना**: सिस्टम नई प्राथमिकताओं के आधार पर उड़ान और होटल डेटा को अपडेट करने के लिए क्वेरियां जनरेट और निष्पादित करेगा।

यहाँ एक अपडेटेड Python कोड उदाहरण है जो इन अवधारणाओं को शामिल करता है:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # उपयोगकर्ता प्रतिक्रिया के आधार पर प्राथमिकताएँ समायोजित करें
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # अन्य संबंधित प्राथमिकताओं को समायोजित करने के लिए स्कीमा के आधार पर तर्क
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # स्कीमा और प्रतिक्रिया के आधार पर प्राथमिकताओं को समायोजित करने के लिए कस्टम लॉजिक
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # अपडेट की गई प्राथमिकताओं के आधार पर फ्लाइट डेटा लाने के लिए कोड जनरेट करें
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # अपडेट की गई प्राथमिकताओं के आधार पर होटल डेटा लाने के लिए कोड जनरेट करें
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # कोड के निष्पादन का अनुकरण करें और नकली डेटा लौटाएं
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # फ्लाइट, होटल, और आकर्षण के आधार पर यात्रा कार्यक्रम बनाएं
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# उदाहरण स्कीमा
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# उदाहरण उपयोग
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# अपडेट की गई प्राथमिकताओं के साथ कोड पुनः जनरेट करें और निष्पादित करें
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### व्याख्या - प्रतिक्रिया के आधार पर बुकिंग

1. **स्कीमा जागरूकता**: `schema` डिक्शनरी बताती है कि प्रतिक्रिया के आधार पर प्राथमिकताएं कैसे समायोजित की जानी चाहिए। इसमें `favorites` और `avoid` जैसे फ़ील्ड शामिल हैं, जिनमें समायोजन होते हैं।
2. **प्राथमिकताओं को समायोजित करना (`adjust_based_on_feedback` मेथड)**: यह मेथड उपयोगकर्ता की प्रतिक्रिया और स्कीमा के आधार पर प्राथमिकताओं को समायोजित करता है।
3. **पर्यावरण-आधारित समायोजन (`adjust_based_on_environment` मेथड)**: यह मेथड स्कीमा और प्रतिक्रिया के आधार पर समायोजन को अनुकूलित करता है।
4. **क्वेरियों का जनरेशन और निष्पादन**: सिस्टम समायोजित प्राथमिकताओं के आधार पर अद्यतित उड़ान और होटल डेटा प्राप्त करने के लिए कोड जनरेट करता है और इन क्वेरियों को निष्पादित करने का अनुकरण करता है।
5. **यात्रा कार्यक्रम जनरेट करना**: सिस्टम नए उड़ान, होटल और आकर्षण डेटा के आधार पर एक अपडेटेड यात्रा कार्यक्रम बनाता है।

सिस्टम को पर्यावरण-जानकारीपूर्ण और स्कीमा के आधार पर तर्कशील बनाकर यह अधिक सटीक और प्रासंगिक क्वेरीज उत्पन्न कर सकता है, जो बेहतर यात्रा सिफारिशों और अधिक व्यक्तिगत उपयोगकर्ता अनुभव की ओर ले जाता है।

### SQL का उपयोग Retrieval-Augmented Generation (RAG) तकनीक के रूप में

SQL (स्ट्रक्चर्ड क्वेरी लैंग्वेज) डेटाबेस के साथ इंटरैक्ट करने के लिए एक शक्तिशाली उपकरण है। इसे Retrieval-Augmented Generation (RAG) दृष्टिकोण के हिस्से के रूप में उपयोग करने पर, SQL AI एजेंटों में प्रतिक्रियाएं या क्रियाएं उत्पन्न करने और सूचित करने के लिए डेटाबेस से प्रासंगिक डेटा पुनः प्राप्त कर सकता है। आइए देखें कि ट्रैवल एजेंट के संदर्भ में SQL को RAG तकनीक के रूप में कैसे इस्तेमाल किया जा सकता है।

#### प्रमुख अवधारणाएं

1. **डेटाबेस इंटरैक्शन**:
   - SQL का उपयोग डेटाबेस से डेटा क्वेरी करने, संबंधित जानकारी पुनः प्राप्त करने, और डेटा को संशोधित करने के लिए किया जाता है।
   - उदाहरण: यात्रा डेटाबेस से उड़ान विवरण, होटल जानकारी, और आकर्षण प्राप्त करना।

2. **RAG के साथ एकीकरण**:
   - SQL क्वेरीज उपयोगकर्ता इनपुट और प्राथमिकताओं के आधार पर जनरेट की जाती हैं।
   - पुनः प्राप्त डेटा का उपयोग व्यक्तिगत सिफारिशें या क्रियाएं उत्पन्न करने के लिए किया जाता है।

3. **डायनामिक क्वेरी जनरेशन**:
   - AI एजेंट संदर्भ और उपयोगकर्ता जरूरतों के आधार पर डायनामिक SQL क्वेरीज उत्पन्न करता है।
   - उदाहरण: बजट, तिथियां, और रुचियों के आधार पर परिणामों को फ़िल्टर करने के लिए SQL क्वेरीज को कस्टमाइज़ करना।

#### अनुप्रयोग

- **स्वचालित कोड जनरेशन**: विशिष्ट कार्यों के लिए कोड स्निपेट उत्पन्न करना।
- **SQL को RAG के रूप में उपयोग करना**: डेटा को संशोधित करने के लिए SQL क्वेरी का उपयोग।
- **समस्या समाधान**: समस्याओं को हल करने के लिए कोड बनाना और निष्पादित करना।

**उदाहरण**:
एक डेटा विश्लेषण एजेंट:

1. **कार्य**: रुझान खोजने के लिए डेटा सेट का विश्लेषण।
2. **चरण**:
   - डेटा सेट लोड करना।
   - डेटा फ़िल्टर करने के लिए SQL क्वेरी जनरेट करना।
   - क्वेरियों को निष्पादित करना और परिणाम प्राप्त करना।
   - विज़ुअलाइज़ेशन और अंतर्दृष्टियाँ बनाना।
3. **संसाधन**: डेटा सेट एक्सेस, SQL क्षमताएं।
4. **अनुभव**: भविष्य के विश्लेषण सुधारने के लिए पिछले परिणामों का उपयोग।

#### व्यावहारिक उदाहरण: ट्रैवल एजेंट में SQL का उपयोग

1. **उपयोगकर्ता प्राथमिकताएं एकत्र करना**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **SQL क्वेरीज जनरेट करना**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **SQL क्वेरीज निष्पादित करना**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **सिफारिशें जनरेट करना**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### उदाहरण SQL क्वेरियां

1. **उड़ान क्वेरी**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **होटल क्वेरी**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **आकर्षण क्वेरी**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

Retrieval-Augmented Generation (RAG) तकनीक के हिस्से के रूप में SQL का उपयोग करके, ट्रैवल एजेंट जैसे AI एजेंट डायनामिक रूप से प्रासंगिक डेटा पुनः प्राप्त कर सकते हैं और सटीक व व्यक्तिगत सिफारिशें प्रदान कर सकते हैं।

### मेटाकॉग्निशन का उदाहरण

तो मेटाकॉग्निशन के कार्यान्वयन को प्रदर्शित करने के लिए, चलिए एक सरल एजेंट बनाते हैं जो समस्या हल करते समय *अपने निर्णय-निर्माण प्रक्रिया पर प्रतिबिंबित करता है*। इस उदाहरण के लिए, हम एक ऐसा सिस्टम बनाएंगे जहाँ एजेंट होटल का चयन मूल्य और गुणवत्ता के संयोजन के आधार पर करता है, लेकिन फिर अपने तर्क का मूल्यांकन करता है और गलतियों या उपयुक्त विकल्पों के अभाव पर अपनी रणनीति समायोजित करता है।

हम इसे एक बुनियादी उदाहरण से प्रदर्शित करेंगे जहाँ एजेंट होटल चुनता है, लेकिन वह अपने निर्णयों पर "प्रतिबिंबित" करता है और आवश्यकतानुसार समायोजन करता है।

#### यह मेटाकॉग्निशन को कैसे प्रदर्शित करता है:

1. **प्रारंभिक निर्णय**: एजेंट सबसे सस्‍ता होटल चुनेगा, बिना गुणवत्ता के प्रभाव को समझे।
2. **प्रतिबिंब और मूल्यांकन**: प्रारंभिक चयन के बाद, एजेंट उपयोगकर्ता की प्रतिक्रिया के आधार पर जांच करता है कि होटल "खराब" विकल्प तो नहीं था। अगर उसे पता चलता है कि होटल की गुणवत्ता बहुत कम थी, तो वह अपने तर्क पर प्रतिबिंब करता है।
3. **रणनीति में समायोजन**: एजेंट अपने प्रतिबिंब के आधार पर रणनीति को समायोजित करता है, "सबसे सस्‍ता" से "सबसे उच्च गुणवत्ता" में स्विच करता है, इस प्रकार भविष्य के निर्णय-निर्माण प्रक्रिया में सुधार करता है।

यहाँ एक उदाहरण है:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # पहले चुने गए होटलों को संग्रहीत करता है
        self.corrected_choices = []  # संशोधित विकल्पों को संग्रहीत करता है
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # उपलब्ध रणनीतियाँ

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # मान लेते हैं कि हमारे पास उपयोगकर्ता की कुछ प्रतिक्रिया है जो हमें बताती है कि पिछला विकल्प अच्छा था या नहीं
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # यदि पिछला विकल्प संतोषजनक नहीं था तो रणनीति समायोजित करें
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# होटलों की एक सूची का अनुकरण करें (मूल्य और गुणवत्ता)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# एक एजेंट बनाएं
agent = HotelRecommendationAgent()

# चरण 1: एजेंट "सबसे सस्ता" रणनीति का उपयोग करके एक होटल की सिफारिश करता है
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# चरण 2: एजेंट विकल्प पर विचार करता है और आवश्यक होने पर रणनीति समायोजित करता है
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# चरण 3: एजेंट फिर से सिफारिश करता है, इस बार समायोजित रणनीति का उपयोग करते हुए
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### एजेंट की मेटाकॉग्निशन क्षमताएं

यहाँ मुख्य बात है कि एजेंट सक्षम है:
- अपने पिछले चुनावों और निर्णय-निर्माण प्रक्रिया का मूल्यांकन करना।
- उस प्रतिबिंब के आधार पर अपनी रणनीति समायोजित करना, यानी क्रियान्वित मेटाकॉग्निशन।

यह मेटाकॉग्निशन का एक सरल रूप है जहाँ सिस्टम आंतरिक प्रतिक्रिया के आधार पर अपने तर्क प्रक्रिया को समायोजित कर सकता है।

### निष्कर्ष

मेटाकॉग्निशन एक शक्तिशाली उपकरण है जो AI एजेंटों की क्षमताओं को महत्वपूर्ण रूप से बढ़ा सकता है। मेटाकॉग्निटिव प्रक्रियाओं को शामिल करके, आप ऐसे एजेंट डिजाइन कर सकते हैं जो अधिक बुद्धिमान, अनुकूली, और प्रभावी हों। अतिरिक्त संसाधनों का उपयोग करके AI एजेंटों में मेटाकॉग्निशन की रोचक दुनिया का और अन्वेषण करें।

### मेटाकॉग्निशन डिज़ाइन पैटर्न के बारे में और प्रश्न हैं?

[Microsoft Foundry Discord](https://aka.ms/ai-agents/discord) में शामिल हों, अन्य शिक्षार्थियों से मिलें, कार्यालय समय में भाग लें और अपने AI एजेंट सवालों के जवाब पाएं।

## पिछला पाठ

[बहु-एजेंट डिज़ाइन पैटर्न](../08-multi-agent/README.md)

## अगला पाठ

[उत्पादन में AI एजेंट](../10-ai-agents-production/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**अस्वीकरण**:  
इस दस्तावेज़ का अनुवाद एआई अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) का उपयोग करके किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियाँ या असंगतियाँ हो सकती हैं। मूल दस्तावेज़, जो इसकी मूल भाषा में है, उसे अधिकारिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सलाह दी जाती है। इस अनुवाद के उपयोग से उत्पन्न कोई भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।
<!-- CO-OP TRANSLATOR DISCLAIMER END -->