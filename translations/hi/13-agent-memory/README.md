# AI एजेंट्स के लिए मेमोरी 
[![एजेंट मेमोरी](../../../translated_images/hi/lesson-13-thumbnail.959e3bc52d210c64.webp)](https://youtu.be/QrYbHesIxpw?si=qNYW6PL3fb3lTPMk)

जब AI एजेंट बनाने के अनूठे लाभों पर चर्चा की जाती है, तो मुख्य रूप से दो चीज़ों पर बात होती है: कार्यों को पूरा करने के लिए टूल्स को कॉल करने की क्षमता और समय के साथ सुधारने की क्षमता। मेमोरी एक स्वयं-सुधार करने वाले एजेंट बनाने की नींव है जो हमारे उपयोगकर्ताओं के लिए बेहतर अनुभव बना सकता है।

इस पाठ में, हम देखेंगे कि AI एजेंटों के लिए मेमोरी क्या है और हम इसे अपने एप्लिकेशन के लाभ के लिए कैसे प्रबंधित और उपयोग कर सकते हैं।

## परिचय

यह पाठ निम्नको कवर करेगा:

• **AI एजेंट मेमोरी को समझना**: मेमोरी क्या है और एजेंट्स के लिए यह क्यों आवश्यक है।

• **मेमोरी को लागू करना और संग्रहीत करना**: अपने AI एजेंट्स में मेमोरी क्षमताएँ जोड़ने के व्यावहारिक तरीके, जो शॉर्ट-टर्म और लॉन्ग-टर्म मेमोरी पर केंद्रित हैं।

• **AI एजेंट्स को स्वयं-सुधारक बनाना**: कैसे मेमोरी एजेंट्स को पिछले इंटरैक्शनों से सीखने और समय के साथ बेहतर बनने में सक्षम बनाती है।

## उपलब्ध कार्यान्वयन

यह पाठ दो व्यापक नोटबुक ट्यूटोरियल शामिल करता है:

• **[13-agent-memory.ipynb](./13-agent-memory.ipynb)**: Mem0 और Azure AI Search के साथ Semantic Kernel फ्रेमवर्क का उपयोग करके मेमोरी को लागू करता है

• **[13-agent-memory-cognee.ipynb](./13-agent-memory-cognee.ipynb)**: Cognee का उपयोग करके संरचित मेमोरी को लागू करता है, जो एम्बेडिंग द्वारा समर्थित नॉलेज ग्राफ को स्वतः बनाता है, ग्राफ को विज़ुअलाइज़ करता है, और बुद्धिमान पुनःप्राप्ति प्रदान करता है

## सीखने के लक्ष्य

इस पाठ को पूरा करने के बाद, आप जानेंगे कि कैसे:

• **विभिन्न प्रकार की AI एजेंट मेमोरी में अंतर कर सकें**, जिसमें वर्किंग, शॉर्ट-टर्म, और लॉन्ग-टर्म मेमोरी के साथ-साथ व्यक्ति-विशेष (persona) और एपिसोडिक मेमोरी जैसे विशिष्ट रूप शामिल हैं।

• **Semantic Kernel फ्रेमवर्क का उपयोग करके AI एजेंट्स के लिए शॉर्ट-टर्म और लॉन्ग-टर्म मेमोरी को लागू और प्रबंधित करें**, Mem0, Cognee, Whiteboard मेमोरी जैसे टूल्स का लाभ उठाते हुए और Azure AI Search के साथ एकीकृत करते हुए।

• **स्वयं-सुधार करने वाले AI एजेंट्स के पीछे के सिद्धांतों को समझें** और कैसे मजबूत मेमोरी प्रबंधन प्रणालियाँ लगातार सीखने और अनुकूलन में योगदान देती हैं।

## AI एजेंट मेमोरी को समझना

मूल रूप से, **AI एजेंट्स के लिए मेमोरी उन तंत्रों को संदर्भित करती है जो उन्हें जानकारी को बनाए रखने और याद करने की अनुमति देते हैं**। यह जानकारी किसी वार्तालाप के विशिष्ट विवरण, उपयोगकर्ता की प्राथमिकताएँ, पिछले कार्य, या सीखे गए पैटर्न हो सकती है।

मेमोरी के बिना, AI एप्लिकेशन अक्सर स्टेटलेस होते हैं, जिसका अर्थ है कि हर इंटरैक्शन शून्य से शुरू होता है। इससे एक दोहरावशील और निराशाजनक उपयोगकर्ता अनुभव बनता है जहाँ एजेंट पिछले संदर्भ या प्राथमिकताओं को "भूल" जाता है।

### मेमोरी क्यों महत्वपूर्ण है?

एक एजेंट की बुद्धिमत्ता गहराई से इसकी पिछली जानकारी को याद करने और उपयोग करने की क्षमता से जुड़ी होती है। मेमोरी एजेंट्स को सक्षम बनाती है:

• **प्रतिबिंबशील (Reflective)**: पिछले कार्यों और परिणामों से सीखना।

• **इंटरैक्टिव (Interactive)**: एक चल रही बातचीत में संदर्भ बनाए रखना।

• **प्रोएक्टिव और रिएक्टिव (Proactive and Reactive)**: ऐतिहासिक डेटा के आधार पर आवश्यकताओं की उम्मीद करना या उपयुक्त प्रतिक्रिया देना।

• **स्वायत्त (Autonomous)**: संग्रहीत ज्ञान का सहारा लेकर अधिक स्वतंत्र रूप से संचालन करना।

मेमोरी लागू करने का उद्देश्य एजेंट्स को अधिक **विश्वसनीय और सक्षम** बनाना है।

### मेमोरी के प्रकार

#### वर्किंग मेमोरी

इसे उस स्क्रैच पेपर के रूप में सोचें जिसका उपयोग एजेंट एक एकल, चल रहे कार्य या विचार प्रक्रिया के दौरान करता है। यह अगले चरण की गणना के लिए आवश्यक तात्कालिक जानकारी रखता है।

AI एजेंट्स के लिए, वर्किंग मेमोरी अक्सर एक बातचीत से सबसे प्रासंगिक जानकारी पकड़ती है, भले ही पूरा चैट इतिहास लंबा या ट्रंकेटेड हो। यह आवश्यक तत्वों जैसे आवश्यकताएँ, प्रस्ताव, निर्णय और क्रियाओं को निकालने पर ध्यान केंद्रित करती है।

**वर्किंग मेमोरी उदाहरण**

एक यात्रा बुकिंग एजेंट में, वर्किंग मेमोरी उपयोगकर्ता की वर्तमान अनुरोध को पकड़ सकती है, जैसे "मैं पेरिस की यात्रा बुक करना चाहता हूँ"। यह विशिष्ट आवश्यकता वर्तमान इंटरैक्शन का मार्गदर्शन करने के लिए एजेंट के तात्कालिक संदर्भ में रखी जाती है।

#### शॉर्ट टर्म मेमोरी

यह प्रकार एक एकल बातचीत या सत्र की अवधि के लिए जानकारी को बनाए रखता है। यह वर्तमान चैट का संदर्भ है, जो एजेंट को संवाद के पिछले टर्न को संदर्भित करने की अनुमति देता है।

**शॉर्ट टर्म मेमोरी उदाहरण**

यदि एक उपयोगकर्ता पूछता है, "पेरिस के लिए फ्लाइट की लागत कितनी होगी?" और फिर आगे पूछता है, "वहाँ रहने के बारे में क्या?", तो शॉर्ट-टर्म मेमोरी सुनिश्चित करती है कि एजेंट जानता है कि "वहाँ" उसी बातचीत के संदर्भ में "पेरिस" को दर्शाता है।

#### लॉन्ग टर्म मेमोरी

यह वह जानकारी है जो कई बातचीतों या सत्रों में बनी रहती है। यह एजेंट्स को उपयोगकर्ता की प्राथमिकताओं, ऐतिहासिक इंटरैक्शनों, या विस्तारित अवधि पर सामान्य ज्ञान को याद रखने की अनुमति देती है। यह वैयक्तिकरण के लिए महत्वपूर्ण है।

**लॉन्ग टर्म मेमोरी उदाहरण**

एक लॉन्ग-टर्म मेमोरी यह संग्रहीत कर सकती है कि "Ben को स्कीइंग और आउटडोर एक्टिविटीज पसंद हैं, वह पहाड़ी दृश्य के साथ कॉफी पसंद करता है, और पिछले चोट के कारण उन्नत स्की ढलानों से बचना चाहता है"। पिछली इंटरैक्शनों से मिली यह जानकारी भविष्य के यात्रा योजना सत्रों में सिफारिशों को अत्यधिक व्यक्तिगत बनाती है।

#### पर्सोना मेमोरी

यह विशेष मेमोरी प्रकार एजेंट को एक सुसंगत "व्यक्तित्व" या "पर्सोना" विकसित करने में मदद करता है। यह एजेंट को अपने बारे में या इसके इरादे वाले भूमिका के बारे में विवरण याद रखने की अनुमति देता है, जिससे इंटरैक्शन अधिक प्रवाही और केंद्रित होते हैं।

**पर्सोना मेमोरी उदाहरण**
यदि यात्रा एजेंट को एक "विशेषज्ञ स्की प्लैनर" के रूप में डिज़ाइन किया गया है, तो पर्सोना मेमोरी इस भूमिका को मजबूत कर सकती है, और इसकी प्रतिक्रियाओं को एक विशेषज्ञ के स्वर और ज्ञान के अनुरूप प्रभावित कर सकती है।

#### वर्कफ़्लो/एपिसोडिक मेमोरी

यह मेमोरी किसी जटिल कार्य के दौरान एक एजेंट द्वारा लिए गए चरणों के अनुक्रम को संग्रहीत करती है, जिनमें सफलताएँ और असफलताएँ शामिल हैं। यह विशिष्ट "एपिसोड" या पिछली अनुभवों को याद करने जैसा है ताकि उनसे सीखा जा सके।

**एपिसोडिक मेमोरी उदाहरण**

यदि एजेंट ने किसी विशेष फ्लाइट को बुक करने का प्रयास किया लेकिन यह उपलब्धता के कारण विफल रहा, तो एपिसोडिक मेमोरी इस विफलता को रिकॉर्ड कर सकती है, जिससे अगली बार प्रयास के दौरान एजेंट वैकल्पिक फ्लाइट्स आज़मा सके या उपयोगकर्ता को अधिक सूचित तरीके से समस्या के बारे में बता सके।

#### एंटिटी मेमोरी

इसमें बातचीत से विशिष्ट एंटिटीज़ (जैसे लोग, स्थान, या चीज़ें) और घटनाओं को निकालना और याद रखना शामिल है। यह एजेंट को चर्चा किए गए प्रमुख तत्वों की संरचित समझ बनाने की अनुमति देता है।

**एंटिटी मेमोरी उदाहरण**

एक पुरानी यात्रा के बारे में बातचीत से, एजेंट "पेरिस," "आइफेल टावर," और "Le Chat Noir रेस्टोरेंट में डिनर" जैसी एंटिटीज़ निकाल सकता है। भविष्य के इंटरैक्शन में, एजेंट "Le Chat Noir" को याद करके वहां नई आरक्षण करने की पेशकश कर सकता है।

#### स्ट्रक्चर्ड RAG (Retrieval Augmented Generation)

जबकि RAG एक व्यापक तकनीक है, "स्ट्रक्चर्ड RAG" को एक शक्तिशाली मेमोरी तकनीक के रूप में उभारा गया है। यह विभिन्न स्रोतों (बातचीतें, ईमेल, इमेजेज़) से घने, संरचित जानकारी निकालती है और इसका उपयोग प्रतिक्रियाओं में सटीकता, रिकॉल और गति बढ़ाने के लिए करती है। पारंपरिक RAG जो केवल सिमेंटिक समानता पर निर्भर करता है, उसके विपरीत स्ट्रक्चर्ड RAG जानकारी की अंतर्निहित संरचना के साथ काम करता है।

**स्ट्रक्चर्ड RAG उदाहरण**

केवल कीवर्ड मेल खाने के बजाय, स्ट्रक्चर्ड RAG ईमेल से फ्लाइट विवरण (गंतव्य, तिथि, समय, एयरलाइन) पार्स कर सकती है और उन्हें संरचित तरीके से स्टोर कर सकती है। इससे सटीक क्वेरीज संभव होती हैं जैसे "मैंने मंगलवार को पेरिस के लिए किस फ्लाइट की बुकिंग की थी?"

## मेमोरी को लागू और संग्रहीत करना

AI एजेंट्स के लिए मेमोरी को लागू करना एक सुव्यवस्थित प्रक्रिया शामिल करता है जिसे **मेमोरी प्रबंधन** कहा जाता है, जिसमें जानकारी का उत्पन्न करना, भंडारण, पुनःप्राप्ति, एकीकरण, अपडेट, और यहां तक कि "भुलाना" (या हटाना) शामिल है। पुनःप्राप्ति एक विशेष रूप से महत्वपूर्ण पहलू है।

### विशिष्ट मेमोरी टूल्स

#### Mem0

एजेंट मेमोरी को स्टोर और प्रबंधित करने का एक तरीका Mem0 जैसे विशिष्ट टूल्स का उपयोग करना है। Mem0 एक स्थायी मेमोरी परत के रूप में काम करता है, जिससे एजेंट्स प्रासंगिक इंटरैक्शनों को याद कर सकते हैं, उपयोगकर्ता की प्राथमिकताओं और तथ्यात्मक संदर्भ को स्टोर कर सकते हैं, और समय के साथ सफलताओं और विफलताओं से सीख सकते हैं। विचार यहाँ यह है कि स्टेटलेस एजेंट्स स्टेटफुल बन जाते हैं।

यह एक **दो-चरण मेमोरी पाइपलाइन: निष्कर्षण और अपडेट** के माध्यम से काम करता है। पहले, एजेंट के थ्रेड में जो संदेश जोड़े जाते हैं उन्हें Mem0 सेवा को भेजा जाता है, जो बातचीत के इतिहास को सारांशित करने और नई मेमोरी निकालने के लिए एक LLM का उपयोग करती है। बाद में, एक LLM-चालित अपडेट चरण यह निर्धारित करता है कि इन मेमोरियों को जोड़ना, संशोधित करना, या हटाना है या नहीं, और उन्हें एक हाइब्रिड डेटा स्टोर में संग्रहीत किया जाता है जिसमें वेक्टर, ग्राफ और की-वैल्यू डेटाबेस शामिल हो सकते हैं। यह प्रणाली विभिन्न मेमोरी प्रकारों का भी समर्थन करती है और एंटिटीज़ के बीच संबंधों का प्रबंधन करने के लिए ग्राफ मेमोरी को शामिल कर सकती है।

#### Cognee

एक और शक्तिशाली दृष्टिकोण है **Cognee** का उपयोग करना, जो AI एजेंट्स के लिए एक ओपन-सोर्स सिमेंटिक मेमोरी है जो संरचित और असंरचित डेटा को एम्बेडिंग द्वारा समर्थित क्वेरी करने योग्य नॉलेज ग्राफ में बदल देता है। Cognee एक **डुअल-स्टोर आर्किटेक्चर** प्रदान करता है जो वेक्टर समानता खोज को ग्राफ संबंधों के साथ जोड़ता है, जिससे एजेंट्स केवल यह नहीं समझते कि कौन सी जानकारी समान है, बल्कि अवधारणाएँ एक-दूसरे से कैसे संबंधित हैं।

यह **हाइब्रिड पुनःप्राप्ति** में उत्कृष्ट है जो वेक्टर समानता, ग्राफ संरचना, और LLM तर्कशक्ति को मिलाती है - कच्चे चंक लुकअप से लेकर ग्राफ-ज्ञानी प्रश्नोत्तर तक। यह सिस्टम एक **जीवित मेमोरी** बनाए रखता है जो विकसित और बढ़ती रहती है जबकि एक जुड़े हुए ग्राफ के रूप में क्वेरी करने योग्य रहती है, जो शॉर्ट-टर्म सेशन संदर्भ और लॉन्ग-टर्म परसिस्टेंट मेमोरी दोनों का समर्थन करती है।

Cognee नोटबुक ट्यूटोरियल ([13-agent-memory-cognee.ipynb](./13-agent-memory-cognee.ipynb)) इस एकीकृत मेमोरी परत का निर्माण दिखाता है, जिसमें विविध डेटा स्रोतों को इनजेस्ट करने, नॉलेज ग्राफ को विज़ुअलाइज़ करने, और विशिष्ट एजेंट आवश्यकताओं के अनुरूप विभिन्न खोज रणनीतियों के साथ क्वेरी करने के व्यावहारिक उदाहरण शामिल हैं।

### RAG के साथ मेमोरी स्टोर करना

Mem0 जैसे विशिष्ट मेमोरी टूल्स के अलावा, आप मेमोरियों को संग्रहीत और पुनःप्राप्त करने के लिए बैकएंड के रूप में **Azure AI Search** जैसे मजबूत सर्च सेवाओं का लाभ उठा सकते हैं, विशेष रूप से स्ट्रक्चर्ड RAG के लिए।

यह आपको अपने एजेंट की प्रतिक्रियाओं को अपने डेटा के साथ ग्राउंड करने की अनुमति देता है, जिससे अधिक प्रासंगिक और सटीक उत्तर सुनिश्चित होते हैं। Azure AI Search को उपयोगकर्ता-विशिष्ट यात्रा मेमोरी, उत्पाद कैटलॉग, या किसी भी अन्य डोमेन-विशिष्ट ज्ञान को स्टोर करने के लिए उपयोग किया जा सकता है।

Azure AI Search **स्ट्रक्चर्ड RAG** जैसी क्षमताओं का समर्थन करता है, जो बातचीत इतिहास, ईमेल, या यहां तक कि छवियों जैसे बड़े डेटासेट से घनी, संरचित जानकारी निकालने और पुनःप्राप्त करने में उत्कृष्ट है। यह पारंपरिक टेक्स्ट चंकिंग और एम्बेडिंग दृष्टिकोणों की तुलना में "सुपरह्यूमन सटीकता और रिकॉल" प्रदान करता है।

## AI एजेंट्स को स्वयं-सुधारक बनाना

स्वयं-सुधार करने वाले एजेंट्स के लिए एक सामान्य पैटर्न में एक **"नॉलेज एजेंट"** को शामिल करना होता है। यह अलग एजेंट मुख्य उपयोगकर्ता और प्राथमिक एजेंट के बीच बातचीत का अवलोकन करता है। इसकी भूमिका है:

1. **मूल्यवान जानकारी की पहचान करना**: यह निर्धारित करना कि बातचीत का कोई भी भाग सामान्य ज्ञान के रूप में या किसी विशिष्ट उपयोगकर्ता प्राथमिकता के रूप में सहेजे जाने योग्य है या नहीं।

2. **निकालना और सारांशित करना**: बातचीत से आवश्यक सीख या प्राथमिकता को संक्षेपित करना।

3. **नॉलेज बेस में संग्रहीत करना**: इस निकाली गई जानकारी को अक्सर वेक्टर डेटाबेस में स्थायी रूप से सहेजना, ताकि इसे बाद में पुनःप्राप्त किया जा सके।

4. **भविष्य के क्वेयरियों को बढ़ाना**: जब उपयोगकर्ता नया प्रश्न शुरू करता है, तो नॉलेज एजेंट संबंधित संग्रहीत जानकारी पुनःप्राप्त करता है और इसे उपयोगकर्ता के प्रॉम्प्ट में जोड़ देता है, प्राथमिक एजेंट को महत्वपूर्ण संदर्भ प्रदान करता है (RAG के समान)।

### मेमोरी के लिए अनुकूलन

• **लेटेंसी प्रबंधन**: उपयोगकर्ता इंटरैक्शनों को धीमा करने से बचने के लिए, पहली बार में यह जांचने के लिए सस्ता, तेज़ मॉडल उपयोग किया जा सकता है कि क्या जानकारी को संग्रहीत या पुनःप्राप्त करना मूल्यवान है, और केवल आवश्यक होने पर अधिक जटिल निष्कर्षण/पुनःप्राप्ति प्रक्रिया को चालू किया जाता है।

• **नॉलेज बेस रखरखाव**: बढ़ते नॉलेज बेस के लिए, कम बार उपयोग की जाने वाली जानकारी को लागत प्रबंधन के लिए "कोल्ड स्टोरेज" में स्थानांतरित किया जा सकता है।

## क्या आपके पास एजेंट मेमोरी के बारे में और प्रश्न हैं?

अन्य शिक्षार्थियों से मिलने, ऑफिस आवर्स में भाग लेने और अपने AI एजेंट्स के प्रश्नों के उत्तर पाने के लिए [Microsoft Foundry Discord](https://aka.ms/ai-agents/discord) में शामिल हों।

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
अस्वीकरण:
यह दस्तावेज़ AI अनुवाद सेवा "Co-op Translator" (https://github.com/Azure/co-op-translator) का उपयोग करके अनुवादित किया गया है। हम सटीकता के लिए प्रयासरत हैं, लेकिन कृपया ध्यान रखें कि स्वचालित अनुवादों में त्रुटियाँ या अशुद्धियाँ हो सकती हैं। मूल दस्तावेज़ को उसकी मूल भाषा में अधिकारिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।
<!-- CO-OP TRANSLATOR DISCLAIMER END -->