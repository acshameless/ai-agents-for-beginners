[![Többügynökös tervezés](../../../translated_images/hu/lesson-9-thumbnail.38059e8af1a5b71d.webp)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(Kattintson a fenti képre a lecke videójának megtekintéséhez)_
# Metakogníció az MI-ügynökökben

## Bevezetés

Üdv a metakognícióról szóló leckében az MI-ügynököknél! Ez a fejezet kezdőknek készült, akik kíváncsiak arra, hogyan gondolkodhatnak az MI-ügynökök a saját gondolkodási folyamataikról. A lecke végére megérted a kulcsfontosságú fogalmakat, és gyakorlati példákkal leszel felszerelve, hogy alkalmazd a metakogníciót az MI-ügynök tervezésében.

## Tanulási célok

A lecke elvégzése után képes leszel:

1. Megérteni az érvelési hurkok következményeit az ügynökdefiníciókban.
2. Tervezési és értékelési technikákat alkalmazni az önkorrekciós ügynökök támogatására.
3. Saját ügynököket létrehozni, amelyek képesek kódot manipulálni feladatok elvégzéséhez.

## Bevezetés a metakognícióhoz

A metakogníció a magasabb rendű kognitív folyamatokra utal, amelyek magukban foglalják a saját gondolkodásunkról való gondolkodást. MI-ügynökök esetében ez azt jelenti, hogy képesek értékelni és módosítani a cselekvéseiket önismeret és múltbeli tapasztalatok alapján. A metakogníció, vagyis a „gondolkodás a gondolkodásról”, fontos fogalom az ügynöki MI rendszerek fejlesztésében. Magában foglalja, hogy az MI rendszerek tisztában vannak saját belső folyamataikkal, és képesek monitorozni, szabályozni és adaptálni viselkedésüket ennek megfelelően. Hasonlóan ahhoz, ahogy mi felmérjük a helyzetet vagy átgondolunk egy problémát. Ez az önismeret segíthet az MI rendszereknek jobb döntéseket hozni, hibákat felismerni és teljesítményüket idővel javítani — ismét visszakapcsolódva a Turing-teszthez és a vitához arról, hogy az MI át fogja-e venni az irányítást.

Az ügynöki MI rendszerek kontextusában a metakogníció több kihívás kezelésében is segíthet, például:
- Átláthatóság: Biztosítani, hogy az MI rendszerek el tudják magyarázni az érvelésüket és döntéseiket.
- Érvelés: Javítani az MI rendszerek képességét az információk szintetizálására és megalapozott döntések meghozatalára.
- Alkalmazkodás: Lehetővé tenni az MI rendszerek számára, hogy alkalmazkodjanak új környezetekhez és változó feltételekhez.
- Észlelés: Növelni az MI rendszerek pontosságát a környezetükből származó adatok felismerésében és értelmezésében.

### Mi a metakogníció?

A metakogníció, vagyis a „gondolkodás a gondolkodásról”, egy magasabb rendű kognitív folyamat, amely magában foglalja az önismeretet és a saját kognitív folyamataid önszabályozását. Az MI területén a metakogníció lehetővé teszi az ügynökök számára, hogy értékeljék és adaptálják stratégiáikat és cselekvéseiket, ami jobb problémamegoldó és döntéshozó képességekhez vezet. A metakogníció megértésével olyan MI-ügynököket tervezhetsz, amelyek nemcsak intelligensebbek, hanem alkalmazkodóképesebbek és hatékonyabbak is. Az igazi metakogníció esetén az MI kifejezetten érvel a saját érveléséről.

Példa: „Az olcsóbb járatokat részesítettem előnyben, mert… Lehet, hogy kimaradok a közvetlen járatokról, szóval újraellenőrzöm.”  
Nyomon követni, hogyan vagy miért választott egy bizonyos útvonalat.
- Megjegyezni, hogy hibázott, mert túlzottan támaszkodott az előző alkalom felhasználói preferenciáira, ezért módosítja a döntéshozatali stratégiáját, nem csak a végső ajánlást.
- Mintázatok diagnosztizálása, például: „Ha a felhasználó megemlíti, hogy 'túl zsúfolt', nemcsak bizonyos látványosságokat kell eltávolítanom, hanem azt is felismernem, hogy a 'legjobb látványosságok' kiválasztási módszerem hibás, ha mindig népszerűség alapján sorrendezek.”

### A metakogníció jelentősége az MI-ügynökökben

![A metakogníció jelentősége](../../../translated_images/hu/importance-of-metacognition.b381afe9aae352f7.webp)

- Önreflexió: Az ügynökök felmérhetik saját teljesítményüket és azonosíthatják a fejlődési területeket.
- Alkalmazkodóképesség: Az ügynökök módosíthatják stratégiáikat a múltbeli tapasztalatok és a változó környezet alapján.
- Hibajavítás: Az ügynökök önállóan felismerhetik és javíthatják a hibákat, ami pontosabb eredményekhez vezet.
- Erőforrás-kezelés: Az ügynökök optimalizálhatják az erőforrások, például az idő és a számítási kapacitás felhasználását a tervezés és értékelés révén.

## Az MI-ügynök összetevői

Mielőtt belemennénk a metakognitív folyamatokba, fontos megérteni egy MI-ügynök alapvető összetevőit. Egy MI-ügynök tipikusan a következőkből áll:

- Persona: Az ügynök személyisége és jellemzői, amelyek meghatározzák, hogyan lép kapcsolatba a felhasználókkal.
- Eszközök: Azok a képességek és funkciók, amelyeket az ügynök végrehajthat.
- Készségek: Azok a tudás és szaktudás, amelyekkel az ügynök rendelkezik.

Ezek az összetevők együtt egy „szakértelmi egységet” alkotnak, amely képes speciális feladatok végrehajtására.

**Példa**:  
Gondolj egy utazási ügynökre, egy olyan ügynök szolgáltatásra, amely nemcsak megtervezi az üdülésedet, hanem valós idejű adatok és korábbi ügyfélút-tapasztalatok alapján is módosítja az útvonalát.

### Példa: Metakogníció egy utazási ügynök szolgáltatásban

Képzeld el, hogy egy MI-alapú utazási ügynök szolgáltatást tervezel. Ez az ügynök, „Utazási ügynök”, segíti a felhasználókat a nyaralás megtervezésében. A metakogníció beépítéséhez az Utazási ügynöknek értékelnie és módosítania kell a cselekvéseit önismeret és múltbeli tapasztalatok alapján. Íme, hogyan játszhat szerepet a metakogníció:

#### Jelenlegi feladat

A jelenlegi feladat egy felhasználó párizsi utazásának megtervezése.

#### A feladat elvégzésének lépései

1. **Felhasználói preferenciák összegyűjtése**: Kérdezd meg a felhasználót az utazási dátumokról, a költségvetésről, az érdeklődési körökről (pl. múzeumok, gasztronómia, vásárlás) és bármilyen speciális igényről.
2. **Információk lekérése**: Keress repülőjáratokat, szállásokat, látványosságokat és éttermeket, amelyek megfelelnek a felhasználó preferenciáinak.
3. **Ajánlások készítése**: Készíts személyre szabott útitervet a járat részleteivel, szállásfoglalásokkal és javasolt programokkal.
4. **Módosítás visszajelzés alapján**: Kérj visszajelzést a felhasználótól az ajánlásokkal kapcsolatban, és végezd el a szükséges kiigazításokat.

#### Szükséges erőforrások

- Hozzáférés járat- és szállásfoglalási adatbázisokhoz.
- Információk párizsi látványosságokról és éttermekről.
- Korábbi interakciókból származó felhasználói visszajelzési adatok.

#### Tapasztalat és önreflexió

Az Utazási ügynök metakogníciót használ teljesítménye értékelésére és a múltbeli tapasztalatokból való tanulásra. Például:

1. **Felhasználói visszajelzések elemzése**: Az Utazási ügynök átnézi a felhasználói visszajelzéseket, hogy meghatározza, mely ajánlások voltak sikeresek és melyek nem. Ennek megfelelően módosítja a jövőbeli javaslatait.
2. **Alkalmazkodóképesség**: Ha egy felhasználó korábban megemlítette, hogy nem szereti a zsúfolt helyeket, az Utazási ügynök a jövőben elkerüli a népszerű turistahelyek ajánlását a csúcsidőben.
3. **Hibajavítás**: Ha az Utazási ügynök egy korábbi foglalásnál hibát követett el — például egy teljesen foglalt hotelt ajánlott — megtanulja, hogy alaposabban ellenőrizze az elérhetőséget, mielőtt ajánlást tesz.

#### Gyakorlati fejlesztői példa

Itt van egy egyszerűsített példa arra, hogyan nézhet ki az Utazási ügynök kódja a metakogníció beépítésével:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # Járatok, szállodák és látnivalók keresése a preferenciák alapján
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # Visszajelzések elemzése és a jövőbeni ajánlások kiigazítása
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Használati példa
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### Miért fontos a metakogníció

- **Önreflexió**: Az ügynökök elemezhetik teljesítményüket és azonosíthatják a fejlődési területeket.
- **Alkalmazkodóképesség**: Az ügynökök módosíthatják stratégiáikat a visszajelzések és a változó körülmények alapján.
- **Hibajavítás**: Az ügynökök önállóan felismerhetik és korrigálhatják a hibákat.
- **Erőforrás-kezelés**: Az ügynökök optimalizálhatják az erőforrások, például az idő és a számítási kapacitás használatát.

A metakogníció beépítésével az Utazási ügynök személyre szabottabb és pontosabb utazási ajánlásokat tud nyújtani, ezáltal javítva az általános felhasználói élményt.

---

## 2. Tervezés az ügynökökben

A tervezés kritikus eleme az MI-ügynök viselkedésének. Felöleli a cél eléréséhez szükséges lépések kidolgozását, figyelembe véve a jelenlegi állapotot, az erőforrásokat és a lehetséges akadályokat.

### A tervezés elemei

- **Jelenlegi feladat**: Határozd meg világosan a feladatot.
- **A feladat elvégzésének lépései**: Bontsd le a feladatot kezelhető lépésekre.
- **Szükséges erőforrások**: Azonosítsd a szükséges erőforrásokat.
- **Tapasztalat**: Használd a múltbeli tapasztalatokat a tervezés elősegítésére.

**Példa**:  
Itt vannak azok a lépések, amelyeket az Utazási ügynöknek meg kell tennie, hogy hatékonyan segítse a felhasználót az utazás megtervezésében:

### Lépések az utazási ügynök számára

1. **Felhasználói preferenciák összegyűjtése**
   - Kérdezd meg a felhasználót az utazási dátumokról, a költségvetésről, az érdeklődési körökről és bármilyen speciális igényről.
   - Példák: "Mikor tervez utazni?" "Mekkora a költségvetési sáv?" "Milyen tevékenységeket élvez nyaraláskor?"

2. **Információk lekérése**
   - Keress releváns utazási lehetőségeket a felhasználói preferenciák alapján.
   - **Járatok**: Keresd meg az elérhető járatokat a felhasználó költségvetésén és preferált utazási dátumain belül.
   - **Szállások**: Találj hoteleket vagy kiadó ingatlanokat, amelyek megfelelnek a felhasználó elvárásainak (helyszín, ár, felszereltség).
   - **Látványosságok és éttermek**: Azonosíts népszerű látványosságokat, programokat és étkezési lehetőségeket, amelyek illeszkednek a felhasználó érdeklődéséhez.

3. **Ajánlások készítése**
   - Gyűjtsd össze a lekért információkat egy személyre szabott útitervbe.
   - Adj meg részleteket, például járatopciókat, szállásfoglalásokat és javasolt programokat, ügyelve arra, hogy az ajánlások igazodjanak a felhasználó preferenciáihoz.

4. **Az útiterv bemutatása a felhasználónak**
   - Oszd meg a javasolt útitervet a felhasználóval átnézésre.
   - Példa: "Itt egy javasolt útiterv a párizsi utazásához. Tartalmazza a járat részleteit, a szállásfoglalásokat és egy listát a javasolt programokról és éttermekről. Mondja el a véleményét!"

5. **Visszajelzés gyűjtése**
   - Kérdezd meg a felhasználót a javasolt útitervvel kapcsolatban.
   - Példák: "Tetszenek a járatopciók?" "Megfelel Önnek a szálloda?" "Van-e olyan tevékenység, amelyet hozzáadna vagy eltávolítana?"

6. **Visszajelzés alapján történő módosítás**
   - Módosítsd az útitervet a felhasználó visszajelzése alapján.
   - Végezze el a szükséges változtatásokat a járat-, szállás- és programajánlásokban, hogy jobban illeszkedjenek a felhasználó preferenciáihoz.

7. **Végső megerősítés**
   - Mutasd be a frissített útitervet a felhasználónak végső megerősítés céljából.
   - Példa: "Elvégeztem a módosításokat a visszajelzése alapján. Itt a frissített útiterv. Minden rendben van így?"

8. **Foglalások elvégzése és visszaigazolás**
   - Miután a felhasználó jóváhagyta az útitervet, folytasd a járatok, szállások és az előre tervezett tevékenységek foglalását.
   - Küldd el a visszaigazolási részleteket a felhasználónak.

9. **Folyamatos támogatás biztosítása**
   - Maradj elérhető, hogy segítséget nyújts a felhasználónak minden változtatás vagy további kérés esetén az utazás előtt és alatt.
   - Példa: "Ha az utazás során további segítségre van szüksége, bármikor fordulhat hozzám!"

### Példa interakció

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Példa egy fújjolást kérő kérésben való használatra
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. Korrigáló RAG rendszer

Először is kezdjük azzal, hogy megértjük a különbséget a RAG eszköz és az előzetes kontextusbetöltés között

![RAG és kontextusbetöltés összehasonlítása](../../../translated_images/hu/rag-vs-context.9eae588520c00921.webp)

### Lekéréssel kiegészített generálás (RAG)

A RAG egy lekérőrendszert kombinál egy generatív modellel. Amikor kérdés érkezik, a lekérőrendszer releváns dokumentumokat vagy adatokat hoz be egy külső forrásból, és ez a lekért információ kiegészíti a bemenetet a generatív modell számára. Ez segít a modellnek pontosabb és kontextusilag relevánsabb válaszok generálásában.

Egy RAG rendszerben az ügynök releváns információkat keres egy tudásbázisból, és ezeket használja fel megfelelő válaszok vagy cselekvések generálására.

### Korrigáló RAG megközelítés

A Korrigáló RAG megközelítés a RAG technikák hibajavításra és az MI-ügynökök pontosságának javítására való alkalmazására összpontosít. Ez magában foglalja:

1. **Promptolási technika**: Konkrét promptok használata az ügynök irányítására a releváns információk lekérésében.
2. **Eszköz**: Olyan algoritmusok és mechanizmusok megvalósítása, amelyek lehetővé teszik az ügynök számára a lekért információ relevanciájának értékelését és pontos válaszok generálását.
3. **Értékelés**: Az ügynök teljesítményének folyamatos értékelése és a pontosság és hatékonyság javítása érdekében végrehajtott kiigazítások.

#### Példa: Korrigáló RAG egy keresőügynökben

Vegyünk egy keresőügynököt, amely az interneten keres információt a felhasználói kérdések megválaszolásához. A Korrigáló RAG megközelítés magában foglalhatja:

1. **Promptolási technika**: Keresési lekérdezések megfogalmazása a felhasználó bemenete alapján.
2. **Eszköz**: Természetes nyelvfeldolgozás és gépi tanulási algoritmusok használata a keresési eredmények rangsorolására és szűrésére.
3. **Értékelés**: A felhasználói visszajelzés elemzése a lekért információk pontatlanságainak azonosítása és javítása érdekében.

### Korrigáló RAG az Utazási ügynökben

A Korrigáló RAG (Retrieval-Augmented Generation) növeli egy MI képességét az információk lekérésére és generálására, miközben javítja az esetleges pontatlanságokat. Nézzük meg, hogyan használhatja az Utazási ügynök a Korrigáló RAG megközelítést, hogy pontosabb és relevánsabb utazási ajánlásokat nyújtson.

Ez magában foglalja:

- **Promptolási technika:** Konkrét promptok használata az ügynök irányítására a releváns információk lekérésében.
- **Eszköz:** Olyan algoritmusok és mechanizmusok megvalósítása, amelyek lehetővé teszik az ügynök számára a lekért információ relevanciájának értékelését és pontos válaszok generálását.
- **Értékelés:** Az ügynök teljesítményének folyamatos értékelése és a pontosság és hatékonyság javítása érdekében végrehajtott kiigazítások.

#### Lépések a Korrigáló RAG megvalósításához az Utazási ügynökben

1. **Kezdeti felhasználói interakció**
   - Az Utazási ügynök összegyűjti a felhasználó kezdeti preferenciáit, mint a célállomás, utazási dátumok, költségvetés és érdeklődési körök.
   - Példa:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **Információ lekérése**
   - Az Utazási ügynök lekéri az információkat járatokról, szállásokról, látványosságokról és éttermekről a felhasználói preferenciák alapján.
   - Példa:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **Kezdeti ajánlások generálása**
   - Az Utazási ügynök a lekért információk alapján személyre szabott útitervet állít össze.
   - Példa:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **Felhasználói visszajelzés gyűjtése**
   - Az Utazási ügynök visszajelzést kér a felhasználótól a kezdeti ajánlásokkal kapcsolatban.
   - Példa:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **Korrigáló RAG folyamat**
   - **Promptolási technika**: Az Utazási ügynök új keresési lekérdezéseket fogalmaz meg a felhasználói visszajelzések alapján.
     - Példa:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **Eszköz**: Az Utazási ügynök algoritmusokat használ az új keresési eredmények rangsorolására és szűrésére, kiemelve a relevanciát a felhasználói visszajelzés alapján.
     - Példa:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **Értékelés**: Az Utazási ügynök folyamatosan értékeli az ajánlások relevanciáját és pontosságát a felhasználói visszajelzések elemzésével, és elvégzi a szükséges kiigazításokat.
     - Példa:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### Gyakorlati példa

Itt egy leegyszerűsített Python-kód példa, amely a Korrigáló RAG megközelítést integrálja az Utazási ügynökbe:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# Használati példa
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### Előzetes kontextusbetöltés
A megelőző kontextusbetöltés azt jelenti, hogy a lekérdezés feldolgozása előtt betöltik a modellbe a releváns kontextust vagy háttérinformációkat. Ez azt jelenti, hogy a modell már a kezdetektől hozzáfér ezekhez az információkhoz, ami segíthet abban, hogy tájékozottabb válaszokat generáljon anélkül, hogy a folyamat során további adatokat kellene lekérnie.

Here's a simplified example of how a pre-emptive context load might look for a travel agent application in Python:

```python
class TravelAgent:
    def __init__(self):
        # Népszerű úticélok és azok információinak előzetes betöltése
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # Úticél-információk lekérése az előre betöltött kontextusból
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# Használati példa
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### Magyarázat

1. **Inicializálás (`__init__` metódus)**: A `TravelAgent` osztály előre betölt egy szótárt, amely népszerű úti célokról tartalmaz információkat, mint például Paris, Tokyo, New York, és Sydney. Ez a szótár olyan részleteket foglal magában, mint az ország, pénznem, nyelv és a főbb látnivalók minden úti célra vonatkozóan.

2. **Információ lekérése (`get_destination_info` metódus)**: Amikor a felhasználó egy konkrét úti céllal kapcsolatban kérdez, a `get_destination_info` metódus lekéri a releváns információkat az előre betöltött kontextusszótárból.

A kontextus előzetes betöltésével az utazási ügynök alkalmazás gyorsan válaszolhat a felhasználói lekérdezésekre anélkül, hogy valós időben külső forrásból kellene lekérnie ezeket az információkat. Ez hatékonyabbá és reszponzívabbá teszi az alkalmazást.

### Cél alapú tervindítás iterálás előtt

Egy terv cél szerinti inicializálása azt jelenti, hogy világos céllal vagy kívánt eredménnyel kezdünk. Ha ezt a célt előre meghatározzuk, a modell azt vezérlő elvként használhatja a iteratív folyamat során. Ez segít biztosítani, hogy minden iteráció a kívánt eredmény felé mozduljon, így a folyamat hatékonyabb és fókuszáltabb lesz.

Íme egy példa arra, hogyan indíthatod be egy utazási tervet egy céllal, mielőtt iterálnál egy utazási ügynök esetében Pythonban:

### Forgatókönyv

Egy utazási ügynök személyre szabott nyaralást szeretne megtervezni egy kliens számára. A cél egy olyan útiterv létrehozása, amely maximalizálja a kliens elégedettségét az ő preferenciái és költségvetése alapján.

### Lépések

1. Határozd meg a kliens preferenciáit és költségvetését.
2. Inicializáld a kezdeti tervet a preferenciák alapján.
3. Iterálj a terven, hogy finomítsd azt, a kliens elégedettségének optimalizálása érdekében.

#### Python kód

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# Használati példa
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### Kódmagyarázat

1. **Inicializálás (`__init__` metódus)**: A `TravelAgent` osztályt egy lehetséges úti célok listájával inicializáljuk, amelyek mindegyike olyan attribútumokkal rendelkezik, mint név, költség és tevékenységtípus.

2. **A terv inicializálása (`bootstrap_plan` metódus)**: Ez a metódus létrehoz egy kezdeti utazási tervet a kliens preferenciái és költségvetése alapján. Végigiterál az úti célok listáján, és hozzáadja őket a tervhez, ha megfelelnek a kliens preferenciáinak és beleférnek a költségvetésbe.

3. **Preferenciák egyeztetése (`match_preferences` metódus)**: Ez a metódus ellenőrzi, hogy egy úti cél megfelel-e a kliens preferenciáinak.

4. **A terv iterálása (`iterate_plan` metódus)**: Ez a metódus finomítja a kezdeti tervet azáltal, hogy megpróbál minden tervben szereplő úti célt jobb megfelelésre cserélni, figyelembe véve a kliens preferenciáit és a költségvetési korlátokat.

5. **Költségszámítás (`calculate_cost` metódus)**: Ez a metódus kiszámítja az aktuális terv teljes költségét, beleértve egy lehetséges új úti célt is.

#### Példa használat

- **Kezdeti terv**: Az utazási ügynök létrehoz egy kezdeti tervet a kliens városnézésre vonatkozó preferenciái és 2000$-os költségvetése alapján.
- **Finomított terv**: Az utazási ügynök iterál a terven, optimalizálva a kliens preferenciái és költségvetése szerint.

Ha egyértelmű céllal (pl. a kliens elégedettségének maximalizálása) indítjuk el a tervet és iterálunk a finomítás érdekében, az utazási ügynök személyre szabott és optimalizált útitervet hozhat létre a kliens számára. Ez a megközelítés biztosítja, hogy az utazási terv a kezdetektől a kliens preferenciáihoz és költségvetéséhez igazodjon, és minden iterációval javuljon.

### LLM előnyeinek kihasználása átrendezéshez és pontozáshoz

A nagy nyelvi modellek (LLM-ek) használhatók az átrendezésre és pontozásra úgy, hogy értékelik a lekért dokumentumok vagy generált válaszok relevanciáját és minőségét. Íme, hogyan működik:

**Lekérés:** Az első lekérési lépés a lekérdezés alapján egy jelölt dokumentum- vagy válaszkészletet hoz vissza.

**Átrendezés:** Az LLM értékeli ezeket a jelölteket és átrendezi őket relevanciajuk és minőségük alapján. Ez a lépés biztosítja, hogy a legrelevánsabb és legmagasabb minőségű információk jelenjenek meg először.

**Pontozás:** Az LLM pontokat rendel minden jelölthöz, tükrözve azok relevanciáját és minőségét. Ez segít a legjobb válasz vagy dokumentum kiválasztásában a felhasználó számára.

Az LLM-ek átrendezésre és pontozásra történő kihasználásával a rendszer pontosabb és kontextusban relevánsabb információt tud nyújtani, javítva ezzel a felhasználói élményt.

Íme egy példa arra, hogyan használhat egy utazási ügynök egy nagy nyelvi modellt (LLM-et) az úti célok átrendezésére és pontozására a felhasználói preferenciák alapján Pythonban:

#### Forgatókönyv - Utazás preferenciák alapján

Egy utazási ügynök a kliens preferenciái alapján szeretné ajánlani a legjobb úti célokat. Az LLM segít az úti célok átrendezésében és pontozásában, hogy a legrelevánsabb lehetőségek kerüljenek bemutatásra.

#### Lépések:

1. Gyűjtsd össze a felhasználó preferenciáit.
2. Szerezd be a lehetséges úti célok listáját.
3. Használd az LLM-et az úti célok átrendezésére és pontozására a felhasználói preferenciák alapján.

Here’s how you can update the previous example to use Azure OpenAI Services:

#### Követelmények

1. Szükséged van egy Azure-előfizetésre.
2. Hozz létre egy Azure OpenAI erőforrást és szerezz API-kulcsot.

#### Példa Python kód

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Generáljon promptot az Azure OpenAI számára
        prompt = self.generate_prompt(preferences)
        
        # Határozza meg a fejléceket és a kérés törzsét
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # Hívja meg az Azure OpenAI API-t az újrarangsorolt és pontozott célállomások lekéréséhez
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # Kinyerje és adja vissza az ajánlásokat
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# Használati példa
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### Kódmagyarázat - Preference Booker

1. **Inicializálás**: A `TravelAgent` osztályt egy lehetséges úti célok listájával inicializáljuk, amelyek mindegyike olyan attribútumokkal rendelkezik, mint név és leírás.

2. **Ajánlások lekérése (`get_recommendations` metódus)**: Ez a metódus egy promptot generál az Azure OpenAI szolgáltatás számára a felhasználó preferenciái alapján, és HTTP POST kérést küld az Azure OpenAI API-hoz az átrendezett és pontozott úti célok megszerzéséhez.

3. **Prompt generálása (`generate_prompt` metódus)**: Ez a metódus elkészít egy promptot az Azure OpenAI számára, belefoglalva a felhasználó preferenciáit és az úti célok listáját. A prompt irányítja a modellt, hogy az adott preferenciák alapján átrendezze és pontozza az úti célokat.

4. **API hívás**: A `requests` könyvtárat használjuk egy HTTP POST kérés küldésére az Azure OpenAI API végpontjához. A válasz tartalmazza az átrendezett és pontozott úti célokat.

5. **Példa használat**: Az utazási ügynök összegyűjti a felhasználó preferenciáit (pl. érdeklődés városnézés és változatos kultúra iránt), és az Azure OpenAI szolgáltatást használja az úti célok átrendezett és pontozott ajánlásainak megszerzéséhez.

Győződj meg róla, hogy a `your_azure_openai_api_key` értékét a valós Azure OpenAI API-kulccsal helyettesíted, és a `https://your-endpoint.com/...`-t a tényleges Azure OpenAI telepítés végpontjának URL-jére cseréled.

Az LLM átrendezésre és pontozásra történő kihasználásával az utazási ügynök személyre szabottabb és relevánsabb utazási ajánlásokat tud nyújtani az ügyfeleknek, javítva ezáltal az általános élményt.

### RAG: Promptolási technika vs eszköz

A Retrieval-Augmented Generation (RAG) egyszerre lehet promptolási technika és eszköz az AI ügynökök fejlesztésében. A kettő közötti különbség megértése segíthet abban, hogy hatékonyabban használd a RAG-et a projektjeidben.

#### RAG mint promptolási technika

**Mi ez?**

- Mint promptolási technika, a RAG magában foglalja konkrét lekérdezések vagy promptok megfogalmazását, amelyek irányítják a releváns információk kikeresését egy nagy korpuszból vagy adatbázisból. Ezeket az információkat aztán válaszok vagy akciók generálásához használják fel.

**Hogyan működik:**

1. **Promptok megfogalmazása**: Hozz létre jól strukturált promptokat vagy lekérdezéseket a feladat vagy a felhasználó bemenete alapján.
2. **Információ lekérése**: Használd a promptokat releváns adatok keresésére egy meglévő tudásbázisból vagy adathalmazból.
3. **Válasz generálása**: Kombináld a lekért információkat generatív AI modellekkel, hogy átfogó és koherens választ hozz létre.

**Példa az utazási ügynöknél**:

- Felhasználói bemenet: "Múzeumokat akarok meglátogatni Párizsban."
- Prompt: "Találd meg Párizs legjobb múzeumait."
- Lekért információ: Részletek a Louvre Múzeumról, a Musée d'Orsay-ról, stb.
- Generált válasz: "Íme néhány Párizs legjobb múzeuma: Louvre Múzeum, Musée d'Orsay és Centre Pompidou."

#### RAG mint eszköz

**Mi ez?**

- Eszközként a RAG egy integrált rendszer, amely automatizálja a lekérés és generálás folyamatát, megkönnyítve a fejlesztők számára összetett AI funkciók megvalósítását anélkül, hogy minden lekérdezéshez manuálisan kellene promptokat készíteni.

**Hogyan működik:**

1. **Integráció**: Építsd be a RAG-et az AI ügynök architektúrájába, hogy az automatikusan kezelje a lekérési és generálási feladatokat.
2. **Automatizálás**: Az eszköz kezeli az egész folyamatot, a felhasználói bemenet fogadásától a végső válasz generálásáig, anélkül hogy minden lépéshez explicit promptokra lenne szükség.
3. **Hatékonyság**: Javítja az ügynök teljesítményét azáltal, hogy egyszerűsíti a lekérés és generálás folyamatát, lehetővé téve gyorsabb és pontosabb válaszokat.

**Példa az utazási ügynöknél**:

- Felhasználói bemenet: "Múzeumokat akarok meglátogatni Párizsban."
- RAG eszköz: Automatikusan lekéri a múzeumokkal kapcsolatos információkat és generál egy választ.
- Generált válasz: "Íme néhány Párizs legjobb múzeuma: Louvre Múzeum, Musée d'Orsay és Centre Pompidou."

### Összehasonlítás

| Szempont                 | Promptolási technika                                        | Eszköz                                                  |
|------------------------|-------------------------------------------------------------|-------------------------------------------------------|
| **Kézi vs Automatikus**| Minden lekérdezéshez manuálisan megfogalmazott promptok.               | Automatizált folyamat a lekéréshez és generáláshoz.       |
| **Irányítás**            | Több irányítást biztosít a lekérési folyamat felett.             | Egyszerűsíti és automatizálja a lekérést és generálást.|
| **Rugalmasság**        | Lehetővé teszi a testreszabott promptokat speciális igények alapján.      | Hatékonyabb nagy léptékű megvalósításoknál.       |
| **Komplexitás**         | Megköveteli a promptok kidolgozását és finomhangolását.                  | Könnyebb integráció az AI ügynök architektúrájába. |

### Gyakorlati példák

**Promptolási technika példa:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**Eszköz példa:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### Relevancia értékelése

A relevancia értékelése az AI ügynök teljesítményének kulcsfontosságú szempontja. Biztosítja, hogy az ágens által lekért és generált információ megfelelő, pontos és hasznos legyen a felhasználó számára. Nézzük meg, hogyan lehet értékelni a relevanciát AI ügynökök esetén, beleértve gyakorlati példákat és technikákat.

#### A relevancia értékelésének kulcsfogalmai

1. **Kontekstuális tudatosság**:
   - Az ügynöknek meg kell értenie a felhasználó lekérdezésének kontextusát, hogy releváns információkat tudjon lekérni és generálni.
   - Példa: Ha a felhasználó a „Párizs legjobb éttermei” után érdeklődik, az ügynöknek figyelembe kell vennie a felhasználó preferenciáit, például az étkezési típust és a költségvetést.

2. **Pontosság**:
   - Az ügynök által szolgáltatott információnak tényszerűen helyesnek és naprakésznek kell lennie.
   - Példa: Jelenleg nyitva tartó, jó értékelésű éttermek ajánlása a régi vagy bezárt lehetőségek helyett.

3. **Felhasználói szándék**:
   - Az ügynöknek ki kell következtetnie a felhasználó lekérdezése mögötti szándékot, hogy a legrelevánsabb információt tudja nyújtani.
   - Példa: Ha a felhasználó „költségkímélő hoteleket” kér, az ügynöknek az olcsóbb lehetőségeket kell előnyben részesítenie.

4. **Visszacsatolási hurok**:
   - A felhasználói visszajelzések folyamatos gyűjtése és elemzése segíti az ügynököt a relevanciaértékelési folyamat finomításában.
   - Példa: Korábbi ajánlások felhasználói értékeléseinek és visszajelzéseinek bevonása a jövőbeni válaszok javítása érdekében.

#### Gyakorlati technikák a relevancia értékeléséhez

1. **Relevancia pontozás**:
   - Rendelj relevancia pontszámot minden lekért elemhez annak alapján, hogy mennyire felel meg a felhasználó lekérdezésének és preferenciáinak.
   - Példa:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **Szűrés és rangsorolás**:
   - Szűrd ki a relevancia nélküli elemeket, majd rangsorold a megmaradtakat relevancia pontszámaik alapján.
   - Példa:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # Adja vissza a 10 legrelevánsabb elemet
     ```

3. **Természetes nyelvfeldolgozás (NLP)**:
   - Használj NLP technikákat a felhasználó lekérdezésének megértéséhez és releváns információk lekéréséhez.
   - Példa:

     ```python
     def process_query(query):
         # Használj NLP-t a felhasználó lekérdezésének kulcsinformációinak kinyeréséhez.
         processed_query = nlp(query)
         return processed_query
     ```

4. **Felhasználói visszajelzés integrálása**:
   - Gyűjts felhasználói visszajelzést a megadott ajánlásokról, és használd azt a jövőbeni relevanciaértékelések kiigazításához.
   - Példa:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### Példa: Relevancia értékelése az utazási ügynöknél

Íme egy gyakorlati példa arra, hogyan értékelheti a Travel Agent az utazási ajánlások relevanciáját:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # Visszaadja a 10 legrelevánsabb elemet

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# Használati példa
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### Szándékvezérelt keresés

A szándékvezérelt keresés magában foglalja a felhasználó lekérdezése mögötti valódi cél vagy szándék megértését és értelmezését, hogy a legrelevánsabb és leghasznosabb információt tudjuk lekérni és generálni. Ez a megközelítés túlmutat a kulcsszavak egyszerű egyezésén, és a felhasználó tényleges igényeinek és kontextusának megragadására összpontosít.

#### A szándékvezérelt keresés kulcsfogalmai

1. **A felhasználói szándék megértése**:
   - A felhasználói szándék három fő típusba sorolható: információs, navigációs és tranzakciós.
     - **Információs szándék**: A felhasználó információt keres egy témáról (pl. „Melyek Párizs legjobb múzeumai?”).
     - **Navigációs szándék**: A felhasználó egy meghatározott webhelyre vagy oldalra szeretne navigálni (pl. „Louvre Múzeum hivatalos weboldala”).
     - **Tranzakciós szándék**: A felhasználó tranzakciót szeretne végrehajtani, például repülőjegyfoglalást vagy vásárlást (pl. „Foglalj repülőutat Párizsba”).

2. **Kontekstuális tudatosság**:
   - A felhasználó lekérdezésének kontextusának elemzése segít a szándék pontos azonosításában. Ez magában foglalja a korábbi interakciók, a felhasználói preferenciák és az aktuális lekérdezés konkrét részleteinek figyelembevételét.

3. **Természetes nyelvfeldolgozás (NLP)**:
   - NLP technikákat alkalmaznak a felhasználók által megadott természetes nyelvű lekérdezések megértésére és értelmezésére. Ez magában foglal olyan feladatokat, mint az entitásfelismerés, érzelemelemzés és lekérdezés-feldolgozás.

4. **Személyre szabás**:
   - A keresési eredmények személyre szabása a felhasználó előzményei, preferenciái és visszajelzései alapján növeli a lekért információ relevanciáját.

#### Gyakorlati példa: Szándékvezérelt keresés a Travel Agentnél

Vegyük példaként a Travel Agentet, hogy megvizsgáljuk, hogyan lehet megvalósítani a szándékvezérelt keresést.

1. **Felhasználói preferenciák összegyűjtése**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **A felhasználói szándék megértése**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **Kontekstuális tudatosság**

   ```python
   def analyze_context(query, user_history):
       # A jelenlegi lekérdezés és a felhasználó előzményeinek kombinálása a kontextus megértéséhez
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

   ```python
   def analyze_context(query, user_history):
       # A jelenlegi lekérdezés és a felhasználó előzményeinek kombinálása a kontextus megértéséhez
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **Keresés és személyre szabott eredmények**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # Példa keresési logika információs szándékhoz
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # Példa keresési logika navigációs szándékhoz
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # Példa keresési logika tranzakciós szándékhoz
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # Példa személyre szabási logika
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # Adja vissza a 10 legjobb személyre szabott találatot
   ```

5. **Példa használata**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. Kód generálása eszközként

A kódot generáló ügynökök AI-modelleket használnak kód írására és végrehajtására, összetett problémák megoldására és feladatok automatizálására.

### Kódot generáló ügynökök

A kódot generáló ügynökök generatív AI-modelleket használnak kód írására és végrehajtására. Ezek az ügynökök képesek összetett problémákat megoldani, feladatokat automatizálni, és értékes betekintést nyújtani azáltal, hogy különböző programozási nyelveken kódot generálnak és futtatnak.

#### Gyakorlati alkalmazások

1. **Automatizált kódgenerálás**: Kódkivonatok generálása meghatározott feladatokhoz, például adatelemzéshez, weboldalak adatkinyeréséhez (web scraping) vagy gépi tanuláshoz.
2. **SQL, mint RAG**: SQL lekérdezések használata adatok lekérésére és manipulálására adatbázisokból.
3. **Problémamegoldás**: Kód létrehozása és végrehajtása konkrét problémák megoldására, például algoritmusok optimalizálására vagy adatelemzésre.

#### Példa: Kódot generáló ügynök adatelemzéshez

Képzeld el, hogy kódot generáló ügynököt tervezel. Így működhet:

1. **Feladat**: Egy adathalmaz elemzése trendek és mintázatok azonosításához.
2. **Lépések**:
   - Töltsd be az adathalmazt egy adatelemző eszközbe.
   - SQL lekérdezések generálása az adatok szűréséhez és aggregálásához.
   - A lekérdezések végrehajtása és az eredmények lekérése.
   - Az eredmények felhasználása vizualizációk és betekintések létrehozásához.
3. **Szükséges erőforrások**: Hozzáférés az adathalmazhoz, adatelemző eszközökhöz és SQL-képességekhez.
4. **Tapasztalat**: Korábbi elemzési eredmények felhasználása a jövőbeli elemzések pontosságának és relevanciájának javításához.

### Példa: Kódot generáló ügynök utazási asszisztenshez

Ebben a példában egy kódot generáló ügynököt, az Utazási asszisztenst tervezzük, amely kód generálásával és végrehajtásával segíti a felhasználókat utazásuk megtervezésében. Ez az ügynök képes olyan feladatokra, mint az utazási opciók lekérése, az eredmények szűrése és egy útiterv összeállítása generatív AI segítségével.

#### A kódot generáló ügynök áttekintése

1. **Felhasználói preferenciák gyűjtése**: Összegyűjti a felhasználói bemenetet, mint például a célállomás, utazási dátumok, költségvetés és érdeklődési körök.
2. **Adatlekéréshez kód generálása**: Kódkivonatokat generál járatok, szállodák és látnivalók adatainak lekéréséhez.
3. **A generált kód végrehajtása**: Lefuttatja a generált kódot, hogy valós idejű információkat szerezzen.
4. **Útiterv generálása**: A lekért adatokat személyre szabott utitervvé állítja össze.
5. **Visszajelzés alapján történő igazítás**: Megkapja a felhasználói visszajelzést, és szükség esetén újragenerálja a kódot az eredmények finomítása érdekében.

#### Lépésről lépésre megvalósítás

1. **Felhasználói preferenciák gyűjtése**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Adatlekéréshez kód generálása**

   ```python
   def generate_code_to_fetch_data(preferences):
       # Példa: Kód generálása járatok kereséséhez a felhasználó preferenciái alapján
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # Példa: Kód generálása szállodák kereséséhez
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **A generált kód végrehajtása**

   ```python
   def execute_code(code):
       # Futtassa a generált kódot az exec használatával
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **Útiterv generálása**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **Visszajelzés alapján történő igazítás**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # Állítsa a preferenciákat a felhasználói visszajelzés alapján
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # Generálja újra és futtassa a kódot a frissített preferenciákkal
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### A környezeti tudatosság és az érvelés kihasználása

A tábla sémája valóban javíthatja a lekérdezés-generálási folyamatot a környezeti tudatosság és az érvelés felhasználásával.

Íme egy példa, hogyan lehet ezt megvalósítani:

1. **A séma megértése**: A rendszer megérti a tábla sémáját, és ezt az információt felhasználja a lekérdezés-generálás megalapozásához.
2. **Visszajelzés alapján történő igazítás**: A rendszer a visszajelzések alapján módosítja a felhasználói preferenciákat, és megfontolja, mely mezőket kell frissíteni a sémában.
3. **Lekérdezések generálása és végrehajtása**: A rendszer lekérdezéseket generál és hajt végre, hogy a frissített preferenciák alapján lekérje a repülési és szállodai adatokat.

Itt egy frissített Python kódpélda, amely ezeket a koncepciókat beépíti:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # A preferenciák módosítása a felhasználói visszajelzések alapján
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # Séma alapú következtetés a kapcsolódó preferenciák módosításához
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # Egyedi logika a preferenciák módosításához a séma és a visszajelzések alapján
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # Kód generálása a repülőjárat-adatok lekéréséhez a frissített preferenciák alapján
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # Kód generálása a szállodaadatok lekéréséhez a frissített preferenciák alapján
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # A kód végrehajtásának szimulálása és tesztadatok visszaadása
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # Útiterv generálása járatok, szállások és látnivalók alapján
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# Példa séma
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# Használati példa
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# Kód újragenerálása és végrehajtása a frissített preferenciákkal
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### Magyarázat - Foglalás visszajelzés alapján

1. **Séma-tudatosság**: A `schema` szótár meghatározza, hogyan kell a preferenciákat a visszajelzés alapján igazítani. Tartalmaz olyan mezőket, mint `favorites` és `avoid`, a megfelelő módosításokkal.
2. **Preferenciák igazítása (`adjust_based_on_feedback` metódus)**: Ez a metódus a felhasználói visszajelzés és a séma alapján igazítja a preferenciákat.
3. **Környezeti alapú igazítások (`adjust_based_on_environment` metódus)**: Ez a metódus testreszabja az igazításokat a séma és a visszajelzés alapján.
4. **Lekérdezések generálása és végrehajtása**: A rendszer kódot generál a frissített repülő- és szállodai adatok lekéréséhez, és szimulálja e lekérdezések végrehajtását.
5. **Itiner összeállítása**: A rendszer a friss repülési, szállodai és látnivaló-adatok alapján létrehoz egy frissített utitervet.

A rendszer környezeti tudatossá tétele és a séma alapján történő következtetés lehetővé teszi a pontosabb és relevánsabb lekérdezések generálását, ami jobb utazási ajánlásokhoz és személyre szabottabb felhasználói élményhez vezet.

### SQL használata Retrieval-Augmented Generation (RAG) technikaként

SQL (Structured Query Language) erőteljes eszköz az adatbázisokkal való interakcióra. Amikor a Retrieval-Augmented Generation (RAG) megközelítés részeként használják, az SQL képes releváns adatokat lekérni adatbázisokból, hogy informálja és generálja a válaszokat vagy műveleteket az AI ügynökök számára. Vizsgáljuk meg, hogyan használható az SQL RAG technikaként az Utazási ügynök kontextusában.

#### Kulcsfogalmak

1. **Adatbázissal való interakció**:
   - Az SQL-t adatbázisok lekérdezésére, releváns információk lekérésére és az adatok manipulálására használják.
   - Példa: Repülési adatok, szálloda-információk és látnivalók lekérése egy utazási adatbázisból.

2. **Integráció a RAG-gel**:
   - Az SQL lekérdezések a felhasználói bemenet és preferenciák alapján generálódnak.
   - A lekért adatokat ezután személyre szabott ajánlások vagy műveletek generálására használják.

3. **Dinamikus lekérdezés-generálás**:
   - Az AI ügynök dinamikus SQL lekérdezéseket generál a kontextus és a felhasználói igények alapján.
   - Példa: SQL lekérdezések testreszabása az eredmények szűrésére költségvetés, dátumok és érdeklődés alapján.

#### Alkalmazások

- **Automatizált kódgenerálás**: Kódkivonatok generálása meghatározott feladatokhoz.
- **SQL, mint RAG**: SQL lekérdezések használata adatok manipulálására.
- **Problémamegoldás**: Kód létrehozása és végrehajtása problémák megoldására.

**Példa**:
Egy adatelemző ügynök:

1. **Feladat**: Egy adathalmaz elemzése trendek megtalálásához.
2. **Lépések**:
   - Töltsd be az adathalmazt.
   - SQL lekérdezések generálása az adatok szűréséhez.
   - A lekérdezések végrehajtása és az eredmények lekérése.
   - Vizualizációk és betekintések generálása.
3. **Erőforrások**: Hozzáférés az adathalmazhoz, SQL képességek.
4. **Tapasztalat**: Korábbi eredmények felhasználása a jövőbeli elemzések javításához.

#### Gyakorlati példa: SQL használata az utazási ügynökben

1. **Felhasználói preferenciák gyűjtése**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **SQL lekérdezések generálása**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **SQL lekérdezések végrehajtása**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **Ajánlások generálása**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### Példa SQL lekérdezések

1. **Repülőjárat lekérdezés**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **Szálloda lekérdezés**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **Látnivaló lekérdezés**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

Az SQL RAG technikaként való kihasználásával olyan AI ügynökök, mint az Utazási ügynök, dinamikusan lekérhetik és felhasználhatják a releváns adatokat, hogy pontos és személyre szabott ajánlásokat nyújtsanak.

### Metakogníció példája

Tehát hogy bemutassunk egy metakogníció-implementációt, hozzunk létre egy egyszerű ügynököt, amely *visszatükrözi a döntéshozatali folyamatát* miközben megold egy problémát. Ebben a példában egy olyan rendszert építünk, ahol az ügynök a szálloda kiválasztását próbálja optimalizálni, majd értékeli saját érvelését és módosítja stratégiáját, ha hibákat vagy nem optimális választ talál.

#### Hogyan illusztrálja ez a metakogníciót:

1. **Kezdeti döntés**: Az ügynök a legolcsóbb hotelt választja, anélkül, hogy megértené a minőség hatását.
2. **Reflektálás és értékelés**: A kezdeti választást követően az ügynök ellenőrzi, hogy a hotel "rossz" választás volt-e a felhasználói visszajelzés alapján. Ha azt tapasztalja, hogy a hotel minősége túl alacsony volt, reflektál az érvelésére.
3. **Stratégia igazítása**: Az ügynök a reflektálás alapján módosítja stratégiáját, és átvált a "cheapest" módról a "highest_quality" módra, ezáltal javítva döntéshozatali folyamatát a jövőbeli iterációk során.

Itt egy példa:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # Tárolja a korábban kiválasztott hoteleket
        self.corrected_choices = []  # Tárolja a javított választásokat
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # Elérhető stratégiák

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # Tegyük fel, hogy van némi felhasználói visszajelzésünk, amely megmondja, hogy az utolsó választás jó volt-e vagy sem
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # Igazítja a stratégiát, ha az előző választás nem volt kielégítő
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# Hotelek listájának szimulálása (ár és minőség)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# Ügynök létrehozása
agent = HotelRecommendationAgent()

# 1. lépés: Az ügynök a "legolcsóbb" stratégia szerint javasol egy hotelt
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# 2. lépés: Az ügynök átgondolja a választást és szükség esetén igazítja a stratégiát
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# 3. lépés: Az ügynök újra ajánl, ezúttal a módosított stratégiát használva
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### Az ügynökök metakognitív képességei

A lényeg az ügynök azon képessége, hogy:
- Értékelje korábbi választásait és döntéshozatali folyamatát.
- Igazítsa stratégiáját az ezen történő reflektálás alapján, azaz metakogníció a gyakorlatban.

Ez a metakogníció egy egyszerű formája, ahol a rendszer képes a belső visszajelzés alapján módosítani érvelési folyamatát.

### Következtetés

A metakogníció egy erőteljes eszköz, amely jelentősen növelheti az AI ügynökök képességeit. A metakognitív folyamatok beépítésével olyan ügynököket tervezhetsz, amelyek intelligensebbek, alkalmazkodóbbak és hatékonyabbak. Használd a további forrásokat, hogy mélyebben felfedezd a metakogníció lenyűgöző világát az AI ügynökökben.

### Több kérdésed van a metakogníció tervezési mintájáról?

Csatlakozz a [Microsoft Foundry Discord](https://aka.ms/ai-agents/discord) közösséghez, találkozz más tanulókkal, vegyél részt konzultációs órákon és kapj választ az AI ügynökökkel kapcsolatos kérdéseidre.

## Előző lecke

[Többügynökös tervezési minta](../08-multi-agent/README.md)

## Következő lecke

[AI ügynökök éles környezetben](../10-ai-agents-production/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
Felelősségkizárás:
Ez a dokumentum az AI-fordító szolgáltatás [Co-op Translator](https://github.com/Azure/co-op-translator) segítségével készült. Bár a pontosságra törekszünk, kérjük, vegye figyelembe, hogy az automatikus fordítások hibákat vagy pontatlanságokat tartalmazhatnak. Az eredeti dokumentum az anyanyelvén tekintendő a hiteles forrásnak. Kritikus fontosságú információk esetén professzionális, emberi fordítást javaslunk. Nem vállalunk felelősséget a fordítás használatából eredő félreértésekért vagy téves értelmezésekért.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->