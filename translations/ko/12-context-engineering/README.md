# AI 에이전트를 위한 컨텍스트 엔지니어링

[![Context Engineering](../../../translated_images/ko/lesson-12-thumbnail.ed19c94463e774d4.webp)](https://youtu.be/F5zqRV7gEag)

> _(위 이미지를 클릭하면 이 수업의 동영상을 볼 수 있습니다)_

AI 에이전트를 구축하는 애플리케이션의 복잡성을 이해하는 것은 신뢰할 수 있는 에이전트를 만드는 데 중요합니다. 우리는 프롬프트 엔지니어링을 넘어 복잡한 요구를 해결하기 위해 정보를 효과적으로 관리하는 AI 에이전트를 구축해야 합니다.

이번 수업에서는 컨텍스트 엔지니어링이 무엇이며 AI 에이전트 구축에서 어떤 역할을 하는지 살펴보겠습니다.

## 소개

이번 수업에서는 다음 내용을 다룹니다:

• **컨텍스트 엔지니어링이 무엇인지** 및 이것이 프롬프트 엔지니어링과 어떻게 다른지.

• **효과적인 컨텍스트 엔지니어링을 위한 전략**, 정보 작성, 선택, 압축 및 격리 방법 포함.

• AI 에이전트를 망칠 수 있는 **일반적인 컨텍스트 실패 사례**와 이를 해결하는 방법.

## 학습 목표

이번 수업을 완료하면 다음을 이해하게 됩니다:

• **컨텍스트 엔지니어링을 정의**하고 프롬프트 엔지니어링과 구분할 수 있습니다.

• 대형 언어 모델(LLM) 애플리케이션에서 **컨텍스트의 핵심 요소를 식별**할 수 있습니다.

• 에이전트 성능 향상을 위해 **컨텍스트 작성, 선택, 압축, 격리 전략을 적용**할 수 있습니다.

• **중독(poisoining), 산만(distraction), 혼란(confusion), 충돌(clash)**과 같은 일반적인 컨텍스트 오류를 인식하고 완화 기술을 구현할 수 있습니다.

## 컨텍스트 엔지니어링이란?

AI 에이전트에 있어 컨텍스트는 AI 에이전트가 특정 행동을 계획하는 동인입니다. 컨텍스트 엔지니어링은 AI 에이전트가 작업의 다음 단계를 완료하는 데 필요한 정확한 정보를 확보하도록 하는 실천 방법입니다. 컨텍스트 창은 크기에 제한이 있으므로, 에이전트 제작자는 컨텍스트 창 내 정보를 추가, 제거, 압축하는 시스템과 절차를 구축해야 합니다.

### 프롬프트 엔지니어링과 컨텍스트 엔지니어링의 차이

프롬프트 엔지니어링은 AI 에이전트에게 효과적으로 안내하는 단일 정적 명령 세트에 집중합니다. 반면에 컨텍스트 엔지니어링은 초기 프롬프트를 포함하여 시간 경과에 따라 AI 에이전트가 필요로 하는 동적인 정보를 관리하는 방법입니다. 컨텍스트 엔지니어링의 핵심 개념은 이 과정을 반복 가능하고 신뢰할 수 있게 하는 것입니다.

### 컨텍스트의 유형

[![Types of Context](../../../translated_images/ko/context-types.fc10b8927ee43f06.webp)](https://youtu.be/F5zqRV7gEag)

컨텍스트는 단 하나의 것이 아니라는 점을 기억하는 것이 중요합니다. AI 에이전트가 필요로 하는 정보는 다양한 출처에서 올 수 있으며, 에이전트가 이 출처들에 접근할 수 있도록 하는 것이 우리의 역할입니다:

AI 에이전트가 관리해야 할 수 있는 컨텍스트 유형은 다음과 같습니다:

• **지침(Instructions):** 에이전트의 "규칙"과 같습니다 – 프롬프트, 시스템 메시지, 몇 가지 예시(에이전트가 작업을 수행하는 방법 보여주기), 그리고 사용할 수 있는 도구의 설명입니다. 여기에 프롬프트 엔지니어링과 컨텍스트 엔지니어링이 결합되어 있습니다.

• **지식(Knowledge):** 사실, 데이터베이스에서 검색한 정보 또는 에이전트가 축적한 장기 기억을 포함합니다. 에이전트가 여러 지식 저장소와 데이터베이스에 접근이 필요하면 RAG(Retrieval Augmented Generation) 시스템 통합이 포함됩니다.

• **도구(Tools):** 에이전트가 호출할 수 있는 외부 함수, API, MCP 서버 정의와 사용 후 피드백(결과)입니다.

• **대화 기록(Conversation History):** 사용자와 진행되는 대화입니다. 시간이 지남에 따라 대화가 길고 복잡해져 컨텍스트 창 공간을 차지합니다.

• **사용자 선호도(User Preferences):** 시간이 지남에 따라 사용자의 취향과 싫어하는 정보를 배우는 것입니다. 이는 저장되어 중요한 결정을 내릴 때 사용자를 돕기 위해 호출될 수 있습니다.

## 효과적인 컨텍스트 엔지니어링 전략

### 계획 전략

[![Context Engineering Best Practices](../../../translated_images/ko/best-practices.f4170873dc554f58.webp)](https://youtu.be/F5zqRV7gEag)

좋은 컨텍스트 엔지니어링은 좋은 계획에서 시작됩니다. 다음은 컨텍스트 엔지니어링 개념을 적용하는 방법을 생각하는 데 도움이 되는 접근법입니다:

1. **명확한 결과 정의** – AI 에이전트에게 할당될 작업 결과는 명확하게 정의되어야 합니다. "AI 에이전트가 작업을 끝냈을 때 세상은 어떻게 변해 있을까?"라는 질문에 답하세요. 즉, 사용자가 AI 에이전트와 상호작용 후에 가져야 할 변화, 정보, 혹은 응답이 무엇인지 정의합니다.

2. **컨텍스트 매핑** – AI 에이전트의 결과를 정의한 후에는 "이 작업을 완료하기 위해 AI 에이전트가 어떤 정보가 필요할까?"라는 질문에 답해야 합니다. 이를 통해 해당 정보를 어디서 얻을 수 있는지 컨텍스트를 매핑할 수 있습니다.

3. **컨텍스트 파이프라인 생성** – 정보 위치를 알게 되었으니 "에이전트가 이 정보를 어떻게 얻을까?"라는 질문에 답해야 합니다. RAG, MCP 서버 사용 등 다양한 방법으로 구현할 수 있습니다.

### 실용적인 전략

계획이 중요하지만 정보가 에이전트의 컨텍스트 창으로 흘러들어오기 시작하면 이를 관리할 실용적인 전략이 필요합니다:

#### 컨텍스트 관리

일부 정보는 자동으로 컨텍스트 창에 추가되지만, 컨텍스트 엔지니어링은 이 정보를 보다 적극적으로 다루는 것을 의미하며, 다음 몇 가지 전략으로 수행할 수 있습니다:

 1. **에이전트 스크래치패드**
 이 기능은 에이전트가 단일 세션 동안 현재 작업 및 사용자 상호작용에 관한 관련 정보를 메모하도록 합니다. 이는 컨텍스트 창 외부에 파일이나 런타임 객체로 존재하여 에이전트가 필요할 때 나중에 검색할 수 있어야 합니다.

 2. **메모리(Memories)**
 스크래치패드는 단일 세션 컨텍스트 밖의 정보를 관리하는 데 적합합니다. 메모리는 여러 세션에 걸쳐 관련 정보를 저장하고 검색할 수 있게 합니다. 요약, 사용자 선호도, 미래 개선을 위한 피드백 등을 포함할 수 있습니다.

 3. **컨텍스트 압축**
 컨텍스트 창이 커져 한계에 가까워지면 요약과 자르기(트리밍) 같은 기술을 사용할 수 있습니다. 가장 관련성 높은 정보만 남기거나 오래된 메시지를 제거하는 방식입니다.
  
 4. **멀티 에이전트 시스템**
 멀티 에이전트 시스템 개발은 각 에이전트가 자체 컨텍스트 창을 가지므로 컨텍스트 엔지니어링의 한 형태입니다. 이 컨텍스트를 어떻게 공유하고 다른 에이전트에 전달할지 계획하는 것도 중요합니다.
  
 5. **샌드박스 환경**
 에이전트가 코드를 실행하거나 문서 내 대량의 정보를 처리해야 한다면 처리 결과를 얻는 데 많은 토큰이 소모됩니다. 이를 모두 컨텍스트 창에 저장하는 대신, 코드를 실행하고 결과 및 주요 정보만 읽을 수 있는 샌드박스 환경을 사용할 수 있습니다.
  
 6. **런타임 상태 객체**
 에이전트가 특정 정보에 접근해야 할 상황을 관리하기 위해 정보 컨테이너를 만듭니다. 복잡한 작업에서는 각 하위 작업의 결과를 단계별로 저장하여 컨텍스트가 그 특정 하위 작업과만 연결되도록 할 수 있습니다.
  
### 컨텍스트 엔지니어링 예시

만약 AI 에이전트에게 **"파리 여행을 예약해줘."**라고 요청한다면,

• 단순히 프롬프트 엔지니어링만 사용하는 에이전트는 **"알겠습니다, 파리 여행 날짜가 언제인가요?"**와 같이 질문당시 직접적인 질문만 처리할 것입니다.

• 컨텍스트 엔지니어링 전략을 사용하는 에이전트는 훨씬 더 많은 일을 수행합니다. 응답하기 전에 시스템이:

  ◦ 실시간 데이터를 이용해 **캘린더를 확인**하여 가능한 날짜를 찾습니다.

  ◦ 장기 기억에서 과거 여행 선호도(선호하는 항공사, 예산, 직항 선호 여부 등)를 **회상**합니다.

  ◦ 항공권과 호텔 예약 도구를 **식별**합니다.

- 그러면 예시 응답은: "안녕하세요 [사용자 이름]! 10월 첫째 주에 자유 시간이 있으시네요. 평소 예산 내에서 [선호 항공사] 직항편을 찾아볼까요?" 와 같이 더욱 풍부한 컨텍스트 기반 응답을 보여줍니다.

## 일반적인 컨텍스트 실패 사례

### 컨텍스트 중독(Context Poisoning)

**무엇인가:** 환각(hallucination; LLM이 생성한 거짓 정보) 또는 오류가 컨텍스트에 들어가 반복 참조되면서 에이전트가 불가능한 목표를 추구하거나 무의미한 전략을 개발하게 되는 경우.

**대처법:** **컨텍스트 검증**과 **격리**(quarantine) 구현. 정보를 장기 기억에 추가하기 전에 검증합니다. 중독 가능성이 감지되면 새 컨텍스트 스레드를 시작하여 나쁜 정보 확산을 방지합니다.

**여행 예약 예시:** 에이전트가 실제 국제 항공편이 없는 작은 지역 공항에서 먼 도시로 가는 **직항편이 있다고 환각**합니다. 이 존재하지 않는 비행 정보가 컨텍스트에 저장됩니다. 이후 예약 시 에이전트가 이 불가능한 경로의 티켓을 찾으려 반복 실패합니다.

**해결책:** 비행 정보가 작업 컨텍스트에 추가되기 _전에_ **실시간 API를 사용해 비행 존재 여부와 노선을 검증**하는 단계를 구현합니다. 검증에 실패하면 잘못된 정보는 "격리"되어 더 이상 사용되지 않습니다.

### 컨텍스트 산만(Context Distraction)

**무엇인가:** 컨텍스트가 너무 커져 모델이 학습 중에 익힌 내용보다 누적된 이력에 너무 집중하여 반복적이거나 도움이 안 되는 행동을 하는 경우. 컨텍스트 창이 가득 차기 전에 실수가 발생할 수 있음.

**대처법:** **컨텍스트 요약** 사용. 누적된 정보를 주기적으로 짧은 요약으로 압축해 중요한 부분은 유지하고 중복된 이력은 제거합니다. 포커스를 "재설정"하는 데 도움됩니다.

**여행 예약 예시:** 오랜 기간 동안 배낭여행 경험을 포함해 여러 드림 여행지를 자세히 이야기했습니다. 이후 **"다음 달 저렴한 항공권 찾아줘"**라고 요청했을 때 에이전트가 오래된 불필요한 정보에 빠져 배낭 장비나 과거 일정에 대해 계속 질문하며 현재 요청을 무시합니다.

**해결책:** 일정 턴 수 후 또는 컨텍스트가 너무 커지면 에이전트가 **가장 최신이고 관련 있는 대화 부분을 요약**해서 현재 여행 날짜와 목적지에 집중한 요약을 다음 LLM 호출에 사용하고 덜 관련된 과거 대화는 폐기합니다.

### 컨텍스트 혼란(Context Confusion)

**무엇인가:** 불필요한 대량 도구가 있을 때 모델이 엉뚱한 답변을 하거나 무관한 도구를 호출하는 경우. 작은 모델이 특히 취약함.

**대처법:** RAG 기법을 활용한 **도구 로드아웃 관리**를 구현합니다. 도구 설명을 벡터 데이터베이스에 저장하고 특정 작업에 필요한 가장 관련성 높은 도구만 선택합니다. 연구 결과 30개 미만으로 도구를 제한하는 것이 좋습니다.

**여행 예약 예시:** 에이전트가 `book_flight`, `book_hotel`, `rent_car`, `find_tours`, `currency_converter`, `weather_forecast`, `restaurant_reservations` 등 수십 개 도구에 접근합니다. 당신이 **"파리에서 가장 좋은 교통수단은?"**이라고 묻자 너무 많은 도구 때문에 혼란이 생겨 `book_flight`를 파리 안에서 호출하거나 대중교통을 선호하는데도 불구하고 `rent_car`를 호출하는 등 잘못된 선택을 합니다.

**해결책:** 도구 설명에 대해 **RAG를 사용**해 파리에서 이동 관련 쿼리 시 `rent_car`나 `public_transport_info` 같은 가장 관련 도구만 동적으로 불러와 LLM에 집중된 도구 "로드아웃"을 제공합니다.

### 컨텍스트 충돌(Context Clash)

**무엇인가:** 컨텍스트 내부에 상충하는 정보가 있어 일관성 없는 추론이나 부적절한 최종 응답이 발생합니다. 보통 정보가 단계별로 도착하면서 초기에 잘못된 가정이 컨텍스트에 남아 있을 때 발생.

**대처법:** **컨텍스트 가지치기(pruning)**와 **오플로딩(offloading)** 사용. 가지치기는 오래되거나 상충하는 정보를 새 정보 도착 시 제거하는 것이고, 오플로딩은 모델에 별도의 "스크래치패드" 작업 공간을 제공해 주 컨텍스트를 혼란스럽게 하지 않고 정보를 처리하게 합니다.

**여행 예약 예시:** 처음에 "이코노미 클래스로 비행해 주세요."라고 말한 뒤 대화 중 "이번 여행은 비즈니스 클래스로 하자."라고 변경하면 두 정보가 모두 컨텍스트에 남아 모순이 발생해 검색 결과가 혼란스러워질 수 있습니다.

**해결책:** **컨텍스트 가지치기**를 구현해 새 지침이 기존 지침과 상충하면 오래된 것을 제거하거나 명시적으로 덮어씁니다. 또는 에이전트가 **스크래치패드**를 사용하여 상충하는 선호도를 조정 후 결정하게 해 최종 일관된 지침만 행동에 반영하도록 합니다.

## 컨텍스트 엔지니어링에 대해 더 궁금한가요?

다른 학습자들과 만나고 오피스 아워에 참석하며 AI 에이전트 관련 질문을 할 수 있는 [Microsoft Foundry Discord](https://aka.ms/ai-agents/discord)에 참여하세요.

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**면책 조항**:  
이 문서는 AI 번역 서비스 [Co-op Translator](https://github.com/Azure/co-op-translator)를 사용하여 번역되었습니다. 정확성을 위해 노력하고 있으나 자동 번역에는 오류나 부정확한 부분이 있을 수 있음을 유의해 주시기 바랍니다. 원문 문서는 해당 언어의 권위 있는 자료로 간주되어야 합니다. 중요한 정보의 경우 전문 인간 번역을 권장합니다. 이 번역본 사용으로 인한 오해나 잘못된 해석에 대해 당사는 책임을 지지 않습니다.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->