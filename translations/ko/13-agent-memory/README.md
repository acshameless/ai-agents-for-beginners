# AI 에이전트를 위한 메모리  
[![Agent Memory](../../../translated_images/ko/lesson-13-thumbnail.959e3bc52d210c64.webp)](https://youtu.be/QrYbHesIxpw?si=qNYW6PL3fb3lTPMk)

AI 에이전트를 만드는 고유한 이점을 논할 때 주로 두 가지가 논의됩니다: 작업을 완료하기 위한 도구를 호출하는 능력과 시간이 지남에 따라 개선하는 능력입니다. 메모리는 사용자에게 더 나은 경험을 제공할 수 있는 자기 개선 에이전트를 만드는 기초에 있습니다.

이번 강의에서는 AI 에이전트에서 메모리가 무엇인지, 그리고 이를 관리하고 애플리케이션의 이익을 위해 사용하는 방법을 살펴보겠습니다.

## 소개

이번 강의에서 다룰 내용은 다음과 같습니다:

• **AI 에이전트 메모리 이해하기**: 메모리가 무엇이며 에이전트에 중요한 이유

• **메모리 구현 및 저장**: AI 에이전트에 메모리 기능을 추가하는 실질적인 방법, 단기 및 장기 메모리에 중점

• **AI 에이전트 자기 개선 만들기**: 메모리가 에이전트가 과거 상호작용에서 학습하고 시간이 지나면서 개선하는 방법

## 사용 가능한 구현들

이번 강의에는 두 개의 종합적인 노트북 튜토리얼이 포함되어 있습니다:

• **[13-agent-memory.ipynb](./13-agent-memory.ipynb)**: Mem0와 Azure AI Search를 사용하고 Semantic Kernel 프레임워크로 메모리 구현

• **[13-agent-memory-cognee.ipynb](./13-agent-memory-cognee.ipynb)**: Cognee를 활용해 내장 임베딩으로 지원되는 지식 그래프를 자동으로 구축, 그래프 시각화 및 지능형 검색으로 구조화된 메모리 구현

## 학습 목표

이번 강의를 완료하면 다음을 알게 됩니다:

• **작동 메모리, 단기 및 장기 메모리, 그리고 페르소나 및 에피소드 메모리 같은 특수 형태를 포함한 다양한 AI 에이전트 메모리 유형을 구분하는 방법**

• **Semantic Kernel 프레임워크를 사용하여 Mem0, Cognee, Whiteboard 메모리 같은 도구 및 Azure AI Search 통합을 활용해 AI 에이전트를 위한 단기 및 장기 메모리를 구현하고 관리하는 방법**

• **자기 개선 AI 에이전트 원리를 이해하고 견고한 메모리 관리 시스템이 지속적 학습과 적응에 어떻게 기여하는지**

## AI 에이전트 메모리 이해하기

본질적으로, **AI 에이전트의 메모리는 정보를 유지하고 되찾을 수 있게 해주는 메커니즘을 의미합니다**. 이 정보는 대화에 관한 구체적인 세부사항, 사용자 선호, 과거 행동, 심지어 학습된 패턴일 수 있습니다.

메모리가 없다면 AI 애플리케이션은 종종 상태 비저장(stateless)으로, 각 상호작용이 새로 시작됩니다. 이는 에이전트가 이전 맥락이나 선호를 "잊는" 반복적이고 답답한 사용자 경험을 초래합니다.

### 메모리가 중요한 이유

에이전트의 지능은 과거 정보를 기억하고 활용하는 능력과 깊이 연결되어 있습니다. 메모리는 에이전트를 다음과 같이 만듭니다:

• **반성적**: 과거 행동과 결과에서 학습

• **상호작용적**: 진행 중인 대화에서 맥락 유지

• **선제적 및 반응적**: 과거 데이터를 토대로 요구를 예측하거나 적절히 대응

• **자율적**: 저장된 지식을 활용해 더 독립적으로 작동

메모리를 구현하는 목표는 에이전트를 더 **신뢰할 수 있고 유능하게** 만드는 것입니다.

### 메모리 유형

#### 작동 메모리

작업 도중 에이전트가 사용하는 임시 메모리라고 생각하세요. 현재 진행 중인 단일 작업이나 사고 과정에서 다음 단계를 처리하는 데 필요한 즉각적인 정보를 담습니다.

AI 에이전트에게 작동 메모리는 긴 또는 잘린 전체 채팅 기록 중에서도 대화에서 가장 관련성 높은 정보를 자주 포착합니다. 요구사항, 제안, 결정, 행동 같은 핵심 요소를 추출하는 데 집중합니다.

**작동 메모리 예시**

여행 예약 에이전트의 경우, 작동 메모리는 "파리 여행 예약을 원해요" 같은 현재 사용자의 요구를 포착하여 즉각적인 대화 맥락을 안내하는 데 활용됩니다.

#### 단기 메모리

단기 메모리는 단일 대화 또는 세션 동안 정보를 유지합니다. 현재 대화의 맥락으로, 에이전트가 이전 대화 턴을 다시 참조할 수 있도록 합니다.

**단기 메모리 예시**

사용자가 "파리행 비행기 비용이 얼마인가요?"라고 물은 뒤 "거기 숙박은요?"라고 질문하면, 단기 메모리가 에이전트가 같은 대화 내에서 "거기"가 "파리"를 의미한다는 것을 알게 합니다.

#### 장기 메모리

여러 대화 또는 세션을 거쳐 지속되는 정보를 뜻합니다. 사용자 선호나 과거 상호작용, 일반 지식을 장기적으로 기억할 수 있게 하며, 이는 개인화에 중요합니다.

**장기 메모리 예시**

장기 메모리는 "벤은 스키와 야외 활동을 좋아하고, 산 전망에 커피를 즐기며, 이전 부상으로 인해 고급 스키 슬로프를 피하고 싶어 한다"는 정보를 저장합니다. 이는 미래 여행 계획 세션에서 맞춤 추천에 영향을 미칩니다.

#### 페르소나 메모리

이 특수 메모리 유형은 에이전트의 일관된 “성격”이나 “페르소나”를 발전시키는 데 도움을 줍니다. 에이전트가 자신이나 맡은 역할에 관한 세부사항을 기억하게 하여 상호작용을 더 자연스럽고 집중되게 합니다.

**페르소나 메모리 예시**

여행 에이전트가 "스키 전문가 플래너"로 설계되었다면, 페르소나 메모리가 이 역할을 강화해 전문가다운 어조와 지식으로 응답하도록 영향을 줍니다.

#### 워크플로우/에피소드 메모리

이 메모리는 에이전트가 복잡한 작업 중 거치는 단계들을 저장하며 성공과 실패도 포함합니다. 과거의 특정 “에피소드”나 경험을 기억해 학습하는 것과 같습니다.

**에피소드 메모리 예시**

에이전트가 특정 비행기 예약을 시도했으나 좌석이 없어서 실패하면, 에피소드 메모리가 이 실패를 기록해 이후 시도 시 대안을 찾거나 사용자에게 더 정확히 알리는 데 활용됩니다.

#### 엔티티 메모리

대화에서 특정 엔티티(사람, 장소, 사물)와 사건을 추출해 기억하는 것입니다. 에이전트가 논의된 주요 요소들의 구조화된 이해를 구축할 수 있도록 합니다.

**엔티티 메모리 예시**

과거 여행에 관한 대화에서 "파리", "에펠탑", "르 샤 누아르 레스토랑에서의 저녁" 같은 엔티티를 추출할 수 있습니다. 미래 대화에서 "르 샤 누아르"를 기억해 새 예약을 제안할 수도 있습니다.

#### 구조화된 RAG (Retrieval Augmented Generation)

RAG가 보다 넓은 기술이지만, "구조화된 RAG"는 강력한 메모리 기술로 강조됩니다. 대화, 이메일, 이미지 등 다양한 출처에서 밀도 있고 구조화된 정보를 추출하여 반응의 정확성과 재현성을 높입니다. 전통적인 의미 유사도에만 의존하는 고전적 RAG와 달리, 구조화된 RAG는 정보 고유의 구조를 활용합니다.

**구조화된 RAG 예시**

키워드 일치만 하는 대신, 이메일에서 비행기 정보(목적지, 날짜, 시간, 항공사)를 파싱하여 구조화된 방식으로 저장할 수 있습니다. 그래서 "화요일에 파리행으로 예약한 비행기는 무엇인가요?" 같은 정확한 쿼리가 가능합니다.

## 메모리 구현 및 저장

AI 에이전트 메모리 구현은 메모리 생성, 저장, 검색, 통합, 업데이트, 심지어 "잊기"(또는 삭제) 등 **체계적인 메모리 관리** 프로세스를 포함합니다. 이 중에서도 검색이 특히 중요합니다.

### 특수화된 메모리 도구들

#### Mem0

에이전트 메모리를 저장하고 관리하는 한 가지 방법은 Mem0 같은 특수 도구를 사용하는 것입니다. Mem0는 지속적인 메모리 계층으로 작용해 에이전트가 관련 상호작용을 기억하고 사용자 선호 및 사실적 맥락을 저장하며, 성공과 실패에서 학습하도록 돕습니다. 이를 통해 상태 비저장(stateless) 에이전트를 상태 저장(stateful)으로 전환합니다.

Mem0는 **두 단계 메모리 파이프라인: 추출과 업데이트**를 통해 작동합니다. 먼저, 에이전트가 대화에 추가한 메시지가 Mem0 서비스로 전송되며, LLM(대형 언어 모델)을 사용해 대화 기록을 요약하고 새 메모리를 추출합니다. 이어서 LLM 기반 업데이트 단계에서 이 메모리를 추가, 수정, 삭제 여부를 판단하여 백터, 그래프, 키-값 데이터베이스를 포함하는 하이브리드 저장소에 저장합니다. 이 시스템은 다양한 메모리 유형과 엔티티 관계 관리를 위한 그래프 메모리도 지원합니다.

#### Cognee

또 다른 강력한 방법은 Cognee라는 오픈소스 의미 메모리를 사용하는 것입니다. Cognee는 구조화된 데이터와 비구조화 데이터를 임베딩에 기반한 쿼리 가능한 지식 그래프로 변환합니다. Cognee는 벡터 유사도 검색과 그래프 관계를 결합하는 **이중 저장소 아키텍처**를 제공해, 단순히 정보가 유사한지를 넘어 개념들이 어떻게 관련되는지를 이해하도록 합니다.

Cognee는 벡터 유사도, 그래프 구조, LLM 추론을 혼합하는 **하이브리드 검색**에 뛰어나며, 단순 분할 검색부터 그래프 인지 질문 응답에 이르기까지 지원합니다. 시스템은 진화하며 성장하는 **생활형 메모리**를 유지하고, 단기 세션 맥락과 장기 지속 메모리 모두를 지원하는 하나의 연결된 그래프로 쿼리 가능합니다.

Cognee 노트북 튜토리얼([13-agent-memory-cognee.ipynb](./13-agent-memory-cognee.ipynb))은 다양한 데이터 소스 수집, 지식 그래프 시각화, 특정 에이전트 요구에 맞춘 다양한 검색 전략 쿼리를 실습 예제로 보여줍니다.

### RAG를 이용한 메모리 저장

Mem0 같은 특수 메모리 도구 외에도, **Azure AI Search와 같은 강력한 검색 서비스를 메모리 저장 및 검색 백엔드로 활용할 수 있으며**, 특히 구조화된 RAG에 적합합니다.

이를 통해 에이전트의 응답이 자체 데이터에 근거를 두어 보다 관련성 높고 정확한 답변을 제공합니다. Azure AI Search는 사용자별 여행 메모리, 제품 카탈로그 또는 기타 특정 도메인 지식을 저장하는 데 활용 가능합니다.

Azure AI Search는 **Structured RAG** 능력을 지원해 대화 기록, 이메일, 이미지 같은 방대한 데이터셋에서 밀도 높은 구조화된 정보를 추출하고 검색하는 데 탁월합니다. 이는 전통적 텍스트 청크 분할과 임베딩 방식에 비해 "초인적 정확도와 재현율"을 제공합니다.

## AI 에이전트가 자기 개선하도록 만들기

자기 개선 에이전트의 일반적인 패턴은 **"지식 에이전트"**를 도입하는 것입니다. 이 별도의 에이전트는 사용자와 메인 에이전트 사이의 대화를 관찰하며 다음 역할을 수행합니다:

1. **가치 있는 정보 확인**: 대화 중 어느 부분이 일반적 지식이나 특정 사용자 선호로 저장될 가치가 있는지 판단

2. **추출 및 요약**: 대화에서 본질적인 학습 내용이나 선호를 추출하고 요약

3. **지식 베이스에 저장**: 추출한 정보를 벡터 데이터베이스에 저장해 나중에 검색 가능하게 함

4. **미래 쿼리 보강**: 사용자가 새 쿼리를 시작할 때, 지식 에이전트가 관련 저장 정보를 끌어와 사용자 프롬프트에 덧붙여 메인 에이전트에 중요한 맥락을 제공 (RAG와 유사)

### 메모리 최적화

• **지연 시간 관리**: 사용자 상호작용 속도 저하를 방지하기 위해, 처음에는 더 저렴하고 빠른 모델을 사용해 정보 저장이나 검색의 가치 여부를 신속히 판단하고, 필요 시에만 복잡한 추출/검색 프로세스를 호출

• **지식 베이스 유지 관리**: 지식 베이스가 커질수록 덜 자주 사용되는 정보는 비용 관리를 위해 "콜드 스토리지"로 이동 가능

## 에이전트 메모리에 관해 더 궁금한 점이 있나요?

[Microsoft Foundry Discord](https://aka.ms/ai-agents/discord)에 참여해 다른 학습자들과 만나고, 오피스 아워에 참석하며, AI 에이전트 관련 질문에 답변을 받아보세요.

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**면책 조항**:  
이 문서는 AI 번역 서비스 [Co-op Translator](https://github.com/Azure/co-op-translator)를 사용하여 번역되었습니다. 정확성을 위해 최선을 다하고 있으나, 자동 번역은 오류나 부정확한 부분이 있을 수 있음을 알려드립니다. 원본 문서는 해당 원어로 작성된 문서를 권위 있는 출처로 간주해야 합니다. 중요한 정보의 경우, 전문적인 인간 번역을 권장합니다. 본 번역 사용으로 인해 발생하는 오해나 오인에 대해 당사는 책임을 지지 않습니다.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->