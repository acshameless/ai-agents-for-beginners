[![Мультиагентный дизайн](../../../translated_images/ru/lesson-9-thumbnail.38059e8af1a5b71d.webp)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(Нажмите на изображение выше, чтобы посмотреть видео этого урока)_
# Метапознание в агентах ИИ

## Введение

Добро пожаловать на урок по метапознанию в агентах ИИ! Эта глава предназначена для начинающих, которые интересуются тем, как агенты ИИ могут рассуждать о собственных мыслительных процессах. К концу этого урока вы поймёте ключевые концепции и получите практические примеры для применения метапознания при проектировании агентов ИИ.

## Цели обучения

После завершения этого урока вы сможете:

1. Понимать последствия циклов рассуждения в определениях агентов.
2. Использовать методы планирования и оценки, чтобы помогать агентам самокорректироваться.
3. Создавать собственных агентов, способных манипулировать кодом для выполнения задач.

## Введение в метапознание

Метапознание относится к высшим когнитивным процессам, которые включают размышления о собственных мыслительных процессах. Для агентов ИИ это означает способность оценивать и корректировать свои действия на основе самосознания и прошлого опыта. Метапознание, или «мышление о мышлении», — важная концепция при разработке агентных систем ИИ. Это подразумевает, что системы ИИ осознают свои внутренние процессы и могут контролировать, регулировать и адаптировать своё поведение соответствующим образом. Подобно тому, как мы оцениваем обстановку или анализируем задачу. Это самосознание может помочь системам ИИ принимать более взвешенные решения, выявлять ошибки и улучшать свою работу со временем — снова возвращаясь к тесту Тьюринга и дебатам о том, захватит ли ИИ мир.

В контексте агентных систем ИИ метапознание может помочь решить несколько задач, таких как:
- Прозрачность: Обеспечение возможности объяснить рассуждения и решения системы ИИ.
- Рассуждение: Повышение способности систем ИИ синтезировать информацию и принимать обоснованные решения.
- Адаптация: Позволяет системам ИИ приспосабливаться к новым средам и изменяющимся условиям.
- Восприятие: Улучшение точности распознавания и интерпретации данных из окружения системы ИИ.

### Что такое метапознание?

Метапознание, или «мышление о мышлении», — это высший когнитивный процесс, включающий самосознание и саморегулирование собственных когнитивных процессов. В области ИИ метапознание даёт агентам возможность оценивать и адаптировать свои стратегии и действия, что приводит к улучшению решения задач и принятия решений. Поняв метапознание, вы сможете проектировать агентов ИИ, которые будут не только умнее, но и более адаптируемыми и эффективными. В подлинном метапознании вы увидите, что ИИ явно рассуждает о собственных рассуждениях.

Пример: «Я отдал приоритет более дешёвым рейсам, потому что… Возможно, я упускаю прямые рейсы, поэтому мне стоит перепроверить.»
Отслеживание того, как или почему он выбрал определённый маршрут.
- Замечание, что он совершал ошибки из-за чрезмерного опирания на пользовательские предпочтения с предыдущего раза, поэтому он изменяет свою стратегию принятия решений, а не только окончательную рекомендацию.
- Диагностика закономерностей, например: «Когда пользователь упоминает «слишком многолюдно», мне следует не только исключать определённые достопримечательности, но и задуматься о том, что мой метод отбора «топ-достопримечательностей» ошибочен, если я всегда ранжирую по популярности.»

### Важность метапознания в агентах ИИ

![Важность метапознания](../../../translated_images/ru/importance-of-metacognition.b381afe9aae352f7.webp)

- Саморефлексия: Агенты могут оценивать собственную производительность и выявлять области для улучшения.
- Адаптивность: Агенты могут изменять стратегии на основе прошлых опытов и меняющихся условий.
- Исправление ошибок: Агенты могут автоматически обнаруживать и исправлять ошибки, что приводит к более точным результатам.
- Управление ресурсами: Агенты могут оптимизировать использование ресурсов, таких как время и вычислительная мощность, путём планирования и оценки своих действий.

## Компоненты агента ИИ

Прежде чем погружаться в метапознавательные процессы, важно понять базовые компоненты агента ИИ. Аgent ИИ обычно состоит из:

- Persona: Личность и характеристики агента, которые определяют, как он взаимодействует с пользователями.
- Tools: Возможности и функции, которые агент может выполнять.
- Skills: Знания и экспертиза, которыми обладает агент.

Эти компоненты работают вместе, создавая «единицу экспертизы», способную выполнять конкретные задачи.

**Пример**:
Рассмотрим туристического агента — сервис, который не только планирует ваш отпуск, но и корректирует маршрут на основе данных в реальном времени и прошлых впечатлений клиентов.

### Пример: метапознание в сервисе туристического агента

Представьте, что вы проектируете сервис туристического агента на базе ИИ. Этот агент, «Туристический агент», помогает пользователям планировать их отпуска. Чтобы внедрить метапознание, Туристическому агенту необходимо оценивать и корректировать свои действия на основе самосознания и прошлого опыта. Вот как метапознание может играть роль:

#### Текущая задача

Текущая задача — помочь пользователю спланировать поездку в Париж.

#### Шаги для выполнения задачи

1. **Сбор предпочтений пользователя**: Спросите у пользователя даты поездки, бюджет, интересы (например, музеи, кухня, шопинг) и любые особые требования.
2. **Получение информации**: Поиск вариантов перелёта, проживания, достопримечательностей и ресторанов, соответствующих предпочтениям пользователя.
3. **Генерация рекомендаций**: Предоставьте персонализированный маршрут с деталями по рейсам, бронированию отеля и предлагаемыми активностями.
4. **Корректировка на основе обратной связи**: Спросите пользователя об обратной связи по рекомендациям и внесите необходимые изменения.

#### Необходимые ресурсы

- Доступ к базам данных бронирования рейсов и отелей.
- Информация о парижских достопримечательностях и ресторанах.
- Данные обратной связи пользователей из предыдущих взаимодействий.

#### Опыт и саморефлексия

Туристический агент использует метапознание для оценки своей работы и обучения на прошлом опыте. Например:

1. **Анализ обратной связи пользователей**: Туристический агент просматривает отзывы пользователей, чтобы определить, какие рекомендации были приняты хорошо, а какие — нет. Он корректирует свои будущие предложения соответственно.
2. **Адаптивность**: Если пользователь ранее упоминал, что не любит многолюдные места, Туристический агент будет избегать рекомендаций популярных туристических мест в часы пик в будущем.
3. **Исправление ошибок**: Если Туристический агент сделал ошибку при прошлой броне, например предложил отель, который был полностью забронирован, он учится более тщательно проверять доступность перед тем, как делать рекомендации.

#### Практический пример для разработчиков

Ниже упрощённый пример того, как может выглядеть код Туристического агента при включении метапознания:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # Поиск авиарейсов, отелей и достопримечательностей на основе предпочтений
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # Анализ обратной связи и корректировка будущих рекомендаций
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Пример использования
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### Почему метапознание важно

- **Саморефлексия**: Агенты могут анализировать свою работу и выявлять области для улучшения.
- **Адаптивность**: Агенты могут изменять стратегии на основе обратной связи и меняющихся условий.
- **Исправление ошибок**: Агенты могут автономно обнаруживать и исправлять ошибки.
- **Управление ресурсами**: Агенты могут оптимизировать использование ресурсов, таких как время и вычислительная мощность.

Внедряя метапознание, Туристический агент сможет предоставлять более персонализированные и точные рекомендации по путешествиям, улучшая общий опыт пользователя.

---

## 2. Планирование в агентах

Планирование является критическим компонентом поведения агента ИИ. Оно включает в себя описание шагов, необходимых для достижения цели, с учётом текущего состояния, ресурсов и возможных препятствий.

### Элементы планирования

- **Текущая задача**: Чётко определить задачу.
- **Шаги для выполнения задачи**: Разбить задачу на управляемые шаги.
- **Необходимые ресурсы**: Определить необходимые ресурсы.
- **Опыт**: Использовать прошлый опыт для информирования планирования.

**Пример**:
Ниже приведены шаги, которые Туристическому агенту нужно выполнить, чтобы эффективно помочь пользователю спланировать поездку:

### Шаги для туристического агента

1. **Сбор предпочтений пользователя**
   - Спросите у пользователя подробности о датах поездки, бюджете, интересах и любых особых требованиях.
   - Примеры: "Когда вы планируете путешествовать?" "Какой у вас диапазон бюджета?" "Какими занятиями вы любите заниматься во время отпуска?"

2. **Получение информации**
   - Поиск релевантных вариантов путешествия на основе предпочтений пользователя.
   - **Рейсы**: Поиск доступных рейсов в рамках бюджета пользователя и предпочтительных дат.
   - **Проживание**: Поиск отелей или аренды жилья, соответствующих предпочтениям пользователя по расположению, цене и удобствам.
   - **Достопримечательности и рестораны**: Выявление популярных достопримечательностей, активностей и заведений, соответствующих интересам пользователя.

3. **Генерация рекомендаций**
   - Скомпилируйте найденную информацию в персонализированный маршрут.
   - Предоставьте детали, такие как варианты рейсов, бронирования отеля и предлагаемые активности, адаптируя рекомендации под предпочтения пользователя.

4. **Представление маршрута пользователю**
   - Поделитесь предложенным маршрутом с пользователем для его рассмотрения.
   - Пример: "Вот предложенный маршрут для вашей поездки в Париж. Он включает данные по рейсам, бронированиям отеля и список рекомендуемых активностей и ресторанов. Дайте знать, что вы думаете!"

5. **Сбор обратной связи**
   - Спросите у пользователя мнение о предложенном маршруте.
   - Примеры: "Вам подходят варианты перелётов?" "Отель соответствует вашим требованиям?" "Есть ли активности, которые вы хотели бы добавить или убрать?"

6. **Корректировка на основе обратной связи**
   - Измените маршрут на основе отзывов пользователя.
   - Внесите необходимые изменения в рекомендации по перелёту, проживанию и активностям, чтобы лучше соответствовать предпочтениям пользователя.

7. **Окончательное подтверждение**
   - Представьте обновлённый маршрут пользователю для окончательного подтверждения.
   - Пример: "Я внес изменения на основе вашей обратной связи. Вот обновлённый маршрут. Всё ли вас устраивает?"

8. **Бронирование и подтверждение резервирований**
   - После одобрения маршрута пользователем приступайте к бронированию рейсов, проживания и заранее запланированных активностей.
   - Отправьте пользователю подтверждающие данные.

9. **Предоставление постоянной поддержки**
   - Оставайтесь доступными для помощи пользователю при любых изменениях или дополнительных запросах до и во время поездки.
   - Пример: "Если вам потребуется дополнительная помощь во время поездки, обращайтесь в любое время!"

### Пример взаимодействия

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Пример использования в запросе на освистывание
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. Система Corrective RAG

Сначала давайте разберёмся в различии между инструментом RAG и Предварительной загрузкой контекста (Pre-emptive Context Load)

![RAG против загрузки контекста](../../../translated_images/ru/rag-vs-context.9eae588520c00921.webp)

### Retrieval-Augmented Generation (RAG)

RAG объединяет систему извлечения с генеративной моделью. Когда поступает запрос, система извлечения получает релевантные документы или данные из внешнего источника, и эта извлечённая информация используется для дополнения входных данных генеративной модели. Это помогает модели генерировать более точные и контекстно релевантные ответы.

В RAG-системе агент извлекает релевантную информацию из базы знаний и использует её для генерации соответствующих ответов или действий.

### Корректирующий подход RAG

Корректирующий подход RAG фокусируется на использовании техник RAG для исправления ошибок и повышения точности агентов ИИ. Это включает в себя:

1. **Технику подсказок**: Использование специальных подсказок для направления агента при извлечении релевантной информации.
2. **Инструмент**: Реализация алгоритмов и механизмов, которые позволяют агенту оценивать релевантность извлечённой информации и генерировать точные ответы.
3. **Оценку**: Непрерывную оценку производительности агента и внесение корректировок для повышения точности и эффективности.

#### Пример: Corrective RAG в поисковом агенте

Рассмотрим поискового агента, который извлекает информацию из веба для ответа на запросы пользователей. Корректирующий подход RAG может включать:

1. **Технику подсказок**: Формулирование поисковых запросов на основе ввода пользователя.
2. **Инструмент**: Использование методов обработки естественного языка и алгоритмов машинного обучения для ранжирования и фильтрации результатов поиска.
3. **Оценку**: Анализ обратной связи пользователей для выявления и исправления неточностей в извлечённой информации.

### Corrective RAG в Туристическом агенте

Corrective RAG (Retrieval-Augmented Generation) повышает способность ИИ извлекать и генерировать информацию с одновременным исправлением неточностей. Посмотрим, как Туристический агент может использовать подход Corrective RAG для предоставления более точных и релевантных рекомендаций по путешествиям.

Это включает в себя:

- **Технику подсказок:** Использование определённых подсказок для направления агента при извлечении релевантной информации.
- **Инструмент:** Реализация алгоритмов и механизмов, позволяющих агенту оценивать релевантность извлечённой информации и генерировать точные ответы.
- **Оценку:** Непрерывную оценку работы агента и внесение корректировок для повышения точности и эффективности.

#### Шаги для внедрения Corrective RAG в Туристическом агенте

1. **Первичное взаимодействие с пользователем**
   - Туристический агент собирает первоначальные предпочтения пользователя, такие как направление, даты поездки, бюджет и интересы.
   - Пример:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **Извлечение информации**
   - Туристический агент извлекает информацию о рейсах, проживании, достопримечательностях и ресторанах на основе предпочтений пользователя.
   - Пример:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **Генерация первоначальных рекомендаций**
   - Туристический агент использует извлечённую информацию для создания персонализированного маршрута.
   - Пример:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **Сбор обратной связи пользователя**
   - Туристический агент спрашивает пользователя о мнении по первоначальным рекомендациям.
   - Пример:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **Процесс Corrective RAG**
   - **Техника подсказок**: Туристический агент формулирует новые поисковые запросы на основе обратной связи пользователя.
     - Пример:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **Инструмент**: Туристический агент использует алгоритмы для ранжирования и фильтрации новых результатов поиска, уделяя внимание релевантности на основе обратной связи пользователя.
     - Пример:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **Оценка**: Туристический агент непрерывно оценивает релевантность и точность своих рекомендаций, анализируя обратную связь пользователя и внося необходимые корректировки.
     - Пример:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### Практический пример

Ниже упрощённый пример на Python, включающий подход Corrective RAG в Туристическом агенте:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# Пример использования
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### Предварительная загрузка контекста
Предварительная загрузка контекста включает загрузку релевантной информации или справочного материала в модель до обработки запроса. Это означает, что модель имеет доступ к этой информации с самого начала, что может помочь ей генерировать более обоснованные ответы без необходимости запрашивать дополнительные данные во время процесса.

Вот упрощённый пример того, как может выглядеть предварительная загрузка контекста для приложения туристического агента на Python:

```python
class TravelAgent:
    def __init__(self):
        # Предварительно загрузить популярные направления и их информацию
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # Получить информацию о направлении из предварительно загруженного контекста
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# Пример использования
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### Объяснение

1. **Инициализация (`__init__` method)**: Класс `TravelAgent` предварительно загружает словарь, содержащий информацию о популярных направлениях, таких как Paris, Tokyo, New York и Sydney. Этот словарь включает детали, такие как страна, валюта, язык и основные достопримечательности для каждого направления.

2. **Получение информации (`get_destination_info` method)**: Когда пользователь спрашивает о конкретном направлении, метод `get_destination_info` извлекает соответствующую информацию из предварительно загруженного словаря контекста.

Предварительно загрузив контекст, приложение туристического агента может быстро отвечать на запросы пользователей, не требуя получения этой информации из внешнего источника в реальном времени. Это делает приложение более эффективным и отзывчивым.

### Инициализация плана с целью перед итерацией

Инициализация плана с целью предполагает начало с чётко определённой задачи или желаемого результата. Определив эту цель заранее, модель может использовать её как руководящий принцип в ходе итеративного процесса. Это помогает гарантировать, что каждая итерация приближает к достижению нужного результата, делая процесс более эффективным и сфокусированным.

Вот пример того, как можно инициализировать план путешествия с целью перед итерацией для туристического агента на Python:

### Сценарий

Туристический агент хочет спланировать индивидуальный отпуск для клиента. Цель — создать маршрут путешествия, который максимально повышает удовлетворённость клиента на основе его предпочтений и бюджета.

### Шаги

1. Определить предпочтения клиента и бюджет.
2. Инициализировать начальный план на основе этих предпочтений.
3. Итеративно уточнять план, оптимизируя его под удовлетворённость клиента.

#### Python Code

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# Пример использования
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### Объяснение к коду

1. **Инициализация (`__init__` method)**: Класс `TravelAgent` инициализируется списком потенциальных направлений, каждое из которых имеет атрибуты, такие как name, cost и activity type.

2. **Инициализация плана (`bootstrap_plan` method)**: Этот метод создаёт начальный план путешествия на основе предпочтений и бюджета клиента. Он проходит по списку направлений и добавляет их в план, если они соответствуют предпочтениям клиента и укладываются в бюджет.

3. **Сопоставление предпочтений (`match_preferences` method)**: Этот метод проверяет, соответствует ли направление предпочтениям клиента.

4. **Итерация плана (`iterate_plan` method)**: Этот метод уточняет начальный план, пытаясь заменить каждое направление в плане на более подходящее, учитывая предпочтения клиента и бюджетные ограничения.

5. **Расчёт стоимости (`calculate_cost` method)**: Этот метод рассчитывает общую стоимость текущего плана, включая потенциальное новое направление.

#### Пример использования

- **Начальный план**: Туристический агент создаёт начальный план на основе предпочтений клиента по sightseeing и бюджета $2000.
- **Уточнённый план**: Туристический агент итеративно улучшает план, оптимизируя его под предпочтения клиента и бюджет.

Инициализируя план с чёткой целью (например, максимизация удовлетворённости клиента) и итеративно уточняя его, туристический агент может создать индивидуальный и оптимизированный маршрут путешествия для клиента. Такой подход обеспечивает соответствие плана предпочтениям и бюджету клиента с самого начала и улучшает его с каждой итерацией.

### Использование LLM для повторной ранжировки и оценки

Большие языковые модели (LLM) могут использоваться для повторной ранжировки и оценки, оценивая релевантность и качество извлечённых документов или сгенерированных ответов. Вот как это работает:

**Извлечение:** На начальном этапе извлечения получается набор кандидатных документов или ответов на основе запроса.

**Повторная ранжировка:** LLM оценивает эти кандидаты и повторно ранжирует их на основе релевантности и качества. Этот шаг гарантирует, что наиболее релевантная и высококачественная информация отображается первой.

**Оценка:** LLM присваивает каждому кандидату оценки, отражающие их релевантность и качество. Это помогает выбрать лучший ответ или документ для пользователя.

Используя LLM для повторной ранжировки и оценки, система может предоставить более точную и контекстно релевантную информацию, улучшая общий пользовательский опыт.

Вот пример того, как туристический агент мог бы использовать большую языковую модель (LLM) для повторной ранжировки и оценки направлений путешествий на основе предпочтений пользователя на Python:

#### Сценарий — Путешествие на основе предпочтений

Туристический агент хочет рекомендовать лучшие направления путешествий клиенту на основе его предпочтений. LLM поможет повторно ранжировать и оценивать направления, чтобы обеспечить наиболее релевантные варианты.

#### Шаги:

1. Собрать предпочтения пользователя.
2. Получить список потенциальных направлений путешествий.
3. Использовать LLM для повторной ранжировки и оценки направлений на основе предпочтений пользователя.

Ниже показано, как можно обновить предыдущий пример для использования Azure OpenAI Services:

#### Требования

1. У вас должна быть подписка Azure.
2. Создайте ресурс Azure OpenAI и получите свой API-ключ.

#### Пример кода на Python

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Сгенерировать подсказку для Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # Определить заголовки и тело запроса
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # Вызвать API Azure OpenAI, чтобы получить повторно ранжированные и оценённые места назначения
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # Извлечь и вернуть рекомендации
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# Пример использования
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### Объяснение кода — Бронирование по предпочтениям

1. **Инициализация**: Класс `TravelAgent` инициализируется списком потенциальных направлений, каждое из которых имеет атрибуты, такие как name и description.

2. **Получение рекомендаций (`get_recommendations` method)**: Этот метод генерирует prompt для сервиса Azure OpenAI на основе предпочтений пользователя и выполняет HTTP POST-запрос к API Azure OpenAI, чтобы получить повторно ранжированные и оценённые направления.

3. **Генерация prompt (`generate_prompt` method)**: Этот метод формирует prompt для Azure OpenAI, включающий предпочтения пользователя и список направлений. Prompt направляет модель на повторную ранжировку и оценку направлений на основе предоставленных предпочтений.

4. **Вызов API**: Библиотека `requests` используется для выполнения HTTP POST-запроса к конечной точке API Azure OpenAI. В ответе содержатся повторно ранжированные и оценённые направления.

5. **Пример использования**: Туристический агент собирает предпочтения пользователя (например, интерес к sightseeing и разнообразной культуре) и использует сервис Azure OpenAI для получения повторно ранжированных и оценённых рекомендаций по направлениям путешествий.

Обязательно замените `your_azure_openai_api_key` на ваш фактический API-ключ Azure OpenAI и `https://your-endpoint.com/...` на фактический URL конечной точки вашего развертывания Azure OpenAI.

Используя LLM для повторной ранжировки и оценки, туристический агент может предоставлять более персонализированные и релевантные рекомендации по путешествиям клиентам, улучшая их общий опыт.

### RAG: техника подсказки против инструмента

Retrieval-Augmented Generation (RAG) может быть как техникой подсказки, так и инструментом в разработке AI-агентов. Понимание различия между ними поможет эффективнее использовать RAG в ваших проектах.

#### RAG как техника подсказки

**Что это такое?**

- Как техника подсказки, RAG предполагает формулирование конкретных запросов или подсказок для направленного извлечения релевантной информации из большого корпуса или базы данных. Эта информация затем используется для генерации ответов или действий.

**Как это работает:**

1. **Формулировка подсказок**: Создавайте хорошо структурированные подсказки или запросы на основе задачи или ввода пользователя.
2. **Извлечение информации**: Используйте подсказки для поиска релевантных данных в существующей базе знаний или наборе данных.
3. **Генерация ответа**: Комбинируйте извлечённую информацию с генеративными моделями ИИ, чтобы получить исчерпывающий и связный ответ.

**Пример в приложении туристического агента**:

- User Input: "I want to visit museums in Paris."
- Prompt: "Find top museums in Paris."
- Retrieved Information: Details about Louvre Museum, Musée d'Orsay, etc.
- Generated Response: "Here are some top museums in Paris: Louvre Museum, Musée d'Orsay, and Centre Pompidou."

#### RAG как инструмент

**Что это такое?**

- Как инструмент, RAG представляет собой интегрированную систему, которая автоматизирует процесс извлечения и генерации, облегчая разработчикам внедрение сложной функциональности ИИ без ручной разработки подсказок для каждого запроса.

**Как это работает:**

1. **Интеграция**: Встраивайте RAG в архитектуру AI-агента, позволяя ему автоматически обрабатывать задачи извлечения и генерации.
2. **Автоматизация**: Инструмент управляет всем процессом — от получения ввода пользователя до генерации финального ответа — без необходимости явных подсказок на каждом шаге.
3. **Эффективность**: Повышает производительность агента за счёт оптимизации процессов извлечения и генерации, обеспечивая более быстрые и точные ответы.

**Пример в приложении туристического агента**:

- User Input: "I want to visit museums in Paris."
- RAG Tool: Automatically retrieves information about museums and generates a response.
- Generated Response: "Here are some top museums in Paris: Louvre Museum, Musée d'Orsay, and Centre Pompidou."

### Сравнение

| Aspect                 | Prompting Technique                                        | Tool                                                  |
|------------------------|-------------------------------------------------------------|-------------------------------------------------------|
| **Manual vs Automatic**| Manual formulation of prompts for each query.               | Automated process for retrieval and generation.       |
| **Control**            | Offers more control over the retrieval process.             | Streamlines and automates the retrieval and generation.|
| **Flexibility**        | Allows for customized prompts based on specific needs.      | More efficient for large-scale implementations.       |
| **Complexity**         | Requires crafting and tweaking of prompts.                  | Easier to integrate within an AI agent's architecture. |

### Практические примеры

**Пример техники подсказки:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**Пример инструмента:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### Оценка релевантности

Оценка релевантности — важный аспект работы AI-агента. Она гарантирует, что информация, извлечённая и сгенерированная агентом, является уместной, точной и полезной для пользователя. Рассмотрим, как оценивать релевантность в AI-агентах, включая практические примеры и методы.

#### Ключевые понятия в оценке релевантности

1. **Осведомлённость о контексте**:
   - Агент должен понимать контекст запроса пользователя, чтобы извлечь и сгенерировать релевантную информацию.
   - Пример: Если пользователь спрашивает о "best restaurants in Paris", агент должен учитывать предпочтения пользователя, такие как тип кухни и бюджет.

2. **Точность**:
   - Предоставляемая агентом информация должна быть фактически корректной и актуальной.
   - Пример: Рекомендовать рестораны, которые в настоящее время открыты и имеют хорошие отзывы, а не устаревшие или закрытые варианты.

3. **Интенция пользователя**:
   - Агент должен выводить намерение пользователя за запросом, чтобы предоставить наиболее релевантную информацию.
   - Пример: Если пользователь просит "budget-friendly hotels", агент должен отдать приоритет доступным вариантам.

4. **Цикл обратной связи**:
   - Непрерывный сбор и анализ обратной связи от пользователей помогает агенту уточнять процесс оценки релевантности.
   - Пример: Включение оценок и отзывов пользователей по предыдущим рекомендациям для улучшения будущих ответов.

#### Практические методы оценки релевантности

1. **Оценка релевантности (Relevance Scoring)**:
   - Присваивайте каждому извлечённому элементу оценку релевантности на основе того, насколько хорошо он соответствует запросу и предпочтениям пользователя.
   - Пример:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **Фильтрация и ранжирование**:
   - Отфильтруйте нерелевантные элементы и ранжируйте оставшиеся на основе их оценок релевантности.
   - Пример:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # Вернуть 10 наиболее релевантных элементов
     ```

3. **Обработка естественного языка (NLP)**:
   - Используйте методы NLP для понимания запроса пользователя и извлечения релевантной информации.
   - Пример:

     ```python
     def process_query(query):
         # Используйте обработку естественного языка (NLP) для извлечения ключевой информации из запроса пользователя
         processed_query = nlp(query)
         return processed_query
     ```

4. **Интеграция обратной связи пользователей**:
   - Собирайте отзывы пользователей о предоставленных рекомендациях и используйте их для корректировки будущих оценок релевантности.
   - Пример:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### Пример: оценка релевантности в приложении туристического агента

Вот практический пример того, как Travel Agent может оценивать релевантность рекомендаций по путешествиям:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # Вернуть 10 наиболее релевантных элементов

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# Пример использования
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### Поиск с учётом намерения

Поиск с учётом намерения предполагает понимание и интерпретацию скрытой цели или задачи за запросом пользователя, чтобы извлечь и сгенерировать наиболее релевантную и полезную информацию. Такой подход выходит за рамки простого совпадения ключевых слов и фокусируется на понимании реальных потребностей и контекста пользователя.

#### Ключевые понятия в поиске с учётом намерения

1. **Понимание намерения пользователя**:
   - Намерение пользователя можно разделить на три основные категории: информационное, навигационное и транзакционное.
     - **Информационное намерение**: пользователь ищет информацию по теме (например, "What are the best museums in Paris?").
     - **Навигационное намерение**: пользователь хочет перейти на конкретный сайт или страницу (например, "Louvre Museum official website").
     - **Транзакционное намерение**: пользователь намеревается совершить действие, например забронировать рейс или сделать покупку (например, "Book a flight to Paris").

2. **Осведомлённость о контексте**:
   - Анализ контекста запроса пользователя помогает точно определить их намерение. Это включает в себя учёт предыдущих взаимодействий, предпочтений пользователя и конкретных деталей текущего запроса.

3. **Обработка естественного языка (NLP)**:
   - Методы NLP используются для понимания и интерпретации естественно-языковых запросов пользователей. Это включает задачи, такие как распознавание сущностей, анализ тональности и парсинг запросов.

4. **Персонализация**:
   - Персонализация результатов поиска на основе истории пользователя, предпочтений и обратной связи увеличивает релевантность извлечённой информации.

#### Практический пример: поиск с учётом намерения в приложении туристического агента

Возьмём Travel Agent в качестве примера, чтобы посмотреть, как можно реализовать поиск с учётом намерения.

1. **Сбор предпочтений пользователя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Понимание намерения пользователя**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **Осведомлённость о контексте**
   ```python
   def analyze_context(query, user_history):
       # Объедините текущий запрос с историей пользователя, чтобы понять контекст
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **Поиск и персонализация результатов**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # Пример логики поиска для информационного намерения
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # Пример логики поиска для навигационного намерения
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # Пример логики поиска для транзакционного намерения
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # Пример логики персонализации
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # Вернуть топ-10 персонализированных результатов
   ```

5. **Пример использования**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. Генерация кода как инструмента

Агенты, генерирующие код, используют модели ИИ для написания и выполнения кода, решая сложные задачи и автоматизируя процессы.

### Агенты, генерирующие код

Агенты, генерирующие код, используют генеративные модели ИИ для написания и выполнения кода. Эти агенты могут решать сложные задачи, автоматизировать процессы и предоставлять ценные инсайты, генерируя и выполняя код на различных языках программирования.

#### Практические применения

1. **Автоматическая генерация кода**: Генерация фрагментов кода для конкретных задач, таких как анализ данных, веб-скрапинг или машинное обучение.
2. **SQL как RAG**: Использование SQL-запросов для извлечения и обработки данных из баз данных.
3. **Решение задач**: Создание и выполнение кода для решения конкретных задач, таких как оптимизация алгоритмов или анализ данных.

#### Пример: агент, генерирующий код для анализа данных

Представьте, что вы разрабатываете агента, генерирующего код. Вот как это может работать:

1. **Задача**: Проанализировать набор данных для выявления тенденций и закономерностей.
2. **Шаги**:
   - Загрузить набор данных в инструмент анализа данных.
   - Сгенерировать SQL-запросы для фильтрации и агрегации данных.
   - Выполнить запросы и получить результаты.
   - Использовать результаты для создания визуализаций и выводов.
3. **Необходимые ресурсы**: Доступ к набору данных, инструменты анализа данных и возможности SQL.
4. **Опыт**: Использовать результаты прошлых анализов для повышения точности и релевантности будущих исследований.

### Пример: агент, генерирующий код для туристического агента

В этом примере мы спроектируем агента, генерирующего код, Travel Agent, чтобы помогать пользователям планировать поездки, генерируя и выполняя код. Этот агент может выполнять задачи, такие как получение вариантов путешествий, фильтрация результатов и составление маршрута с помощью генеративного ИИ.

#### Обзор агента, генерирующего код

1. **Сбор предпочтений пользователя**: Собирать ввод пользователя, такой как место назначения, даты поездки, бюджет и интересы.
2. **Генерация кода для получения данных**: Генерировать фрагменты кода для получения информации о рейсах, отелях и достопримечательностях.
3. **Выполнение сгенерированного кода**: Запуск сгенерированного кода для получения информации в реальном времени.
4. **Создание маршрута**: Компилировать полученные данные в персонализированный план путешествия.
5. **Корректировка на основе обратной связи**: Получать отзыв от пользователя и при необходимости генерировать код заново для уточнения результатов.

#### Пошаговая реализация

1. **Сбор предпочтений пользователя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генерация кода для получения данных**

   ```python
   def generate_code_to_fetch_data(preferences):
       # Пример: Сгенерировать код для поиска авиарейсов на основе предпочтений пользователя
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # Пример: Сгенерировать код для поиска отелей
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **Выполнение сгенерированного кода**

   ```python
   def execute_code(code):
       # Выполните сгенерированный код с помощью exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **Создание маршрута**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **Корректировка на основе обратной связи**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # Настроить предпочтения на основе отзывов пользователя
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # Перегенерировать и выполнить код с обновлёнными предпочтениями
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### Использование осведомленности об окружении и рассуждений

Учет схемы таблицы действительно может улучшить процесс генерации запросов, используя осведомленность об окружении и рассуждения.

Вот пример того, как это может быть реализовано:

1. **Понимание схемы**: Система поймет схему таблицы и будет использовать эту информацию для обоснования генерации запросов.
2. **Корректировка на основе обратной связи**: Система будет корректировать предпочтения пользователя на основе отзывов и рассуждать о том, какие поля в схеме необходимо обновить.
3. **Генерация и выполнение запросов**: Система будет генерировать и выполнять запросы для получения обновленных данных о рейсах и отелях на основе новых предпочтений.

Ниже приведен обновленный пример кода на Python, который включает эти концепции:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # Настроить предпочтения на основе отзывов пользователя
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # Вывод на основе схемы для корректировки других связанных предпочтений
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # Пользовательская логика для настройки предпочтений на основе схемы и отзывов
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # Сгенерировать код для получения данных о рейсах на основе обновлённых предпочтений
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # Сгенерировать код для получения данных об отелях на основе обновлённых предпочтений
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # Смоделировать выполнение кода и вернуть фиктивные данные
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # Сгенерировать маршрут на основе рейсов, отелей и достопримечательностей
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# Пример схемы
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# Пример использования
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# Перегенерировать и выполнить код с обновлёнными предпочтениями
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### Объяснение - Бронирование на основе обратной связи

1. **Осведомленность о схеме**: Словарь `schema` определяет, как предпочтения следует корректировать на основе обратной связи. Он включает поля, такие как `favorites` и `avoid`, с соответствующими настройками.
2. **Корректировка предпочтений (метод `adjust_based_on_feedback`)**: Этот метод корректирует предпочтения на основе отзывов пользователя и схемы.
3. **Корректировки на основе окружения (метод `adjust_based_on_environment`)**: Этот метод настраивает корректировки на основе схемы и отзывов.
4. **Генерация и выполнение запросов**: Система генерирует код для получения обновленных данных о рейсах и отелях на основе скорректированных предпочтений и симулирует выполнение этих запросов.
5. **Создание маршрута**: Система создает обновленный маршрут на основе новых данных о рейсах, отелях и достопримечательностях.

Сделав систему осознающей окружение и способной рассуждать на основе схемы, можно генерировать более точные и релевантные запросы, что приведет к лучшим рекомендациям по путешествиям и более персонализированному пользовательскому опыту.

### Использование SQL как техники Retrieval-Augmented Generation (RAG)

SQL (Structured Query Language) — мощный инструмент для взаимодействия с базами данных. В составе подхода Retrieval-Augmented Generation (RAG) SQL может извлекать релевантные данные из баз данных, чтобы информировать и генерировать ответы или действия в агентах ИИ. Давайте рассмотрим, как SQL может использоваться как техника RAG в контексте Travel Agent.

#### Ключевые концепции

1. **Взаимодействие с базой данных**:
   - SQL используется для выполнения запросов к базам данных, извлечения релевантной информации и обработки данных.
   - Пример: получение информации о рейсах, отелях и достопримечательностях из базы данных путешествий.
2. **Интеграция с RAG**:
   - SQL-запросы генерируются на основе ввода пользователя и предпочтений.
   - Извлеченные данные затем используются для генерации персонализированных рекомендаций или действий.
3. **Динамическая генерация запросов**:
   - Агент ИИ генерирует динамические SQL-запросы на основе контекста и потребностей пользователя.
   - Пример: настройка SQL-запросов для фильтрации результатов по бюджету, датам и интересам.

#### Применения

- **Автоматическая генерация кода**: Генерация фрагментов кода для конкретных задач.
- **SQL как RAG**: Использование SQL-запросов для обработки данных.
- **Решение задач**: Создание и выполнение кода для решения проблем.

**Пример**:
Агент анализа данных:

1. **Задача**: Проанализировать набор данных, чтобы найти тенденции.
2. **Шаги**:
   - Загрузить набор данных.
   - Сгенерировать SQL-запросы для фильтрации данных.
   - Выполнить запросы и получить результаты.
   - Создать визуализации и выводы.
3. **Ресурсы**: Доступ к набору данных, возможности SQL.
4. **Опыт**: Использовать прошлые результаты для улучшения будущих анализов.

#### Практический пример: использование SQL в туристическом агенте

1. **Сбор предпочтений пользователя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генерация SQL-запросов**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **Выполнение SQL-запросов**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **Создание рекомендаций**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### Примеры SQL-запросов

1. **Запрос рейсов**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **Запрос отелей**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **Запрос достопримечательностей**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

Используя SQL как часть техники Retrieval-Augmented Generation (RAG), агенты ИИ, такие как Travel Agent, могут динамически извлекать и использовать релевантные данные для предоставления точных и персонализированных рекомендаций.

### Пример метакогниции

Итак, чтобы продемонстрировать реализацию метакогниции, давайте создадим простого агента, который отражает свой процесс принятия решений при решении задачи. Для этого примера мы построим систему, где агент пытается оптимизировать выбор отеля, а затем оценивает свое собственное рассуждение и корректирует стратегию, когда делает ошибки или принимает неоптимальные решения.

Мы смоделируем это, используя базовый пример, в котором агент выбирает отели на основе комбинации цены и качества, но при этом он будет «рефлексировать» над своими решениями и соответственно корректироваться.

#### Как это иллюстрирует метакогницию:

1. **Первоначальное решение**: Агент выберет самый дешевый отель, не учитывая влияние качества.
2. **Рефлексия и оценка**: После первоначального выбора агент проверит, является ли отель «плохим» вариантом, используя отзывы пользователя. Если он обнаружит, что качество отеля было слишком низким, он проанализирует свое рассуждение.
3. **Корректировка стратегии**: Агент корректирует свою стратегию на основе рефлексии, переключаясь с «самого дешевого» на «наивысшее качество», тем самым улучшая процесс принятия решений в будущих итерациях.

Вот пример:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # Хранит ранее выбранные отели
        self.corrected_choices = []  # Хранит скорректированные выборы
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # Доступные стратегии

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # Предположим, у нас есть отзыв пользователя, который сообщает, был ли последний выбор удачным или нет
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # Корректировать стратегию, если предыдущий выбор был неудовлетворительным
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# Симулирует список отелей (цена и качество)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# Создает агента
agent = HotelRecommendationAgent()

# Шаг 1: Агент рекомендует отель, используя стратегию "самый дешевый"
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# Шаг 2: Агент обдумывает выбор и при необходимости корректирует стратегию
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# Шаг 3: Агент снова рекомендует, на этот раз используя скорректированную стратегию
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### Метакогнитивные способности агента

Ключевое здесь — способность агента:
- Оценивать свои предыдущие выборы и процесс принятия решений.
- Корректировать свою стратегию на основе этой рефлексии, т.е. демонстрировать метакогницию на практике.

Это простая форма метакогниции, где система способна корректировать свой процесс рассуждения на основе внутренней обратной связи.

### Заключение

Метакогниция — мощный инструмент, который может значительно расширить возможности агентов ИИ. Включая метакогнитивные процессы, вы можете проектировать агентов более интеллектуальными, адаптивными и эффективными. Воспользуйтесь дополнительными ресурсами, чтобы дальше исследовать увлекательный мир метакогниции в агентах ИИ.

### Есть дополнительные вопросы по шаблону проектирования метакогниции?

Присоединяйтесь к [Microsoft Foundry Discord](https://aka.ms/ai-agents/discord), чтобы встретиться с другими учащимися, посетить часы приёма и получить ответы на ваши вопросы об агентах ИИ.

## Предыдущий урок

[Шаблон проектирования нескольких агентов](../08-multi-agent/README.md)

## Следующий урок

[Агенты ИИ в производстве](../10-ai-agents-production/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
Отказ от ответственности:
Этот документ был переведён с помощью сервиса машинного перевода на основе ИИ [Co-op Translator](https://github.com/Azure/co-op-translator). Несмотря на наши усилия по обеспечению точности, имейте в виду, что автоматические переводы могут содержать ошибки или неточности. Оригинальный документ на его исходном языке следует считать авторитетным источником. Для критически важной информации рекомендуется профессиональный перевод, выполненный человеком. Мы не несем ответственности за любые недоразумения или неправильные толкования, возникшие в результате использования этого перевода.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->