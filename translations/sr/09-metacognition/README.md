[![Дизајн вишеструких агената](../../../translated_images/sr/lesson-9-thumbnail.38059e8af1a5b71d.webp)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(Кликните на слику изнад да бисте погледали видео о овој лекцији)_
# Метакогниција код AI агената

## Увод

Добродошли на лекцију о метакогницији код AI агената! Ово поглавље је намењено почетницима који желе да сазнају како AI агенти могу да размишљају о својим процесима размишљања. На крају ове лекције, разумећете кључне појмове и бићете опремљени практичним примерима за примену метакогниције у дизајну AI агената.

## Циљеви учења

Након завршетка ове лекције, бићете у стању да:

1. Разумете импликације петљи размишљања у дефиницијама агената.
2. Користите технике планирања и процене да бисте помогли агентима који самокоригују своје поступке.
3. Направите своје агенте способне да манипулишу кодом како би обављали задатке.

## Увод у метакогницију

Метакогниција се односи на вишем реда когнитивне процесе који укључују размишљање о властитом размишљању. За AI агенте, то значи бити у стању да процене и прилагоде своје радње на основу самосвести и претходних искустава. Метакогниција, или „размишљање о размишљању“, је важан појам у развоју агенцијских AI система. Она подразумева да AI системи буду свесни својих унутрашњих процеса и у стању да надгледају, регулишу и прилагођавају своје понашање у складу с тим. Баш као што ми то радимо када читамо атмосферу у просторији или разматрамо проблем. Ова самосвест може помоћи AI системима да доносе боље одлуке, идентификују грешке и побољшају свој учинак с временом – што поново води до Туринг теста и расправе о томе да ли ће AI преузети контролу.

У контексту агенцијских AI система, метакогниција може помоћи у решавању више изазова, као што су:
- Прозирност: Осигуравање да AI системи могу објаснити своје разлоге и одлуке.
- Размишљање: Побољшање способности AI система да синтетишу информације и доносе исправне одлуке.
- Прилагодљивост: Омогућавање AI системима да се прилагођавају новим окружењима и променљивим условима.
- Перцепција: Повећање тачности AI система у препознавању и тумачењу података из окружења.

### Шта је метакогниција?

Метакогниција, или „размишљање о размишљању“, вишег је реда когнитивни процес који обухвата самосвест и саморегулацију сопствених когнитивних процеса. У домену AI, метакогниција омогућава агентима да процене и прилагоде своје стратегије и радње, што води ка побољшаном решавању проблема и доношењу одлука. Разумевајући метакогницију, можете дизајнирати AI агенте који нису само интелигентнији, већ и прилагодљивији и ефикаснији. У истинској метакогницији, AI јасно разматра своје сопствене разлоге.

Пример: „Преферирао сам јефтиније летове јер... можда пропуштам директне летове, па ћу поново проверити.“
Прати како и зашто је изабрао одређену руту.
- Обавештавање да је направио грешке јер је превише ослањао на корисничке преференције из претходног пута, па мења своју стратегију доношења одлука, а не само коначну препоруку.
- Дијагностикује обрасце као: „Свaki пут када чујем да корисник помиње 'преоптерећеност', не бих требао само уклонити одређене атракције, већ и размотрити да је мој метод избора 'најбољих атракција' лош ако их увек рангирам по популарности.“

### Значај метакогниције у AI агентима

Метакогниција игра кључну улогу у дизајну AI агената из више разлога:

![Значај метакогниције](../../../translated_images/sr/importance-of-metacognition.b381afe9aae352f7.webp)

- Саморефлексија: Агенти могу проценити свој учинак и идентификовати области за побољшање.
- Прилагодљивост: Агенти могу модификовати своје стратегије на основу претходних искустава и промењених услова.
- Корекција грешака: Агенти могу аутономно детектовати и исправљати грешке, што доводи до прецизнијих резултата.
- Управљање ресурсима: Агенти могу оптимизовати коришћење ресурса, као што су време и рачунарска снага, планирањем и проценом својих радњи.

## Компоненте AI агента

Пре него што се упустимо у метакогнитивне процесе, важно је разумети основне компоненте AI агента. AI агент обично се састоји из:

- Личност: Личност и карактеристике агента које дефинишу како комуницира са корисницима.
- Алати: Капацитети и функције које агент може обављати.
- Вештине: Знање и експертизу које агент поседује.

Ове компоненте заједно раде како би створиле „јединицу стручности“ која може обављати специфичне задатке.

**Пример**:
Сетите се туристичког агента, сервиса агента који не само да планира ваш одмор, већ и прилагођава своју стазу на основу података у реалном времену и претходних искустава корисника.

### Пример: Метакогниција у туристичком агенту

Замислите да дизајнирате туристички сервис покретан AI. Овај агент, „Туристички агент“, помаже корисницима у планирању њихових одмора. Да бисте укључили метакогницију, Туристички агент мора проценити и прилагодити своје радње на основу самосвести и претходних искустава. Ево како метакогниција може одиграти улогу:

#### Тренутни задатак

Тренутни задатак је помоћи кориснику да испланира путовање у Париз.

#### Корaци за обављање задатка

1. **Прикупити корисничке преференције**: Питајте корисника за датуме путовања, буџет, интересовања (нпр. музеји, кухиња, куповина) и било какве посебне захтеве.
2. **Претрага информација**: Тражите опције летова, смештај, атракције и ресторане који одговарају корисничким преференцама.
3. **Генерисање препорука**: Пружите персонализовани итинерер са детаљима о летовима, хотелским резервацијама и предложеним активностима.
4. **Прилагођавање на основу повратних информација**: Питајте корисника за повратне информације о препорукама и направите потребне измене.

#### Потребни ресурси

- Приступ базама података о летовима и хотелским резервацијама.
- Информације о париским атракцијама и ресторанима.
- Податке повратних информација корисника из претходних интеракција.

#### Искуство и саморефлексија

Туристички агент користи метакогницију да процени свој учинак и учи из претходних искустава. На пример:

1. **Анализа корисничких повратних информација**: Туристички агент прегледа повратне информације да одреди које су препоруке добро прихваћене, а које нису. Према томе прилагођава своје будуће предлоге.
2. **Прилагодљивост**: Ако је корисник раније поменуо да му не пријају гужве, Туристички агент ће убудуће избегавати препоруке популарних туристичких места у најпрометнијим сатима.
3. **Корекција грешака**: Ако је Туристички агент направио грешку у претходној резервацији, као што је препорука хотела који је био пун, учи да пре него што да препоруку проверава доступност темељније.

#### Практичан пример за програмере

Ево поједностављеног примера кода Туристичког агента који укључује метакогницију:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # Претражите летове, хотеле и атракције на основу преференција
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # Анализирајте повратне информације и прилагодите будуће препоруке
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Пример употребе
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### Зашто је метакогниција важна

- **Саморефлексија**: Агенти могу анализирати свој учинак и идентификовати области за побољшање.
- **Прилагодљивост**: Агенти могу мењати стратегије на основу повратних информација и променљивих услова.
- **Корекција грешака**: Агенти могу аутономно откривати и исправљати грешке.
- **Управљање ресурсима**: Агенти могу оптимизовати коришћење ресурса, као што су време и рачунарска снага.

Укључивањем метакогниције, Туристички агент може пружити персонализованије и прецизније препоруке за путовања, побољшавајући укупно корисничко искуство.

---

## 2. Планирање код агената

Планирање је критична компонента понашања AI агената. Обухвата налажење корака потребних за постизање циља, узимајући у обзир тренутно стање, ресурсе и могуће препреке.

### Елементи планирања

- **Тренутни задатак**: Јасно дефинисати задатак.
- **Кораци за завршетак задатка**: Поделити задатак на управљиве кораке.
- **Потребни ресурси**: Идентификовати неопходне ресурсе.
- **Искуство**: Користити претходна искуства за информисање планирања.

**Пример**:
Ево корака које Туристички агент треба да предузме да би ефикасно помогао кориснику у планирању путовања:

### Кораци за Туристичког агента

1. **Прикупити корисничке преференције**
   - Питај корисника за детаље о датумима путовања, буџету, интересовањима и било каквим посебним захтевима.
   - Примери: „Када планирате путовање?“ „Који је ваш буџет?“ „Које активности волите током одмора?“

2. **Прикупити информације**
   - Тражи релевантне опције путовања на основу корисничких преференција.
   - **Летови**: Претрага доступних летова у оквиру корисничког буџета и жељених датума.
   - **Смештај**: Проналажење хотела или изнајмљених објеката који одговарају локацији, цени и садржајима које корисник жели.
   - **Атракције и ресторани**: Идентификовање популарних атракција, активности и ресторана који одговарају интересовањима корисника.

3. **Генерисање препорука**
   - Складишти прикупљене информације у персонализовани итинерер.
   - Обезбеђује детаље као што су опције летова, хотелске резервације и предложене активности, прилагођене корисничким преференцијама.

4. **Презентација итинерера кориснику**
   - Делити предложени итинерер са корисником ради прегледа.
   - Пример: „Ево предложеног итинерера за ваше путовање у Париз. Укључује детаље о лету, резервације хотела и листу препоручених активности и ресторана. Јавите ми ваше мишљење!“

5. **Прикупљање повратних информација**
   - Питај корисника за коментаре о предложеном итинереру.
   - Примери: „Да ли вам се свиђају опције летова?“ „Да ли је хотел погодан за ваше потребе?“ „Постоје ли активности које бисте желели да додате или уклоните?“

6. **Прилагођавање на основу повратних информација**
   - Модификуј итинерер према повратним информацијама корисника.
   - Направи потребне промене у препорукама за лет, смештај и активности како би боље одговарале корисничким жељама.

7. **Коначна потврда**
   - Презентуј ажурирани итинерер кориснику ради коначне потврде.
   - Пример: „Направио сам измене у складу са вашим повратним информацијама. Ево ажурираног итинерера. Да ли вам све изгледа добро?“

8. **Резервација и потврда**
   - Чим корисник одобри итинерер, настави са резервацијом летова, смештаја и било којих планираних активности.
   - Пошаљи кориснику детаље потврде.

9. **Обезбеђивање континуиране подршке**
   - Остани доступан да помогнеш кориснику са изменама или додатним захтевима пре и током путовања.
   - Пример: „Ако вам буде потребна додатна помоћ током путовања, слободно ми се обратите у било ком тренутку!“

### Пример интеракције

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Пример употребе унутар захтева за бројеве
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. Корективни RAG систем

Прво да почнемо са разумевањем разлике између RAG алата и преемптивног учитавања контекста

![RAG против учитавања контекста](../../../translated_images/sr/rag-vs-context.9eae588520c00921.webp)

### Ретрајвал-аугментед генератион (RAG)

RAG комбинује систем за претрагу са генеративним моделом. Када се постави упит, систем за претрагу дохвата релевантне документе или податке из екстерне базе, а ове преузете информације се користе за допуну улаза генеративног модела. Ово помаже моделу да генерише прецизније и контекстуално релевантније одговоре.

У RAG систему, агент преузима релевантне информације из базе знања и користи их за генерисање одговарајућих одговора или радњи.

### Корективни RAG приступ

Корективни RAG приступ фокусира се на коришћење RAG техника за исправљање грешака и побољшање тачности AI агената. Ово укључује:

1. **Техника упућивања**: Користи специфичне задатке да усмери агента на преузимање релевантних информација.
2. **Алат**: Имплементација алгоритама и механизама који омогућавају агенту да процени релевантност преузетих информација и генерише прецизне одговоре.
3. **Евалуација**: Континуирано процењивање учинка агента и вршење корекција ради побољшања његове тачности и ефикасности.

#### Пример: Корективни RAG у претраживачком агенту

Размотрите претраживачког агента који преузима информације са интернета да одговара на упите корисника. Корективни RAG приступ би могао обухватити:

1. **Техника упућивања**: Формирање претраживачких упита базираних на улазу корисника.
2. **Алат**: Коришћење алгоритама природног језика и машинског учења за рангирање и филтрирање резултата претраге.
3. **Евалуација**: Анализа повратних информација корисника за идентификовање и исправку нетачности у преузетим информацијама.

### Корективни RAG у туристичком агенту

Корективни RAG (Retrieval-Augmented Generation) побољшава способност AI да преузима и генерише информације уз исправљање било каквих нетачности. Погледајмо како Туристички агент може да користи Корективни RAG приступ да пружи прецизније и релевантније препоруке за путовања.

Ово укључује:

- **Техника упућивања:** Коришћење специфичних упита да усмери агента на преузимање релевантних информација.
- **Алат:** Имплементацију алгоритама и механизама који омогућавају агенту да процени релевантност преузетих информација и генерише прецизне одговоре.
- **Евалуацију:** Континуирано процењивање учинка агента и прилагођавање ради побољшања тачности и ефикасности.

#### Кораци за имплементацију корективног RAG у Туристичком агенту

1. **Почетна интеракција са корисником**
   - Туристички агент прикупља почетне преференције корисника као што су дестинација, датуми путовања, буџет и интересовања.
   - Пример:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **Претрага информација**
   - Туристички агент преузима информације о летовима, смештају, атракцијама и ресторанима на основу корисничких преференци.
   - Пример:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **Генерисање почетних препорука**
   - Туристички агент користи преузете информације да генерише персонализовани итинерер.
   - Пример:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **Прикупљање корисничких повратних информација**
   - Туристички агент пита корисника за мишљење о почетним препорукама.
   - Пример:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **Корективни RAG процес**
   - **Техника упућивања**: Туристички агент формира нове претраживачке упите на основу повратних информација корисника.
     - Пример:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **Алат**: Туристички агент користи алгоритме да рангира и филтрира нове резултате претраге, стављајући нагласак на релевантност према повратним информацијама.
     - Пример:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **Евалуација**: Туристички агент континуирано процењује релевантност и тачност својих препорука анализом повратних информација и прави неопходне измене.
     - Пример:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### Практичан пример

Ево поједностављеног примера Python кода који укључује Корективни RAG приступ у Туристичком агенту:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# Пример употребе
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### Преемптивно учитавање контекста
Преемптивно учитавање контекста подразумева уношење релевантног контекста или позадинских информација у модел пре обраде упита. Ово значи да модел има приступ овим информацијама од почетка, што му може помоћи да генерише информисаније одговоре без потребе да током процеса преузима додатне податке.

Ево поједностављеног примера како може изгледати преемптивно учитавање контекста за апликацију агента за путовања у Пајтону:

```python
class TravelAgent:
    def __init__(self):
        # Унапред учитајте популарне дестинације и њихове информације
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # Преузмите информације о дестинацији из унапред учитаног контекста
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# Пример употребе
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### Објашњење

1. **Иницијализација (`__init__` метода)**: Класа `TravelAgent` унапред учитава речник који садржи информације о популарним дестинацијама као што су Париз, Токио, Њујорк и Сиднеј. Овај речник укључује детаље као што су земља, валута, језик и главне атракције за сваку дестинацију.

2. **Дохватање информација (`get_destination_info` метода)**: Када корисник упита о одређеној дестинацији, метод `get_destination_info` преузима релевантне податке из унапред учитаног речника контекста.

Унапред учитавајући контекст, апликација агента за путовања може брзо одговарати на корисничке упите без потребе да у реалном времену преузима ове информације из спољног извора. Ово чини апликацију ефикаснијом и бржом.

### Започињање плана са циљем пре итерације

Започињање плана са јасним циљем подразумева почетак са дефинисаним циљем или очекиваним резултатом на уму. Дефинисањем овог циља унапред, модел може да га користи као водиљу током итеративног процеса. Ово помаже да свака итерација доведе ближе постизању жељеног резултата, чинећи процес ефикаснијим и фокусиранијим.

Ево примера како можете започети план путовања са циљем пре него што почнете итерацију за агента за путовања у Пајтону:

### Сценарио

Агент за путовања жели да испланира прилагођен одмор за клијента. Циљ је креирање путног плана који максимизира задовољство клијента на основу његових преференција и буџета.

### Кораци

1. Дефинисање преференција клијента и буџета.
2. Започињање иницијалног плана на основу тих преференција.
3. Итерација ради дораде плана, оптимизујући га за задовољство клијента.

#### Пајтон код

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# Пример коришћења
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### Објашњење кода

1. **Иницијализација (`__init__` метода)**: Класа `TravelAgent` се иницијализује са списком потенцијалних дестинација, од којих свака има атрибуте као што су име, цена и тип активности.

2. **Започињање плана (`bootstrap_plan` метода)**: Ова метода креира почетни план путовања на основу преференција и буџета клијента. Пролази кроз списак дестинација и додаје их у план ако одговарају преференцијама и улазе у буџет.

3. **Усклађивање преференција (`match_preferences` метода)**: Ова метода проверава да ли дестинација одговара преференцијама клијента.

4. **Итерација плана (`iterate_plan` метода)**: Дорађује иницијални план покушавајући да замени сваку дестинацију у плану бољим избором, узимајући у обзир преференције и буџетске ограничења клијента.

5. **Израчунавање цене (`calculate_cost` метода)**: Израчунава укупну цену текућег плана, укључујући потенцијално нову дестинацију.

#### Пример коришћења

- **Иницијални план**: Агент за путовања креира почетни план на основу предпочитаног разгледања и буџета од 2000 долара.
- **Дорађени план**: Агент итеративно побољшава план, оптимизујући га за преференције и буџет клијента.

Започињањем плана са јасним циљем (нпр. максимизирање задовољства клијента) и итерацијом за дораду, агент за путовање може креирати прилагођен и оптимизован путни план. Овај приступ осигурава да путни план унапред одговара преференцијама и буџету клијента и побољшава се сваким понављањем.

### Коришћење LLM за прерангирање и оцењивање

Велики језички модели (LLM) могу се користити за прерангирање и оцењивање процењивањем релевантности и квалитета преузетих докумената или генерисаних одговора. Ево како то функционише:

**Претрага:** Почетна претрага доноси скуп кандидата — докумената или одговора — на основу упита.

**Прерангирање:** LLM процењује кандидате и поново их рангира на основу релевантности и квалитета. Овај корак обезбеђује да најрелевантније и најквалитетније информације буду приказане прве.

**Оцењивање:** LLM додељује резултате сваком кандидату који одражавају њихову релевантност и квалитет. Ово помаже у избору најбољег одговора или документа за корисника.

Коришћењем LLM за прерангирање и оцењивање, систем може да пружи прецизније и контекстуално релевантније информације, побољшавајући укупно корисничко искуство.

Ево примера како агент за путовања може да користи Велики језички модел (LLM) за прерангирање и оцењивање дестинација за путовање на основу корисничких преференција у Пајтону:

#### Сценарио - Путовање на основу преференција

Агент за путовања жели да препоручи најбоље дестинације клијенту на основу његових преференција. LLM ће помоћи да се дестинације прерангирају и оцењују како би се осигурало да се најрелевантније опције представе.

#### Кораци:

1. Прикупити корисничке преференције.
2. Претражити списак потенцијалних дестинација.
3. Користити LLM за прерангирање и оцењивање дестинација на основу корисничких преференција.

Ево како можете ажурирати претходни пример да користите Azure OpenAI услуге:

#### Захтеви

1. Потребно је да имате Azure претплату.
2. Креирајте Azure OpenAI ресурс и набавите свој API кључ.

#### Пример Пајтон кода

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Генериши упит за Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # Дефиниши заглавља и садржај захтева
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # Позови Azure OpenAI API да добијеш поново рангиране и оцењене дестинације
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # Извуци и врати препоруке
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# Пример коришћења
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### Објашњење кода – Бројач преференција

1. **Иницијализација**: Класа `TravelAgent` се иницијализује са списком потенцијалних дестинација за путовање, од којих свака има атрибуте као што су име и опис.

2. **Добијање препорука (`get_recommendations` метода)**: Ова метода генерише промпт за Azure OpenAI сервис на основу корисникових преференција и врши HTTP POST захтев ка Azure OpenAI API-ју да би добила прерангиране и оцењене дестинације.

3. **Генерисање промпта (`generate_prompt` метода)**: Ова метода конструише промпт за Azure OpenAI, укључујући корисникове преференције и списак дестинација. Промпт упућује модел да прерангира и оцењује дестинације на основу достављених преференција.

4. **API позив**: Користи се библиотека `requests` за слање HTTP POST захтева ка Azure OpenAI API крајњој тачки. Одговор садржи прерангиране и оцењене дестинације.

5. **Пример коришћења**: Агент за путовања прикупља корисничке преференције (нпр. интересовање за разгледање и разнолику културу) и користи Azure OpenAI сервис за добијање препорука које су прерангиране и оцењене.

Обавезно замените `your_azure_openai_api_key` са вашим стварним Azure OpenAI API кључем и `https://your-endpoint.com/...` са стварним URL-ом крајње тачке ваше Azure OpenAI имплементације.

Коришћењем LLM за прерангирање и оцењивање, агент за путовања може пружити персонализоване и релевантније препоруке клијентима, побољшавајући њихово укупно искуство.

### RAG: Техника промптовања у односу на алат

Retrieval-Augmented Generation (RAG) може бити и техника промптовања и алат у развоју AI агената. Разумевање разлике између ова два може вам помоћи да ефикасније користите RAG у својим пројектима.

#### RAG као техника промптовања

**Шта је то?**

- Као техника промптовања, RAG укључује формулисање специфичних упита или промптова који воде претрагу релевантних информација из великог корпуса или базе података. Ове информације се затим користе за генерисање одговора или акција.

**Како функционише:**

1. **Формулисање промптова**: Креирање добро структурисаних упита или промптова на основу задатка или корисниковог уноса.
2. **Преузимање информација**: Коришћење промптова за претраживање релевантних података из постојеће базе знања или скупa података.
3. **Генерисање одговора**: Комбинација преузетих информација са генеративним AI моделима ради производње комплетног и кохерентног одговора.

**Пример у агенту за путовања**:

- Корисников унос: "Желим да посетим музеје у Паризу."
- Промпт: "Пронађи најбоље музеје у Паризу."
- Дохваћене информације: Детаљи о Лувру, Музеју Орсеј и др.
- Генерисани одговор: "Ево неких најбољих музеја у Паризу: Лувр, Музеј Орсеј и Центар Помпиду."

#### RAG као алат

**Шта је то?**

- Као алат, RAG је интегрисани систем који аутоматизује процес претраге и генерисања, олакшавајући програмерима примену сложених AI функционалности без ручног креирања промптова за сваки упит.

**Како функционише:**

1. **Интеграција**: Уграђује се у архитектуру AI агента, омогућавајући аутоматско руковање задацима претраге и генерисања.
2. **Аутоматизација**: Алат управља целим процесом, од пријема корисничког уноса до генерисања коначног одговора, без потребе за експлицитним промптовима сваки пут.
3. **Ефикасност**: Побољшава перформансе агента оптимизујући процес претраге и генерисања и омогућујући бржи и прецизнији одговор.

**Пример у агенту за путовања**:

- Корисников унос: "Желим да посетим музеје у Паризу."
- RAG алат: Аутоматски преузима информације о музејима и генерише одговор.
- Генерисани одговор: "Ево неких најбољих музеја у Паризу: Лувр, Музеј Орсеј и Центар Помпиду."

### Поређење

| Аспект                 | Техника промптовања                                      | Алат                                                |
|------------------------|-----------------------------------------------------------|-----------------------------------------------------|
| **Ручно или аутоматско**| Ручна формулација промптова за сваки упит.               | Аутоматизован процес претраге и генерисања.         |
| **Контрола**            | Пружа већу контролу над процесом претраге.               | Поједностављује и аутоматизује претрагу и генерисање.|
| **Флексибилност**       | Дозвољава прилагођене промптове према специфичним потребама.| Ефикаснији је за имплементације у великом обиму.     |
| **Сложеност**           | Захтева креирање и подешавање промптова.                  | Лакше се интегрише у архитектуру AI агента.          |

### Практични примери

**Пример технике промптовања:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**Пример алата:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### Процена релевантности

Процена релевантности је кључни аспект перформанси AI агената. Она обезбеђује да информације које агент преузима и генерише буду адекватне, тачне и корисне за корисника. Погледајмо како проценити релевантност у AI агентима, укључујући практичне примере и технике.

#### Кључни појмови у процени релевантности

1. **Свесност о контексту**:
   - Агент мора да разуме контекст корисничког упита како би преузео и генерисао релевантне информације.
   - Пример: Ако корисник тражи "најбоље ресторане у Паризу", агент треба да узме у обзир преференције корисника као што су тип кухиње и буџет.

2. **Тачност**:
   - Подаци које агент пружа требају бити фактички тачни и ажурирани.
   - Пример: Препоручити ресторане који су тренутно отворени и имају добре рецензије, а не затворене или застареле.

3. **Корисничка намера**:
   - Агент треба да препозна намеру корисника иза упита како би пружио најрелевантније информације.
   - Пример: Ако корисник тражи "повољне хотеле", агент треба да приоритизује приступачне опције.

4. **Повратна спрема**:
   - Континуирано прикупљање и анализа повратних информација од корисника помаже агенту да унапреди процес процене релевантности.
   - Пример: Укључивање корисничких оцена и повратних информација о претходним препорукама да би се побољшали будући одговори.

#### Практичне технике за процену релевантности

1. **Оцењивање релевантности**:
   - Додељивање оцена релевантности сваком преузетом предмету на основу тога колико одговара корисничком упиту и преференцијама.
   - Пример:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **Филтрирање и рангирање**:
   - Филтрирање ирелевантних ставки и рангирање преосталих на основу оцена релевантности.
   - Пример:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # Врати 10 најрелевантнијих ставки
     ```

3. **Обрада природног језика (NLP)**:
   - Коришћење NLP техника за разумевање корисничког упита и преузимање релевантних информација.
   - Пример:

     ```python
     def process_query(query):
         # Користите НЛП да извучете кључне информације из корисничког упита
         processed_query = nlp(query)
         return processed_query
     ```

4. **Интеграција повратних информација корисника**:
   - Прикупљање повратних информација о пруженим препорукама и коришћење истих за прилагођавање будућих процена релевантности.
   - Пример:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### Пример: Процена релевантности у агенту за путовања

Ево практичног примера како агент за путовања може проценити релевантност препорука за путовања:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # Врати топ 10 релевантних ставки

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# Пример коришћења
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### Претрага са намером

Претрага са намером подразумева разумевање и тумачење основне сврхе или циља корисничког упита ради преузимања и генерисања најрелевантнијих и најкориснијих информација. Овај приступ превазилази само подударање кључних речи и фокусира се на разумевање стварних потреба и контекста корисника.

#### Кључни појмови у претрази са намером

1. **Разумевање корисничке намере**:
   - Намера корисника може бити категорисана у три главна типа: информативна, навигациона и трансакциона.
     - **Информативна намера**: Корисник тражи информације о одређеној теми (нпр. "Који су најбољи музеји у Паризу?").
     - **Навигациона намера**: Корисник жели да пронађе одређени сајт или страницу (нпр. "званична веб страница Лувра").
     - **Трансакциона намера**: Корисник има намеру да изврши трансакцију, као што је резервација лета или куповина (нпр. "Резервиши лет до Париза").

2. **Свесност о контексту**:
   - Анализа контекста корисничког упита помаже у прецизном идентификовању њихове намере. Ово укључује узимање у обзир претходних интеракција, корисничких преференција и специфичних детаља текућег упита.

3. **Природна обрада језика (NLP)**:
   - NLP технике се користе за разумевање и тумачење природних језичких упита које корисници дају. Ово укључује задатке као што су препознавање ентитета, анализа сентимента и парсирање упита.

4. **Персонализација**:
   - Персонализација резултата претраге на основу корисничке историје, преференција и повратних информација повећава релевантност преузетих информација.

#### Практичан пример: Претрага са намером у агенту за путовања

Погледајмо пример агента за путовања како се претрага са намером може имплементирати.

1. **Прикупљање корисничких преференција**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Разумевање корисничке намере**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **Свесност о контексту**
   ```python
   def analyze_context(query, user_history):
       # Комбинујте тренутну упит са историјом корисника ради разумевања контекста
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **Претраживање и персонализација резултата**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # Пример логике претраге за информативну намјеру
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # Пример логике претраге за навигациону намјеру
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # Пример логике претраге за трансакциону намјеру
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # Пример логике персонализације
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # Врати горњих 10 персонализованих резултата
   ```

5. **Пример употребе**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. Генерисање кода као алат

Агенти за генерисање кода користе AI моделе за писање и извршавање кода, решавајући сложене проблеме и аутоматизујући задатке.

### Агенти за генерисање кода

Агенти за генерисање кода користе генеративне AI моделе за писање и извршавање кода. Ови агенти могу решавати сложене проблеме, аутоматизовати задатке и пружати вредне увиде генеришући и покрећући код на разним програмским језицима.

#### Практичне примене

1. **Аутоматизовано генерисање кода**: Генеришите кодне исечке за специфичне задатке, као што су анализа података, web scraping или машинско учење.
2. **SQL као RAG**: Користите SQL упите за преузимање и манипулацију подацима из база података.
3. **Решавање проблема**: Креирајте и извршавајте код за решавање специфичних проблема, као што је оптимизација алгоритама или анализа података.

#### Пример: агент за генерисање кода за анализу података

Замислите да дизајнирате агента за генерисање кода. Ево како то може да функционише:

1. **Задатак**: Анализа скупа података ради идентификовања трендова и шаблона.
2. **Корци**:
   - Учитајте скуп података у алат за анализу података.
   - Генеришите SQL упите за филтрирање и агрегирање података.
   - Извршите упите и преузмите резултате.
   - Користите резултате за генерисање визуелизација и увида.
3. **Потребни ресурси**: Приступ скупу података, алати за анализу података и SQL могућности.
4. **Искуство**: Користите претходне резултате анализа да побољшате тачност и релевантност будућих анализа.

### Пример: агент за генерисање кода за туристичког агента

У овом примеру, дизајнираћемо агента за генерисање кода, Туристички агент, који помаже корисницима у планирању путовања генеришући и извршавајући код. Овај агент може обављати задатке као што су проналажење опција путовања, филтрирање резултата и прављење распореда користећи генеративни AI.

#### Преглед агента за генерисање кода

1. **Прикупљање корисничких преференција**: Прикупља уносе корисника као што су одредиште, датуми путовања, буџет и интересовања.
2. **Генерисање кода за преузимање података**: Генерише кодне исечке за преузимање информација о летовима, хотелима и знаменитостима.
3. **Извршавање генерисаног кода**: Покреће генерисани код ради преузимања информација у реалном времену.
4. **Генерисање распореда путовања**: Саставља преузете податке у персонализовани план путовања.
5. **Прилагођавање на основу повратних информација**: Прима корисничке повратне информације и по потреби регенерише код како би унапредио резултате.

#### Детаљна имплементација корак по корак

1. **Прикупљање корисничких преференција**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генерисање кода за преузимање података**

   ```python
   def generate_code_to_fetch_data(preferences):
       # Пример: Генериши код за претрагу летова на основу корисничких преференција
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # Пример: Генериши код за претрагу хотела
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **Извршавање генерисаног кода**

   ```python
   def execute_code(code):
       # Извршите генерисани код користећи exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **Генерисање распореда путовања**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **Прилагођавање на основу повратних информација**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # Прилагодите подешавања на основу повратних информација корисника
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # Поново генеришите и извршите код са ажурираним подешавањима
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### Коришћење свести о окружењу и резоновања

На основу шеме табеле, заиста је могуће унапредити процес генерисања упита користећи свест о окружењу и резоновање.

Ево примера како то може да се уради:

1. **Разумевање шеме**: Систем ће разумети шему табеле и искористити ове информације као основу за генерисање упита.
2. **Прилагођавање на основу повратних информација**: Систем ће прилагођавати корисничке преференције на основу повратних информација и разматрати која поља у шеми треба ажурирати.
3. **Генерисање и извршавање упита**: Систем ће генерисати и извршавати упите за преузимање ажурираних података о летовима и хотелима на основу нових преференција.

Ево ажурираног примера Python кода који укључује ове концепте:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # Подешавање преференција на основу повратних информација корисника
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # Разлновање на основу шеме за подешавање осталих повезаних преференција
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # Прилагођена логика за подешавање преференција на основу шеме и повратних информација
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # Генериши код за преузимање података о летовима на основу ажурираног преференција
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # Генериши код за преузимање података о хотелима на основу ажурираног преференција
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # Симулација извршења кода и повратак пробних података
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # Генериши план пута на основу летова, хотела и атракција
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# Пример шеме
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# Пример употребе
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# Поново генериши и изврши код са ажурираним преференцијама
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### Објашњење - Резервација на основу повратних информација

1. **Свесност шеме**: речник `schema` дефинише како треба прилагодити преференције на основу повратних информација. Укључује поља као што су `favorites` и `avoid`, са одговарајућим прилагођавањима.
2. **Прилагођавање преференција (метод `adjust_based_on_feedback`)**: овај метод прилагођава преференције на основу корисничких повратних информација и шеме.
3. **Прилагођавања заснована на окружењу (метод `adjust_based_on_environment`)**: овај метод прилагођава прилагођавања на основу шеме и повратних информација.
4. **Генерисање и извршавање упита**: систем генерише код за преузимање ажурираних података о летовима и хотелима на основу прилагођених преференција и симулира извршавање ових упита.
5. **Генерисање распореда**: систем креира ажуриран распоред на основу нових података о летовима, хотелима и знаменитостима.

Увођењем свести о окружењу и резоновања заснованог на шеми, систем може генерисати прецизније и релевантније упите, што доводи до бољих препорука за путовања и персонализованијег корисничког искуства.

### Коришћење SQL као технике Retrieval-Augmented Generation (RAG)

SQL (Structured Query Language) је моћан алат за рад са базама података. Када се користи као део приступа Retrieval-Augmented Generation (RAG), SQL може да преузме релевантне податке из база података како би информисао и генерисао одговоре или акције у AI агентима. Погледајмо како SQL може да се користи као RAG техника у контексту Туристичког агента.

#### Кључни појмови

1. **Интеракција са базом података**:
   - SQL се користи за упите база података, преузимање релевантних информација и манипулацију подацима.
   - Пример: преузимање информација о летовима, хотелима и знаменитостима из туристичке базе.

2. **Интеграција са RAG**:
   - SQL упити се генеришу на основу корисничких уноса и преференција.
   - Преузети подаци се користе за генерисање персонализованих препорука или акција.

3. **Динамичка генерација упита**:
   - AI агент генерише динамичке SQL упите на основу контекста и корисничких потреба.
   - Пример: прилагођавање SQL упита за филтрирање резултата на основу буџета, датума и интересовања.

#### Примене

- **Аутоматизовано генерисање кода**: генеришите кодне исечке за специфичне задатке.
- **SQL као RAG**: користите SQL упите за манипулацију подацима.
- **Решавање проблема**: креирајте и извршавајте код за решавање проблема.

**Пример**:
Агент за анализу података:

1. **Задатак**: Анализирати скуп података ради проналажења трендова.
2. **Корци**:
   - Учитајте скуп података.
   - Генеришите SQL упите за филтрирање података.
   - Извршите упите и преузмите резултате.
   - Генеришите визуелизације и увиде.
3. **Ресурси**: Приступ скупу података, SQL могућности.
4. **Искуство**: Користите претходне резултате да унапредите будуће анализе.

#### Практичан пример: коришћење SQL у Туристичком агенту

1. **Прикупљање корисничких преференција**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генерисање SQL упита**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **Извршавање SQL упита**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **Генерисање препорука**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### Пример SQL упита

1. **Упит за лет**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **Упит за хотел**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **Упит за знаменитост**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

Коришћењем SQL као дела технике Retrieval-Augmented Generation (RAG), AI агенти попут Туристичког агента могу динамички преузимати и користити релевантне податке како би пружили прецизне и персонализоване препоруке.

### Пример метакогниције

Да бисмо демонстрирали имплементацију метакогниције, креираћемо једноставног агента који *разматра свој процес доношења одлука* док решава проблем. За овај пример ћемо направити систем у којем агент покушава да оптимизује избор хотела, али потом оцењује своје резоне и прилагођава стратегију када направи грешке или подоптималне изборе.

Ово ћемо симулирати коришћењем једноставног примера где агент бира хотеле на основу комбинације цене и квалитета, али ће "разматрати" своје одлуке и променити понашање у складу са тим.

#### Како ово илуструје метакогницију:

1. **Почетна одлука**: Агент ће изабрати најјефтинији хотел, без разумевања утицаја квалитета.
2. **Разматрање и евалуација**: Након почетног избора, агент проверава да ли је хотел "лош" избор користећи повратне информације корисника. Ако утврди да је квалитет хотела био пренизак, он разматра своје резоне.
3. **Прилагођавање стратегије**: Агент прилагођава стратегију на основу свог разматрања и пребацује се са "најјефтинији" на "најбољи_квалитет", чиме побољшава процес одлучивања у будућим итерацијама.

Ево примера:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # Чува изабране хотеле претходно
        self.corrected_choices = []  # Чува исправљене изборе
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # Доступне стратегије

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # Претпоставимо да имамо неке повратне информације од корисника које нам кажу да ли је последњи избор био добар или не
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # Прилагођава стратегију ако је претходни избор био незадовољавајући
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# Симулира листу хотела (цена и квалитет)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# Креира агента
agent = HotelRecommendationAgent()

# Корак 1: Агент препоручује хотел користећи стратегију "најјефтинији"
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# Корак 2: Агент разматра избор и по потреби прилагођава стратегију
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# Корак 3: Агент поново препоручује, овог пута користећи прилагођену стратегију
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### Способности метакогниције агената

Кључно овде је способност агента да:
- Евалуира своје претходне изборе и процес доношења одлука.
- Прилагођава своју стратегију на основу тог разматрања, тј. метакогниција на делу.

Ово је једноставан облик метакогниције у којем систем може да прилагоди свој процес резоновања заснован на унутрашњем повратном повезу.

### Закључак

Метакогниција је моћан алат који може значајно да унапреди способности AI агената. Укључивањем метакогнитивних процеса, можете дизајнирати агенте који су интелигентнији, прилагодљивији и ефикаснији. Користите додатне ресурсе да даље истражите фасцинантни свет метакогниције у AI агентима.

### Имате још питања о дизајн патерну метакогниције?

Придружите се [Microsoft Foundry Discord](https://aka.ms/ai-agents/discord) да се упознате са другим учесницима, присуствовате часовању и добијете одговоре на питања о AI агентима.

## Претходна лекција

[Multi-Agent Design Pattern](../08-multi-agent/README.md)

## Следећа лекција

[AI Agents in Production](../10-ai-agents-production/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**Одрицање од одговорности**:
Овај документ је преведен уз помоћ АИ сервиса за превођење [Co-op Translator](https://github.com/Azure/co-op-translator). Иако се трудимо да превод буде тачан, молимо вас да имате у виду да аутоматизовани преводи могу садржати грешке или нетачности. Изворни документ на његовом оригиналном језику треба сматрати ауторитетним извором. За критичне информације препоручује се стручни људски превод. Не одговарамо за било каква неспоразума или погрешна тумачења настала коришћењем овог превода.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->