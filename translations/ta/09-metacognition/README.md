[![பன்முக முகவரி வடிவமைப்பு](../../../translated_images/ta/lesson-9-thumbnail.38059e8af1a5b71d.webp)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(இந்த பாடத்தின் வீடியோவை பார்க்க மேலேயுள்ள படத்தை கிளிக் செய்யவும்)_
# AI முகவரிகளில் மேட்டாகாக்னிஷன்

## அறிமுகம்

AI முகவரிகளில் மேட்டாகாக்னிஷன் பற்றி பாடத்திற்கு வரவேற்கிறோம்! AI முகவர்கள் தங்கள் சொந்த சிந்தனையைப்பற்றிப் சிந்திக்க முடியுமா என்பது பற்றி ஆர்வமுள்ள தொடக்க நிலை பயனாளிகளுக்கான இந்த அத்தியாயம் வடிவமைக்கப்பட்டுள்ளது. இந்த பாடத்தின் முடிவில், நீங்கள் முக்கியக் கருத்துக்களைப் புரிந்து கொண்டு, AI முகவர்களின் வடிவமைப்பில் மேட்டாகாக்னிஷன் பயன்படுத்துவதற்கான நடைமுறை எடுத்துக்காட்டுகளுடன் கூடியதாக இருப்பீர்கள்.

## கற்றல் இலக்குகள்

இந்த பாடத்தை முடித்த பிறகு, நீங்கள்:

1. முகவர் வரையறைகளில் எண்ணறிவு சுழற்சிகளின் விளைவுகளை புரிந்து கொள்ள முடியும்.
2. தானே திருத்துதலைச் செய்யும் முகவர்களுக்கு திட்டமிடல் மற்றும் மதிப்பீட்டு முறைகளை பயன்படுத்த முடியும்.
3. பணிகளை நிறைவேற்ற குறியீட்டை மாற்றும் திறன் கொண்ட உங்கள் சொந்த முகவர்களை உருவாக்க முடியும்.

## மேட்டாகாக்னிஷன் அறிமுகம்

மேட்டாகாக்னிஷன் என்பது ஒருவரின் தனது சிந்தனை பற்றிப் பார்ப்பதைக் குறிக்கும் மேன்மை நிர்ணாய விதிகளைக் குறிக்கிறது. AI முகவர்களுக்கு, இது சொந்தத் தன்னிறைவு மற்றும் கடந்த அனுபவங்களை அடிப்படையாகக் கொண்டு தங்கள் செயல்களை மதிப்பீடு செய்து சீரமைக்கக் கூடிய திறன் என்பதைக் குறிக்கிறது. "சிந்தனையைப்பற்றிச் சிந்தித்தல்" என்கிற மேட்டாகாக்னிஷன், முகவரிகள் இயக்கும் AI அமைப்புகளின் முக்கியக் கருத்தாகும். இது AI அமைப்புகள் தங்களின் உள்நிலை செயல்முறைகளை உணர்ந்து கண்காணித்து, ஒழுங்குபடுத்தி, தாமாகவே தங்கள் நடத்தை சரிசெய்யக்கூடியவையாக இருக்க வேண்டும் என்பதைக் குறிக்கிறது. நம் வரலாற்றையும் பிரச்சினையைப் பார்த்து நடந்துகொள்ளும் விதமாகவே இதும் அமையும். இந்த தன்னிறைவு AI அமைப்புகள் சிறந்த முடிவுகள் எடுக்க, பிழைகளை கண்டறிந்து, காலத்துக்கு உத்தரவாதமாக செயல்திறனை மேம்படுத்த உதவும் - மீண்டும் ட்யூரிங் சோதனை மற்றும் AI takeover பற்றிய விவாதத்தை இணைக்கிறது.

முகவரான AI அமைப்புகள் உள்ளடக்கிய சூழலில், மேட்டாகாக்னிஷன் பல சவால்களை தீர்க்க உதவும், உதாரணமாக:
- தெளிவுத்தன்மை: AI அமைப்புகள் தங்கள் சிந்தனை மற்றும் முடிவுகளை விளக்கக் கூடியதாக இருக்க வேண்டும்.
- கணக்கு எடுப்பு: AI அமைப்புகள் தகவலை ஒருங்கிணைத்து சத்தமான முடிவுகளை எடுக்கும் திறனை மேம்படுத்த வேண்டும்.
- ஏற்பாட்டறிவு: AI அமைப்புகள் புதிய சூழல்களில் மற்றும் மாறும் நிபந்தனைகளில் தங்களை அதற்கேற்றவாறு சரிசெய்யக்கூடியதாக இருக்க வேண்டும்.
- உணர்தல்: AI அமைப்புகள் சுற்றுச் சூழலிலிருந்து தரவை துல்லியமாகக் கண்டறிந்து பொருள் புரிந்து கொள்ளும்படி மேம்படுத்த வேண்டும்.

### மேட்டாகாக்னிஷன் என்றால் என்ன?

மேட்டாகாக்னிஷன் அல்லது "சிந்திப்பதைப் பற்றி சிந்தித்தல்" என்பது ஒருவரின் அறிவு செயல்முறைகளைப் பற்றிய தன்னிறைவும் தானியங்கி ஒழுங்குப்படுத்தலும் உடைய மேம்பட்ட அறிவால் கூடிய செயல் முறை ஆகும். AI துறையில் இது முகவர்களுக்கு தங்கள் முறைகள் மற்றும் செயல்களை மதிப்பீடு செய்து தழுவி மாற்றவும் உத்தேசிக்கின்ற திறனை வழங்குகிறது; இதனால் பிரச்சினை தீர்க்கும் திறன் மற்றும் முடிவு எடுக்கும் திறன் மேம்படுகிறது. மேட்டாகாக்னிஷனைக் கணிந்து கொண்டால், நீங்கள் அதிக அறிவுள்ளதோடு மேலும் ஏற்படும் மற்றும் பயனுள்ள AI முகவர்களை வடிவமைக்க முடியும். உண்மையான மேட்டாகாக்னிஷனில், AI தன் சிந்தனை முறையை திறம்பட விவாதிக்கும்.

உதாரணம்: “நான் மலிவான விமானங்களை முன்னுரிமை கொடுத்துள்ளேன் ஏனென்றால்… நேரடிக் விமானங்களை தவறவிடக்கூடும் என நினைக்கிறேன், எனவே மீண்டும் சரிபார்க்கிறேன்.”  
அது எந்த வழியைக் கொண்டு தேர்ந்தெடுத்தது என்பதைக் கண்காணித்தல்.  
- கடந்த முறையான பயனர் விருப்பங்களுக்கு அதிக நம்பிக்கை வைப்பதன்மால் பிழைகள் ஏற்பட்டது என்பதை குறிப்பிடுவது, அதனால் கடைசி பரிந்துரையை மட்டும் அல்ல, தீர்மானமெடுக்கப்படும் முறையையும் மாற்றுகிறது.  
- "பயனர் 'மிகவும் களவாடப்பட்டது' என்று குறிப்பிடும் போது, நான் சில காட்சிகளை நீக்கவேண்டாம் மட்டுமல்லாமல் 'உச்சகட்ட காட்சிகள்' தேர்வு முறை தவறாக இருக்கலாம், ஏனெனில் நான் எப்போதும் பிரபலத்தன்மைப் படி வரிசை செய்கிறேன்" என்பதும் கண்டறிதல்.

### AI முகவரியில் மேட்டாகாக்னிஷன் முக்கியத்துவம்

மேட்டாகாக்னிஷன் பல காரணங்களுக்காக AI முகவர் வடிவமைப்பில் முக்கிய பங்கு வகிக்கிறது:

![மேட்டாகாக்னிஷனின் முக்கியத்துவம்](../../../translated_images/ta/importance-of-metacognition.b381afe9aae352f7.webp)

- தன்னிலை பிரதிபலிப்பு: முகவர்கள் தங்களுடைய செயல்திறனை மதிப்பீடு செய்து மேம்படுத்தப்பட வேண்டிய பகுதிகளை அடையாளம் காண முடியும்.
- ஏற்பாட்டார்ந்த திறன்: முகவர்கள் கடந்த அனுபவங்களையும் மாறி வரும் சூழ்நிலைகளையும் அடிப்படையாகக் கொண்டு தங்களுடைய முறைகளை மாற்ற முடியும்.
- பிழை திருத்தல்: முகவர்கள் தானாக பிழைகளை கண்டறிந்து சரி செய்ய முடியும், இது மேலும் துல்லியமான விளைவுகளை வழங்கும்.
- வள மேலாண்மை: முகவர்கள் தங்கள் செயல்களை திட்டமிடல் மற்றும் மதிப்பீட்டின் மூலம் நேரம் மற்றும் கணினி சக்தி போன்ற வளங்களை சிறப்பாக உபயோகப்படுத்த முடியும்.

## AI முகவரியின் கூறுகள்

மேட்டாகாக்னிச சந்திப்புகளுக்கு முன்னர் AI முகவரியின் அடிப்படைக் கூறுகளைப் புரிந்து கொள்வது அவசியம். ஒரு AI முகவர் பொதுவாக கீழ்காணும் கூறுகளைக் கொண்டிருக்கும்:

- சோதனைத் தன்மை: முகவர் எப்படி பயனர்களுடன் தொடர்பு கொள்ளுமோ அதன் தனிநிலை மற்றும் பண்புகள்.
- கருவிகள்: முகவர் செய்யக்கூடிய செயல்திறன்கள் மற்றும் செயல்பாடுகள்.
- திறன்கள்: முகவரின் அறிவு மற்றும் பரிசோதனை திறன்.

இந்த கூறுகள் ஒன்றிணைந்து ஒரு "திறன் அலகை" உருவாக்குகின்றன, இது குறிப்பிட்ட பணிகளை நிறைவேற்றக்கூடியதாக இருக்கும்.

**எடுத்துக்காட்டு**:  
உங்கள் விடுமுறையை திட்டமிடுவதோடு மட்டுமல்லாமல் நேரடி தரவுகளையும் கடந்த பயண அனுபவங்களையும் அடிப்படையாகக் கொண்டு அதன் பாதையை மாற்றும் ஒரு பயண முகவரியைப் பரிந்துரைக்கலாம்.

### எடுத்துக்காட்டு: பயண முகவர் சேவையில் மேட்டாகாக்னிஷன்

நீங்கள் AI வலுவூட்டப்பட்ட ஒரு பயண முகவர் சேவையை வடிவமைக்கிறீர்கள் என்று கற்பனை செய்யுங்கள். இந்த முகவர், "பயண முகவர்," பயனர்களுக்கு விடுமுறை திட்டமிடலில் உதவுகிறது. மேட்டாகாக்னிஷனைக் கூட்டி, பயண முகவர் தன்னிலை மற்றும் கடந்த அனுபவங்கள் அடிப்படையில் தன்னுடைய செயல்களை மதிப்பீடு செய்து மாற்ற வேண்டும். இதோ மேட்டாகாக்னிஷன் எப்படி பங்கு வகிப்பதற்கான எடுத்துக்காட்டு:

#### நிகழ்காலப்பணி

ஒரு பயனருக்கு பாரிஸுக்கு பயணம் திட்டமிட உதவுவது தற்போதைய பணி.

#### பணியை முடிப்பதற்கான படிகள்

1. **பயனர் விருப்பங்களை சேகரித்தல்**: பயண தேதிகள், பட்ஜெட், ஆர்வங்கள் (பழங்கலைக்கலைக்கூடங்கள், சமையல், ஷாப்பிங் போன்றவை) மற்றும் பிற குறிப்பிட்ட தேவைகளைப் பற்றி பயனரிடம் கேட்கவும்.
2. **தகவல்பெறுதல்**: பயனர் விருப்பங்களுடன் பொருந்தும் விமான விருப்பங்கள், விடுதிகள், காட்சிகள் மற்றும் உணவகங்களைத் தேடவும்.
3. **பரிந்துரைகளை உருவாக்குதல்**: விமான விவரங்கள், ஹோட்டல் முன்பதிவுகள் மற்றும் பரிந்துரைக்கப்பட்ட செயல்பாடுகள் கொண்ட தனிப்பட்ட பயண பட்டியலை வழங்கவும்.
4. **பின்னூட்டத்தின் அடிப்படையில் சரிசெய்தல்**: பரிந்துரைகள் குறித்து பயனரிடம் பின்னூட்டம் கேட்டு அடுத்த கட்ட சரிசெய்தல்களை மேற்கொள்ளவும்.

#### தேவையான வளங்கள்

- விமானம் மற்றும் விடுதி முன்பதிவு தரவுத்தளம் பார்வை.
- பாரீசின் காட்சிகள் மற்றும் உணவகங்கள் பற்றிய தகவல்கள்.
- கடந்த தொடர்புகளில் பெற்ற பயனர் பின்னூட்டத் தரவுகள்.

#### அனுபவம் மற்றும் தன்னிலை பிரதிபலிப்பு

பயண முகவர் தன் செயல்திறனை மதிப்பீடு செய்து கடந்த அனுபவங்களிலிருந்து கற்றுக்கொள்ள மேட்டாகாக்னிஷன் பயன்படுத்துகிறது. உதாரணம்:

1. **பயனர் பின்னூட்டத்தை பகுப்பாய்வு செய்தல்**: பயண முகவர் பயனர் பின்னூட்டத்தை ஆய்வு செய்து எந்த பரிந்துரைகள் நல்லவை மற்றும் ஏவை அப்படியில்லை என்பதைத் தீர்மானிக்கிறது. எதிர்கால பரிந்துரைகளை அதன்படி மாற்றுகிறது.
2. **ஏற்றத்தாழ்வு**: ஒரு பயனர் முந்தைய முறையில் கூட்ட முதல் இடங்களை விரும்பவில்லை என்றால், பயண முகவர் எதிர்காலத்தில் பரபரப்பான கணவருகள் நேரங்களில் பிரபலமான பயண இடங்களை பரிந்துரைக்காது.
3. **பிழை திருத்தல்**: கடந்த முறையிலான ஒரு தவறான முன்பதிவை (முழுக்க முன்பதிவு செய்த ஹோட்டல்) செய்முறையை மேம்படுத்திக்கொள்ள பயண முகவர் பின்வட்டாரில் மேலும் பாத்திரம் கூடிய முறையில் கிடைக்கக்கூடிய தன்மையை சரிபார்க்க கற்றுக்கொள்ளும்.

#### நடைமுறை நிரல் எடுத்துக்காட்டு

மேட்டாகாக்னிஷன் இடுகையாயாகக் கொண்டு பயண முகவர்களின் நிரல் எவ்வாறு இருக்க முடியும் என்பதற்கு எளிய எடுத்துக்காட்டு:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # விருப்பங்கள் அடிப்படையில் விமானங்கள், விடுதிகள் மற்றும் ஆர்வமுள்ள இடங்களைத் தேடவும்
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # கருத்துக்களை பகுப்பாய்வு செய்து எதிர்கால பரிந்துரைகளை மாற்றவும்
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# உதாரண பயன்பாடு
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### ஏன் மேட்டாகாக்னிஷன் முக்கியம்

- **தன்னை பிரதிபலித்தல்**: முகவர்கள் தங்கள் செயல்திறனை கண்காணித்து மேம்படுத்தப்பட வேண்டிய இடங்களை கண்டறிய முடியும்.
- **ஏற்றத்தாழ்வு**: முகவர்கள் பின்னூட்டத்தையும் மாறும் சூழலையும் அடிப்படையாகக் கொண்டு தங்களுடைய முறைகளை மாற்ற முடியும்.
- **பிழை திருத்தல்**: முகவர்கள் தானாக பிழைகளை கண்டறிந்து சரி செய்யக்கூடியதாக இருக்கலாம்.
- **வள மேலாண்மை**: நேரம் மற்றும் கணினி சக்தி போன்ற வளங்களை சிறப்பாக பயன்படுத்தும் முறையை மேம்படுத்த முடியும்.

மேட்டாகாக்னிஷன் இடுகையுடன் பயண முகவர் தனிப்பட்ட மற்றும் துல்லியமான பயண பரிந்துரைகளை வழங்கி பொதுவான பயனர் அனுபவத்தை மேம்படுத்த முடியும்.

---

## 2. முகவரிகளில் திட்டமிடல்

திட்டமிடல் என்பது AI முகவர் நடத்தைக்கான முக்கிய பகுதியாகும். இது குறித்த குறிக்கோளை அடைய வேண்டிய படிகளை உருவாக்கும் செயல்முறை ஆகும்; அதற்கான தற்போதைய நிலை, வளங்கள், மற்றும் தடைகளைக் கவனத்தில் கொண்டு செயல்படுத்தும்.

### திட்டமிடல் கூறுகள்

- **நிலை**: பணியை சரியாக வரையறு.
- **பணிகளை முடிப்பதற்கான படிகள்**: பணியை எளிதில் செய்யக்கூடிய படிகளாக உடைக்கவும்.
- **தேவையான வளங்கள்**: தேவையான வளங்களைக் கண்டறி.
- **அனுபவம்**: கடந்த அனுபவங்களை திட்டமிடலில் பயன்படுத்து.

**எடுத்துக்காட்டு**:  
பயண முகவர் பயனரின் பயண திட்டமிடலை திறமையாகச் செய்ய ஏற்கனவே எடுத்துக் கொள்ள வேண்டிய படிகள்:

### பயண முகவருக்கான படிகள்

1. **பயனர் விருப்பங்களை சேகரித்தல்**
   - பயண தேதிகள், பட்ஜெட், விருப்பங்கள் மற்றும் குறிப்பிட்ட கேள்விகள் குறித்து பயனரிடம் கேளுங்கள்.
   - எடுத்துக்காட்டுகள்: "நீங்கள் எப்போது பயணம் மேற்கொள்வீர்கள்?" "உங்கள் பட்ஜெட் வரம்பு என்ன?" "பிரியமான செயல்பாடுகள் என்ன?"

2. **தகவல் பெறுதல்**
   - பயனர் விருப்பங்களை அடிப்படையாகக் கொண்டு பயண விருப்பங்களை தேடுங்கள்.
   - **விமானங்கள்**: பயனர் பட்ஜெட் மற்றும் விருப்பத் தேதிகளில் விமானங்களை தேடு.
   - **விடுதிகள்**: பயனர் விருப்பங்களுக்கு ஏற்ப இடங்கள் மற்றும் விலை அமைவைகளை நோக்கிக் காண்க.
   - **காட்சிகள் மற்றும் உணவகங்கள்**: பயனர் விருப்பங்களுக்கேற்ற பிரபலமான இடங்கள் மற்றும் உணவகங்களை அடையாளம் காண்க.

3. **பரிந்துரைகளை உருவாக்குதல்**
   - திரட்டப்பட்ட தகவல்களை தனிப்பட்ட பயண திட்டமாக தொகுக்கவும்.
   - விமானக் விருப்பங்கள், விடுதி முன்பதிவுகள் மற்றும் பரிந்துரைக்கப்பட்ட செயல்களை பயனருக்கு ஏற்ப விரிவாக கொடுக்கவும்.

4. **பயனருக்கு பயண திட்டத்தை வழங்குதல்**
   - பயனரின் விமர்சனத்துக்காக முன்மொழியப்பட்ட பயண திட்டத்தை பகிரவும்.
   - எடுத்துக்காட்டு: "பாரிஸுக்கான உங்கள் பயணத்திற்கு இதோ சுட்டான பயண திட்டம். இதில் விமான விவரங்கள், விடுதி முன்பதிவுகள் மற்றும் பரிந்துரைக்கப்பட்ட செயல்பாடுகள் உள்ளன. உங்கள் கருத்துக்களை சொல்லுங்கள்!"

5. **பின்வாங்கல் சேகரித்தல்**
   - பயனர் திட்டத்தின் மீதான கருத்துக்களை கேளுங்கள்.
   - எடுத்துக்காட்டுகள்: "விமானங்கள் உங்களுக்கு பிடித்ததா?" "விடுதி தேவைக்கேற்றதா?" "செயல்பாடுகளில் ஏதும் சேர்க்கவோ, நீக்கவோ விரும்புவீர்களா?"

6. **மறுஅமைத்தல் பின்வாங்கின் அடிப்படையில்**
   - பயனர் கருத்துக்களின் அடிப்படையில் பயண திட்டத்தை மாற்றவும்.
   - விமானங்கள், விடுதிகள், செயல்களை பயனர் விருப்பங்களுக்கு ஏற்பச் சரிசெய்யவும்.

7. **தோற்றமான உறுதிப்படுத்தல்**
   - மாற்றிய பயண திட்டத்தை பயனருக்கு கடைசி உறுதிப்படுத்தலுக்காக வழங்கவும்.
   - எடுத்துக்காட்டு: "உங்கள் கருத்துக்களின் அடிப்படையில் மாற்றங்கள் செய்துள்ளேன். இப்போது இந்த பயணத் திட்டத்தைப் பாருங்கள். எல்லாமே சரியா?"

8. **முன்பதிவுகள் மற்றும் உறுதிப்படுத்தல்கள்**
   - பயனர் ஒப்புக்கொண்ட பிறகு விமானங்கள், விடுதிகள் மற்றும் செயல்பாடுகளை முன்பதிவு செய்து உறுதிப்படுத்தவும்.
   - உறுதிப்படுத்தல் விவரங்களை பயனருக்கு அனுப்பவும்.

9. **தொடர்ந்து உதவியளித்தல்**
   - பயணத்தின் முன் மற்றும் போது ஒவ்வொரு மாற்றத்துக்கும் அல்லது கூடுதல் கோரிக்கைக்கும் துணையாக கிடைக்கவும்.
   - எடுத்துக்காட்டு: " உங்கள் பயணத்தின் போது ஏதேனும் உதவி வேண்டுமானால், எப்போதும் என்னை அணுகலாம்!"

### எடுத்துக்காட்டு தொடர்பு

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# படுகாய்ச்சல் கோரிக்கையில் உள்ள உதாரண பயன்பாடு
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. திருத்தல் RAG (Corrective RAG) அமைப்பு

முதல், RAG கருவி மற்றும் முன்னேற்பாட்டு சூழல் ஏற்றுதலுக்கு இடையேயான வித்தியாசத்தை புரிந்து கொள்வோம்

![RAG மற்றும் Context Loading](../../../translated_images/ta/rag-vs-context.9eae588520c00921.webp)

### பெறுதல்-மேம்படுத்தல் உருவாக்குதல் (RAG)

RAG என்பது பெறுதல் அமைப்பையும் உருவாக்கும் மாடலையும் இணைக்கும். ஒரு கேள்வி வந்தவுடன், பெறுதல் அமைப்பு வெளிப்புற ஆதாரத்தில் இருந்து தொடர்புடைய ஆவணங்களோ அல்லது தரவுகளோ பிடித்து கொண்டுவரும்; இந்த பெறப்பட்ட தகவல் உருவாக்கும் மாடலுக்கு உள்ளீடாக சேர்க்கப்படுகிறது. இதனால் மாடல் மேலும் துல்லியமான மற்றும் சூழல் சார்ந்த பதில்களை உருவாக்க உதவும்.

RAG அமைப்பில், முகவர் தொடர்புடைய தகவல்களை அறிவுத்தளத்தில் இருந்து பெற்று, அதைப் பயன்படுத்தி சரியான பதில்கள் அல்லது நடவடிக்கைகள் உருவாக்குகிறான்.

### திருத்தல் RAG அணுகுமுறை

திருத்தல் RAG அணுகுமுறை என்பது பிழைகளை சரி செய்ய மற்றும் AI முகவர்களின் துல்லியத்தை மேம்படுத்த RAG தொழில்நுட்பங்களைப் பயன்படுத்துவதாகும். இது:

1. **ஊக்குவித்தல் முறை**: தொடர்புடைய தகவலை பெறும்படி முகவருக்கு குறிப்பிட்ட ஊக்குவிப்புகளை வழங்குதல்.
2. **கருவி**: பெறப்பட்ட தகவலின் தொடர்பை மதிப்பீடு செய்து துல்லியமான பதில்களை உருவாக்கக்கூடிய உருவாக்குநிரல்களையும் இயந்திரங்களையும் பயன்படுத்துதல்.
3. **மதிப்பீடு**: முகவரின் செயல்திறனை தொடர்ந்தும் ஆய்வு செய்து தேவையான மாற்றங்களை செய்தல்.

#### எடுத்துக்காட்டு: தேடல் முகவரியில் திருத்தல் RAG

பயனர் கேள்விகளுக்கு இணையதளத்திலிருந்து தகவலை பெறும் தேடல் முகவரைக் கவனிப்போம். திருத்தல் RAG அணுகுமுறை அவருக்கு:

1. **ஊக்குவித்தல் முறை**: பயனர் உள்ளீட்டின் அடிப்படையில் தேடல் கேள்விகளை வடிவமைத்தல்.
2. **கருவி**: இயற்கை மொழி செயலாக்கம் மற்றும் இயந்திரக் கற்றல் அல்கோரிதம்களை பயன்படுத்திச் தேடல் முடிவுகளை வரிசைப்படுத்தல் மற்றும் فل்டர் செய்தல்.
3. **மதிப்பீடு**: பெறப்பட்ட தகவலுக்கு பயனர் பின்னூட்டத்தை பகுப்பாய்வு செய்து தவறுகளை கண்டறிந்து திருத்தல் செய்தல்.

### பயண முகவரியில் திருத்தல் RAG

திருத்தல் RAG (Retrieval-Augmented Generation) AIக்கு தகவலைப் பெறுவதும் உருவாக்குவதும் மற்றும் பிழைகளை சரிசெய்தலும் செய்வதற்கான திறனை மேம்படுத்தும். பயண முகவரி, திருத்தல் RAG அணுகுமுறையை எப்படி பயன்படுத்தி மேலும் துல்லியமான மற்றும் பொருத்தமான பயண பரிந்துரைகளை வழங்கக்கூடும் என்பதைக் காண்போம்.

இதில்:

- **ஊக்குவித்தல் முறை**: தொடர்புடைய தகவலை பெற முகவருக்கு குறிப்பிட்ட ஊக்கங்களை வழங்கல்.
- **கருவி**: பெறப்பட்ட தகவலின் தொடர்பை மதிப்பீடு செய்து சரியான பதில்களை உருவாக்கும் அல்கோரிதங்களையும் செயல்முறைகளையும் நடைமுறைப்படுத்தல்.
- **மதிப்பீடு**: முகவரின் செயல்திறனை மதிப்பீடு செய்து தேவையான மாற்றங்களை செய்வதற்கு தொடர்ந்த ஆய்வு.

#### பயண முகவரில் திருத்தல் RAG செயல்முறை படிகள்

1. **தொடக்க பயனர் தொடர்பு**  
   - பயண முகவர் பயனரிடமிருந்து இலக்கு, பயண தேதிகள், பட்ஜெட் மற்றும் ஆர்வங்களைப் பெறுகிறது.  
   - எடுத்துக்காட்டு:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **தகவல் பெறுதல்**  
   - பயண முகவர் பயனர் விருப்பங்களுக்கு ஏற்ப விமானம், விடுதி, காட்சிகள் மற்றும் உணவகங்களைப் பெறுகிறது.  
   - எடுத்துக்காட்டு:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **தொடக்க பரிந்துரைகளை உருவாக்கல்**  
   - பயண முகவர் பெறப்பட்ட தகவலை பயன்படுத்தி தனிப்பட்ட பயண திட்டம் உருவாக்குகிறது.  
   - எடுத்துக்காட்டு:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **பயனர் பின்னூட்டத்தை சேகரித்தல்**  
   - பயண முகவர் தொடக்க பரிந்துரைகளுக்கு பயனரிடமிருந்து பின்னூட்டம் கேட்கிறது.  
   - எடுத்துக்காட்டு:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **திருத்தல் RAG செயல்முறை**  
   - **ஊக்குவித்தல் முறை**: பயனர் பின்னூட்டத்தின் அடிப்படையில் புதிய தேடல் கேள்விகளை உருவாக்குதல்.  
     - எடுத்துக்காட்டு:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **கருவி**: பயனர் கருத்தின் தொடர்பில் புதிய தேடல் முடிவுகளை வரிசைப்படுத்தி فل்டர் செய்யும் அல்கோரிதங்களை பயன்படுத்துதல்.  
     - எடுத்துக்காட்டு:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **மதிப்பீடு**: பயனர் பின்னூட்டங்களின்படியும் பரிந்துரைகளின் தொடர்பும் துல்லியத்தையும் தொடர்ச்சியாக மதிப்பாய்வு செய்து தேவையான மாற்றங்களை செய்யுதல்.  
     - எடுத்துக்காட்டு:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### நடைமுறை எடுத்துக்காட்டு

பயண முகவரியில் திருத்தல் RAG அணுகுமுறையை உட்படுத்திய எளிய பைதான் குறியீடு எடுத்துக்காட்டு:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# உதாரணம் பயன்பாடு
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### முன்னோக்கிய சூழல் ஏற்றுதல்
Pre-emptive Context Load என்பது கேள்வியினை செயலாக்குவதற்கு முன் மாதிரியில் தொடர்புடைய சூழல் அல்லது பின்னணி தகவலை ஏற்றுவது ஆகும். இதன் பொருள், மாதிரி தொடக்கத்திலிருந்து இந்த தகவலுக்கு அணுகல் கொண்டிருப்பது, இது கூடுதலாக தரவை பெற தேவையில்லாமல், மேலும் புரிந்துணர்ந்த பதில்களை உருவாக்க உதவுகிறது.

பயண முகவர் பயன்பாட்டிற்கான பைதான் உதாரணம் எளிமைப்படுத்தப்பட்ட வடிவம் இதோ:

```python
class TravelAgent:
    def __init__(self):
        # பிரபலமான இடங்கள் மற்றும் அவற்றின் தகவல்களை முன்கூட்டியே ஏற்றவும்
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # முன்கூட்டியே ஏற்றிய உள்ளடக்கத்திலிருந்து இடம் தொடர்பான தகவலை கைப்பெறவும்
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# உதாரண பயன்பாடு
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### விளக்கம்

1. **ஆரம்பம் (`__init__` முறை)**: `TravelAgent` வகுப்பு பாரிஸ், டோக்கியோ, நியூயார்க் மற்றும் சிட்னியை போன்ற பிரபலமான இலக்குகளுக்கான தகவல்களைக் கொண்ட ஒரு அகராதியை முன் ஏற்றுகிறது. இந்த அகராதியில் ஒவ்வொரு இலக்குக்கும் நாடு, நாணயம், மொழி மற்றும் முக்கிய Sehenswürdigkeiten போன்ற விவரங்கள் உள்ளன.

2. **தகவல் பெறுதல் (`get_destination_info` முறை)**: பயனர் குறிப்பிட்ட இலக்கைப் பற்றி கேள்வி கேட்டால், `get_destination_info` முறை முன் ஏற்றப்பட்ட சூழல் அகராதியிலிருந்து பொருந்தக்கூடிய தகவலை மீட்டெடுக்கிறது.

சூழலை முன் ஏற்றுவதன் மூலம், பயண முகவர் பயன்பாடு நேரடியாக தவிர்க்கை மூலம் இந்த தகவலை மீட்டெடுக்காமல் துரிதமாக பயனர் கேள்விகளுக்கு பதிலளிக்க முடியும். இது பயன்பாட்டை அதிக திறமையுடன் மற்றும் அதிர்வுத்திறன் கொண்டதாக மாற்றுகிறது.

### இலக்குடன் திட்டத்தை ஆரம்பித்து மீண்டும் புதுப்பித்தல்

இலக்குடன் திட்டத்தை ஆரம்பிப்பது என்பது தெளிவான குறிக்கோள் அல்லது இலக்கை முன்குறிப்பிட்டு தொடங்குவதாகும். இந்த இலக்கை முதலில் வரையறுத்து, மாதிரி மீண்டும் புதுப்பிக்கும் செயல்முறையில் வழிகாட்டும் 원칙மாக பயன்படுத்தலாம். இதனால் ஒவ்வொரு சுற்றுலாவும் விருப்பமான முடிவை அடைவதன் நோக்கத்தை முனைவதற்கு நெருக்கமாக நகர்கிறது, செயல்முறை துல்லியமாகவும் கவனமாகவும் இருக்கும்.

பைதானில் பயண முகவருக்கான ஒரு பயணத் திட்டத்தை இலக்குடன் ஆரம்பித்து மீண்டும் புதுப்பிக்கும் உதாரணம்:

### சூழல்

ஒரு பயண முகவர் தனது வாடிக்கையாளருக்கு தனிப்பயன் விடுமுறை திட்டமிட வேண்டும். இலக்கு வாடிக்கையாளர் விருப்பங்கள் மற்றும் பட்ஜெட் அடிப்படையில் மகிழ்ச்சியை அதிகரிக்கும் பயண திட்டத்தை உருவாக்குவதாகும்.

### படிகள்

1. வாடிக்கையாளர் விருப்பங்கள் மற்றும் பட்ஜெட்டினை வரையறுத்தல்.
2. இந்த விருப்பங்களுக்காக ஆரம்ப திட்டத்தை உருவாக்குதல்.
3. திட்டத்தை மீண்டும் புதுப்பித்து, வாடிக்கையாளர் மகிழ்ச்சிக்காக நுணுக்கமாக்குதல்.

#### பைதான் குறியீடு

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# உதாரண பயன்பாடு
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### குறியீடு விளக்கம்

1. **ஆரம்பம் (`__init__` முறை)**: `TravelAgent` வகுப்பிற்கு பல இலக்குகளின் பட்டியல் கொடுக்கப்படுகிறது; ஒவ்வொன்றுக்கும் பெயர், செலவு மற்றும் செயல்பாட்டுப் பிரிவு போன்ற பண்புகள் உள்ளன.

2. **திட்டத்தை ஆரம்பித்தல் (`bootstrap_plan` முறை)**: வாடிக்கையாளர் விருப்பங்கள் மற்றும் பட்ஜெட்டின் அடிப்படையில் ஆரம்ப பயணத் திட்டத்தை உருவாக்கும் முறை. இலக்குகள் பட்டியலை ஊடாடி, வாடிக்கையாளர் விருப்பத்துடனும் பட்ஜெட்டிற்கும் பொருந்தும் இலக்குகளை திட்டத்தில் சேர்க்கிறது.

3. **விருப்பங்களுடன் பொருத்துதல் (`match_preferences` முறை)**: ஒரு இலக்கு வாடிக்கையாளர் விருப்பத்துடன் பொருந்துகிறதா என சரிபார்க்கும் முறை.

4. **திட்டத்தை மீண்டும் புதுப்பித்தல் (`iterate_plan` முறை)**: ஆரம்ப திட்டத்தை மேம்படுத்தி, ஒவ்வொரு இலக்கையும் வாடிக்கையாளர் விருப்பங்கள் மற்றும் பட்ஜெட் கட்டுப்பாடுகளைக் கருத்தில் கொண்டு சிறந்த பொருத்தத்துடன் மாற்ற முயல்கிறது.

5. **செலவு கணக்கிடுதல் (`calculate_cost` முறை)**: தற்போதைய திட்டத்தின் மொத்தச் செலவையும், புதிய இலக்கின் செலவும் கணக்கிடும் முறை.

#### உதாரண பயன்பாடு

- **ஆரம்பத் திட்டம்**: பயண முகவர், பயணிகளின் சுற்றுலாப் பார்வை விருப்பத்தையும் $2000 பட்ஜெட்டையும் கருத்தில் கொண்டு திட்டம் உருவாக்குகிறார்.
- **மீண்டும் நுணுக்கமான திட்டம்**: பயண முகவர், வாடிக்கையாளர் விருப்பங்களுக்கும் பட்ஜெட்டுக்கும் ஏற்ப திட்டத்தை மீண்டும் புதுப்பிக்கிறார்.

திட்டத்தை தெளிவான இலக்குடன் ஆரம்பித்து மற்றும் மீண்டும் புதுப்பிக்கும்போது, பயண முகவர் தனிப்பயன் செய்யப்பட்ட மற்றும் மேம்படுத்தப்பட்ட பயணத் திட்டத்தை உருவாக்க முடியும். இந்த அணுகுமுறை திட்டம் துவக்கத்தில் இருந்து வாடிக்கையாளர் விருப்பங்களும் பட்ஜெட்டும் பொருந்துமாறு செய்து, ஒவ்வொரு புதுப்பிப்பிலும் மேம்படுத்துகிறது.

### LLM ஐ மறுஇரண்டாம் நிலை வரிசை மற்றும் மதிப்பீட்டிற்காகப் பயன்படுத்துதல்

பெரும் மொழி மாதிரிகள் (LLMs) இனிமையுடன் பெறப்பட்ட ஆவணங்கள் அல்லது உருவாக்கப்பட்ட பதில்களின் தொடர்பு மற்றும் தரத்தை மதிப்பாய்வு செய்து மறுஇரண்டாம் நிலை வரிசை மற்றும் மதிப்பீட்டிற்கு பயன்படுவதாகும். அது எப்படி வேலை செய்கிறது:

**பெறுதல்:** கேள்வியின் அடிப்படையில் விண்ணப்பிக்கப்பட்ட ஆவணங்கள் அல்லது பதில்களின் தொகுப்பை பெறுதல்.

**மறுஇரண்டாம் நிலை வரிசை:** LLM இந்த விண்ணப்பங்களை மதிப்பாய்வு செய்து தொடர்பு மற்றும் தரத்தின் அடிப்படையில் மறுஇரண்டாம் நிலை வரிசைப்படுத்துகிறது. இது மிகவும் தொடர்புடைய மற்றும் தரமான தகவல் முதலில் வழங்கப்படுவதை உறுதி செய்கிறது.

**மதிப்பீடு:** LLM ஒவ்வொரு விண்ணப்பத்திற்கும் தொடர்பு மற்றும் தரத்தைக் காட்டும் மதிப்பெண்களை அளிக்கிறது. இதனால் சிறந்த பதிலோ அல்லது ஆவணமோ தேர்ந்தெடுக்க உதவுகிறது.

LLM களை மறுஇரண்டாம் நிலை வரிசை மற்றும் மதிப்பீட்டிற்கு பயன்படுத்துவதால், முறைமை மேலும் கூர்மையுடன் மற்றும் சூழல் சார்ந்த மிக அருமையான தகவலை வழங்கிறது, இதனால் முழுமையான பயனர் அனுபவம் மேம்படும்.

பயண முகவர், பயனர் விருப்பங்களின் அடிப்படையில் பயண இலக்குகளை மறுஇரண்டாம் நிலை வரிசை மற்றும் மதிப்பீட்டிற்கு எப்படி LLM ஐப் பயன் படுத்தக் கூடியதோ Python உதாரணம் இதோ:

#### சூழல் - விருப்பங்களை அடிப்படையாகக் கொண்டு பயணம்

ஒரு பயண முகவர் வாடிக்கையாளரின் விருப்பங்களைக் கருத்தில் கொண்டு சிறந்த பயண இலக்குகளை பரிந்துரைக்க விரும்புகிறார். LLM, அதிக தொடர்புடைய விருப்பங்களை முன்னுரிமை அளிக்க மறுஇரண்டாம் நிலை வரிசை மற்றும் மதிப்பீடு உதவும்.

#### படிகள்:

1. பயனர் விருப்பங்களை சேகரிக்கவும்.
2. சாத்தியமான பயண இலக்குகளின் பட்டியலை பெற்றுக் கொள்ளவும்.
3. பயனர் விருப்பங்களின் அடிப்படையில் LLM ஐப் பயன்படுத்தி மறுஇரண்டாம் நிலை வரிசை மற்றும் மதிப்பீடு செய்யவும்.

முந்தைய உதாரணத்தை Azure OpenAI சேவைகளைப் பயன்படுத்துவதற்காக இவ்வாறு புதுப்பிக்கலாம்:

#### தேவைப்படும் பொருட்கள்

1. நீங்கள் Azure சந்தா வேண்டும்.
2. Azure OpenAI வளத்தை உருவாக்கி API விசையைப் பெற வேண்டும்.

#### பைதான் குறியீடு உதாரணம்

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Azure OpenAI க்காக ஒரு உந்துசெய்தியை உருவாக்கு
        prompt = self.generate_prompt(preferences)
        
        # கோரிக்கைக்கான தலைப்புகள் மற்றும் பayloadை வரையறு
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # மறுபரிசீலிக்கப்பட்ட மற்றும் மதிப்பிடப்பட்ட இடங்களைக் பெற Azure OpenAI API ஐ அழை
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # பரிந்துரைகளை எடுத்துக்கொண்டு திருப்பி வழங்கும்
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# எடுத்துக்காட்டு பயன்பாடு
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### குறியீடு விளக்கம் - விருப்ப முன்பதிவு செய்பவர்

1. **ஆரம்பம்**: `TravelAgent` வகுப்பிற்கு பல பயண இலக்குகளின் பட்டியலுடன் ஆரம்பிக்கப்படுகிறது; ஒவ்வொன்றிலும் பெயர் மற்றும் விளக்கம் போன்ற பண்புகள் உள்ளன.

2. **பரிந்துரைகளை பெறுதல் (`get_recommendations` முறை)**: பயனர் விருப்பங்களை அடிப்படையாகக் கொண்டு Azure OpenAI சேவைக்கு ஒரு கோரிக்கை உருவாக்கப்பட்டு HTTP POST கோரிக்கை அனுப்பி மறுஇரண்டாம் நிலை வரிசை மற்றும் மதிப்பீடு செய்யப்பட்ட இலக்குகளை பெறுகிறது.

3. **கோரிக்கை உருவாக்குதல் (`generate_prompt` முறை)**: Azure OpenAI க்கான கோரிக்கையை, பயனர் விருப்பங்கள் மற்றும் இலக்குகளின் பட்டியலை உட்படுத்தி உருவாக்குகிறது. இந்த கோரிக்கை மாதிரியை இலக்குகளை மீண்டும் வரிசைப்படுத்தி மதிப்பீடு செய்ய வழிநடத்துகிறது.

4. **API அழைப்பு**: `requests` நூலகம் Azure OpenAI API முடிவுப் புள்ளிக்கு HTTP POST கோரிக்கை செய்ய பயன்படுத்தப்படுகிறது. பதில் மறுஇரண்டாம் நிலை வரிசைப்படுத்தப்பட்ட மற்றும் மதிப்பீடு செய்யப்பட்ட இலக்குகளைக் கொண்டுள்ளது.

5. **உதாரண பயன்பாடு**: பயண முகவர் பயனர் விருப்பங்களை சேகரித்து (உதா: சுற்றுலாப் பார்வை மற்றும் கலாச்சார வேரியத் தன்மை) Azure OpenAI சேவையைப் பயன்படுத்தி மறுஇரண்டாம் நிலை வரிசைப்படுத்தப்பட்ட மற்றும் மதிப்பீடு செய்யப்பட்ட பரிந்துரைகளை பெறுகிறார்.

`your_azure_openai_api_key` என்ற இடத்தில் உங்கள் உண்மையான Azure OpenAI API விசையை மற்றும் `https://your-endpoint.com/...` என்ற இடத்தில் உங்கள் Azure OpenAI நிறைவு URLஐ மாற்றிக்கொள்வதை உறுதிசெய்யுங்கள்.

LLM ஐ மறுஇரண்டாம் நிலை வரிசை மற்றும் மதிப்பீட்டிற்கு பயன்படுத்துவதன் மூலம், பயண முகவர் வாடிக்கையாளர்களுக்கு மேலும் தனிப்பயனாக்கப்பட்ட, சம்பந்தப்பட்ட பயண பரிந்துரைகளை வழங்கி அவர்களின் முழுமையான அனுபவத்தை மேம்படுத்த முடியும்.

### RAG: கோலாட்டமும் கருவியும்

Retrieval-Augmented Generation (RAG) என்பது செயற்கை நுண்ணறிவு முகவர்களின் உருவாக்கத்தில் இரண்டும், ஒரு கோலாட்ட முறையும் ஒரு கருவியும் ஆக இருக்கலாம். இரண்டின் வித்தியாசத்தை புரிந்து கொண்டு உங்கள் திட்டங்களில் RAG ஐ சிறப்பாக பயன்படுத்தலாம்.

#### RAG - ஒரு கோலாட்ட முறையாக

**என்ன?**

- ஒரு கோலாட்ட முறையாக, RAG என்பது பெரிய அறிவுத்தளத்திலிருந்து தொடர்புடைய தகவல்களைப் பெறவும், கேள்விகள் அல்லது கோலாட்டங்களை உருவாக்கவும் பயன்படுத்தப்படும். அப்பட்ட தகவல் பதில்கள் அல்லது செயல்களை உருவாக்கப் பயன்படும்.

**எப்படி வேலை செய்கிறது:**

1. **கோலாட்டங்கள் உருவாக்குதல்**: பணிக்கோள் அல்லது பயன்‌பாட்டாளரின் உள்ளீட்டின் அடிப்படையில் நன்கு வடிவமைக்கப்பட்ட கோலாட்டங்கள் உருவாக்குதல்.
2. **தகவல் தேடல்**: இந்த கோலாட்டங்களைப் பயன்படுத்தி முன்னர் உள்ள அறிவுத்தளம் அல்லது தரவுத்தளம் வழியாக தரவு தேடல்.
3. **பதில் உருவாக்குதல்**: பெறப்பட்ட தகவலை உருவாக்கும் AI மாதிரிகளுடன் சேர்த்து முழுமையான பதிலை உருவாக்குதல்.

**பயண முகவரில் உதாரணம்:**

- பயனர் உள்ளீடு: "நான் பாரிஸில் உள்ள அருங்காட்சியகங்களை பார்க்க விரும்புகிறேன்."
- கோலாட்டம்: "பாரிஸிலுள்ள தலைசிறந்த அருங்காட்சியகங்களை கண்டுபிடி."
- பெறப்பட்ட தகவல்: Louvre அருங்காட்சியகம், Musée d'Orsay போன்ற விவரங்கள்.
- உருவாக்கப்பட்ட பதில்: "பாரிஸிலுள்ள சில சிறந்த அருங்காட்சியகங்கள்: Louvre அருங்காட்சியகம், Musée d'Orsay, மற்றும் Centre Pompidou."

#### RAG - ஒரு கருவியாக

**என்ன?**

- ஒரு கருவியாக, RAG என்பது வலைப்பக்கத்தில் கோழல் மற்றும் உருவாக்கும் செயல்களை தானாக விரிவடையும் முறையாக கையாளும் ஒருங்கிணைந்த அமைப்பு. இதனால் உருவாக்குநர்களுக்கு ஒவ்வொரு கேள்விக்கும் பிரத்தியேக கோலாட்டங்களை இல்லாமல் சிக்கலான AI அம்சங்களை உருவாக்க எளிதாகிறது.

**இது எப்படி செய்கிறது:**

1. **ஒழுங்கமைப்பு**: AI முகவரின் கட்டமைப்புக்குள் RAGஐ இணைத்து, தானாக தகவலைப் பெறுதல் மற்றும் உருவாக்கும் பணிகளை கையாளும்.
2. **தானியங்கி**: பயனர் உள்ளீட்டை பெறுதல் முதல் இறுதி பதிலை உருவாக்கும் வரை முழு முறையையும் தானாக நிர்வகிக்கிறது, ஒவ்வொரு படியிலும் கோலாட்டங்கள் தேவையில்லை.
3. **திறன்**: பிரதான மற்றும் தரமான பதில்களை விரைவாக வழங்குவதற்கு செயல்திறனைக் கூட்டுகிறது.

**பயண முகவரில் உதாரணம்:**

- பயனர் உள்ளீடு: "நான் பாரிஸிலுள்ள அருங்காட்சியகங்களைப் பார்க்க விரும்புகிறேன்."
- RAG கருவி: தானாக அருங்காட்சியக தகவல்களைப் பெற்று பதிலை உருவாக்குகிறது.
- உருவாக்கப்பட்ட பதில்: "பாரிஸிலுள்ள சில சிறந்த அருங்காட்சியகங்கள்: Louvre அருங்காட்சியகம், Musée d'Orsay, மற்றும் Centre Pompidou."

### ஒப்பீடு

| அம்சம்                 | கோலாட்ட முறையாக                                         | கருவியாக                                           |
|-------------------------|-------------------------------------------------------------|----------------------------------------------------|
| **கைமுறை vs தானியங்கி**| ஒவ்வொரு கேள்விக்கும் கைமுறையாக கோலாட்டங்களை வடிவமைத்தல்.      | பெறுதல் மற்றும் உருவாக்குதல் தானாக நடக்கும்.          |
| **கட்டுப்பாடு**         | பெறுதல் செயல்முறையில் மேலான கட்டுப்பாடு அளிக்கிறது.            | பெறுதல் மற்றும் உருவாக்கல் சீராகத் தானியங்கி.        |
| **உடன்படல்**           | குறிப்பிட்ட தேவைகளுக்கு தனிப்பயனாக்கத் திறன்.                   | பெரிய அளவில் செயல்படுத்துவதற்கு முறையாகும்.          |
| **சிக்கல்**             | கோலாட்டங்கள் உருவாக்கம் மற்றும் திருத்தல் தேவை.                | AI முகவரின் கட்டமைப்புடன் எளிதில் இணைக்க முடியும்.   |

### நடைமுறை உதாரணங்கள்

**கோலாட்ட முறையின் உதாரணம்:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**கருவி உதாரணம்:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### தொடர்புத்தன்மையை மதிப்பீடு செய்தல்

தொடர்புத்தன்மையை மதிப்பீடு செய்வது AI முகவரின் செயல்திறனில் முக்கிய அம்சம். இது முகவர் பெறும் மற்றும் உருவாக்கும் தகவல் பயனருக்கு பொருத்தமானது, துல்லியமானது மற்றும் பயனுள்ளதாக இருப்பதை உறுதி செய்கிறது. AI முகவர்களில் தொடர்புத்தன்மையின் மதிப்பீடு எப்படி செய்யப்படுவது மற்றும் நடைமுறை உதாரணங்கள் மற்றும் தொழில்நுட்பங்கள் இங்கே.

#### தொடர்புத்தன்மையை மதிப்பிட முக்கிய கருத்துக்கள்

1. **சூழல் உணர்வு**:
   - பயனர் கேள்வியின் சூழலைக் கவனித்துக் கொண்டு தொடர்புடைய தகவலை பெறும் மற்றும் உருவாக்கும் திறன்.
   - உதாரணம்: "பாரிஸிலுள்ள சிறந்த உணவகங்கள்" என்றால், பயனர் விருப்பங்கள், சமைப்புமுறை மற்றும் பட்ஜெட் ஆகியவற்றைக் கருத்தில் கொள்ளுதல்.

2. **துல்லியம்**:
   - முகவர் வழங்கும் தகவல் உண்மையானதும் புதுப்பிக்கப்பட்டதும் இருக்க வேண்டும்.
   - உதாரணம்: திறந்திருக்கும் உணவகங்களைக்குறித்து பரிந்துரைத்தல், மூடியவை அல்ல.

3. **பயனர் நோக்கம்**:
   - கேள்வியின் அடிப்படையில் பயனர் நோக்கத்தை உணர்ந்து சிறந்த தகவலை வழங்குதல்.
   - உதாரணம்: "பட்ஜெட் முலமாக ஹோட்டல்களை" கேட்டால் மலிவு விலையில் முடிவு வழங்குதல்.

4. **பின்னூட்ட பருவம்**:
   - பயனர் பின்னூட்டத்தை தொடர்ந்து சேகரித்து, தொடர்புத்தன்மையின் மதிப்பீடு முறையை மேம்படுத்தல்.
   - உதாரணம்: முந்தைய பரிந்துரைகளின் மதிப்பீடு மற்றும் எதிரொலியை பயன்படுத்தி பதில்களை மேம்படுத்தல்.

#### தொடர்புத்தன்மையை மதிப்பிட நடைமுறை தொழில்நுட்பங்கள்

1. **தொடர்பு மதிப்பெண் செயல்முறை**:
   - பெறப்பட்ட ஒவ்வொரு பொருளுக்கு தொடர்புத்தன்மை மதிப்பெண்ணை வழங்குதல், அது பயனர் கேள்வி மற்றும் விருப்பங்களுக்கு எவ்வாறு பொருந்துகிறதோ அதனை அடிப்படையாகக் கொண்டு.
   - உதாரணம்:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **வடிகட்டி மற்றும் வரிசைப்படுத்துதல்**:
   - பொருந்தாதவற்றை நீக்கி, மீதமானவற்றை தொடர்புத்தன்மை மதிப்பெண்களுக்கேற்ப வரிசைப்படுத்துதல்.
   - உதாரணம்:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # மேல்நிலை 10 தொடர்புடைய உருப்படிகளை վերադարձு
     ```

3. **இயற்கை மொழி செயலாக்கம் (NLP)**:
   - பயனர் கேள்வியை புரிந்து, தொடர்புடைய தகவலை பெற NLP தொழில்நுட்பங்களைப் பயன்படுத்துதல்.
   - உதாரணம்:

     ```python
     def process_query(query):
         # பயனர் கேள்வியிலிருந்து முக்கிய தகவல்களை எடுப்பதற்காக NLP ஐ பயன்படுத்தவும்
         processed_query = nlp(query)
         return processed_query
     ```

4. **பயனர் பின்னூட்ட ஒருங்கிணைப்பு**:
   - பரிந்துரைகளுக்கு பயனர் பின்னூட்டத்தை சேகரித்து, அதைப் பயன்படுத்தி எதிர்கால தொடர்புத்தன்மை மதிப்பீட்டை சரிசெய்தல்.
   - உதாரணம்:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### உதாரணம்: பயண முகவரில் தொடர்புத்தன்மை மதிப்பீடு

பயண பரிந்துரைகளின் தொடர்புத்தன்மையை மதிப்பிடும் நடைமுறை உதாரணம் இங்கே:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # மேல் 10 தொடர்புடைய பொருட்களை திருப்பவும்

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# எடுத்துக்காட்டு பயன்பாடு
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### நோக்கத்தைக் கொண்டு தேடல்

நோக்கத்தைக் கொண்டு தேடல் என்பது பயனர் கேள்வியின் பின்னர் உள்ள குறிக்கோள் அல்லது நோக்கத்தை புரிந்து, அதன் அடிப்படையில் மிக பொருத்தமான மற்றும் பயனுள்ள தகவலை பெறுதல் மற்றும் உருவாக்குதலை குறிக்கும். இது வெறும் முக்கிய சொற்களை பொருத்துதல் மூலம் மிஞ்சி, பயனர் உண்மையான தேவைகளைப் புரிந்துகொள்ளும் முயற்சியாகும்.

#### நோக்கத்தைக் கொண்டு தேடலில் முக்கிய கருத்துக்கள்

1. **பயனர் நோக்கத்தைப் புரிதல்**:
   - பயனர் நோக்கம் மூன்று முக்கிய வகைகள்: தகவல் தேடு, வழிசெல், மற்றும் பரிவர்த்தனை ஆக பிரிக்கப்படும்.
     - **தகவல் நோக்கம்**: ஒரு பொருள் பற்றிய தகவலைத் தேடுதல் (உதா: "பாரிஸிலுள்ள சிறந்த அருங்காட்சியகங்கள் என்ன?")
     - **வழிசெல் நோக்கம்**: குறிப்பிட்ட இணையதளத்திற்கு செல்ல விருப்பம் (உதா: "Louvre Museum அதிகாரப்பூர்வ இணையதளம்")
     - **பரிவர்த்தனை நோக்கம்**: ஒரு பரிவர்த்தனையை செய்ய முயற்சிப்பு (உதா: "பாரிஸுக்கு விமானம் பதிவு செய்")

2. **சூழல் உணர்வு**:
   - பயனர் கேள்வியினை கருத்தில் கொண்டு அவரின் முன்னைய தொடர்புகள், விருப்பங்கள் மற்றும் தற்போதைய கேள்வியின் சிறப்புகளை ஆராய்ந்து நோக்கத்தை துல்லியமாக கண்டுபிடித்தல்.

3. **இயற்கை மொழி செயலாக்கம் (NLP)**:
   - பயனர் கேள்விகளை புரிந்து அதை வடிப்பதில் NLP தொழில்நுட்பங்களைப் பயன்படுத்துதல். இதில் உயிரணு அடையாளம், உணர்வு பகுப்பு மற்றும் கேள்வி பார்சிங் அடங்கும்.

4. **தனிப்பயனாக்கல்**:
   - பயனர் வரலாறு, விருப்பங்கள் மற்றும் பின்னூட்டத்தின் அடிப்படையில் தேடல் முடிவுகளை தனிப்பயனாக்குதல், தகவலின் தொடர்புத்தன்மையை மேம்படுத்துகிறது.

#### நடைமுறை உதாரணம்: பயண முகவரில் நோக்கத்தைக் கொண்டு தேடல் செயல்படுத்தல்

பயண முகவருக்கு உதாரணமாக, நோக்கத்தைக் கொண்டு தேடல் எப்படி நடைமுறைப்படுத்தலாம்.

1. **பயனர் விருப்பங்களை சேகரித்தல்**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **பயனர் நோக்கத்தை புரிதல்**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **சூழல் உணர்வு**


   ```python
   def analyze_context(query, user_history):
       # தற்போதைய கேள்வியையும் பயனர் செயல்பாட்டு வரலாரியையும் இணைத்து சூழலைப் புரிந்து கொள்ளுங்கள்
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **தேடல் மற்றும் தனிப்பயனாக்கப்பட்ட முடிவுகள்**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # தகவல் நோக்கத்திற்கான உதாரண தேடல் தந்திரம்
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # வழிசெலுத்தும் நோக்கத்திற்கான உதாரண தேடல் தந்திரம்
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # பரிவா்த நோக்கத்திற்கான உதாரண தேடல் தந்திரம்
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # உதாரண தனிப்பயன்பாடு தந்திரம்
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # மேலிருந்து 10 தனிப்பயன் முடிவுகளை திருப்பி அளி
   ```

5. **உதாரண பயன்பாடுகள்**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. கருவியாகக் கோடை உருவாக்குதல்

கோடை உருவாக்கும் முகவர்கள் AI மாடல்களை பயன்படுத்தி கோடை எழுதவும் செயல்படுத்தவும், கடினமான பிரச்சினைகளை தீர்க்கவும் மற்றும் பணிகளை தானாகச் செய்யவும் உதவுகின்றனர்.

### கோடை உருவாக்கும் முகவர்கள்

கோடை உருவாக்கும் முகவர்கள் உருவாக்கும் AI மாடல்களைப் பயன்படுத்தி கோடை எழுதவும் செயல்படுத்தவும் செய்கின்றனர். இப் பயனர் கடினமான பிரச்சினைகள், தானியங்கி பணிகள் மற்றும் பல்வேறு நிரலாக்க மொழிகளில் கோடை உருவாக்கி இயக்குவதன் மூலம் முக்கியமான अंतर्दृष्टிகளை வழங்க இயலும்.

#### நடைமுறை பயன்பாடுகள்

1. **தானியங்கி கோடை உருவாக்கம்**: தரவு பகுப்பாய்வு, வலை தோக்கு எடுக்கும் பணிகள் அல்லது இயந்திரக் கற்றல் போன்ற குறிப்பிட்ட பணிகளுக்கான கோடை துண்டுகளை உருவாக்குதல்.
2. **RAG ஆக SQL**: தரவுத்தளங்களில் இருந்து தரவை மீட்டெடுக்கவும் மாற்றவும் SQL வினாக்களைப் பயன்படுத்துதல்.
3. **பிரச்சினை தீர்க்கும்**: குறிப்பிட்ட பிரச்சினைகளை தீர்க்கக் கோடை உருவாக்கி இயக்குதல், உதாரணமாக ஆல்கோரிதங்களை மேம்படுத்துவது அல்லது தரவை பகுப்பாய்வு செய்தல்.

#### உதாரணம்: தரவு பகுப்பாய்விற்கான கோடை உருவாக்கும் முகவர்

நீங்கள் ஒரு கோடை உருவாக்கும் முகவரைக் வடிவமைக்கிறீர்கள் என்று கற்பனை செய்க:

1. **பணி**: ஒரு தரவுத்தொகுப்பை பகுப்பாய்வு செய்து போக்குகள் மற்றும் மாதிரிகளை கண்டறிதல்.
2. **படிகள்**:
   - தரவுத்தொகுப்பை தரவு பகுப்பாய்வு கருவியில் ஏற்றுதல்.
   - தரவைக் குறைக்க மற்றும் கூட்டக்கூடிய SQL வினாக்களை உருவாக்குதல்.
   - வினாக்களை இயக்கி முடிவுகளைப் பெறுதல்.
   - முடிவுகளை பயன்படுத்தி காட்சிப்படுத்தல்களும் செய்திகள் தயாரித்தல்.
3. **தேவையான வளங்கள்**: தரவுத்தொகுப்பை அணுகல், தரவு பகுப்பாய்வு கருவிகள் மற்றும் SQL திறன்கள்.
4. **அனுபவம்**: முந்தைய பகுப்பாய்வு முடிவுகளை பயன்படுத்தி எதிர்கால பகுப்பாய்வுகளை மேலும் துல்லியமாகவும் பொருத்தமாகவும் மாற்றுதல்.

### உதாரணம்: பயண முகவர்க்கு கோடை உருவாக்கும் முகவர்

இந்த உதாரணத்தில், பயண முகவர்க்கு உதவுவதற்காக பயனர் பயணத்தை திட்டமிட, கோடை உருவாக்கவும் இயக்கவும் உதவும் ஒரு கோடை உருவாக்கும் முகவரை வடிவமைப்போம். இந்த முகவர் பயண விருப்பங்கள் தேடுதல், முடிவுகளை வடிகட்டுதல் மற்றும் உருவாக்கிய AI மூலம் பயண திட்டத்தை ஒன்றிணைப்பது போன்ற பணிகளை செய்யும்.

#### கோடை உருவாக்கும் முகவரின் குறித்து

1. **பயனர் விருப்பங்களை சேகரித்தல்**: பயண இடம், பயண தேதி, பட்ஜெட் மற்றும் விருப்பங்கள் போன்ற பயனர் உள்ளீடுகளை சேகரிக்கும்.
2. **தரவை மீட்டெடுக்க கோடை உருவாக்குதல்**: விமானங்கள், ஹோட்டல்கள் மற்றும் ஈர்ப்புகளுக்கான தரவுகளைப் பெற கோடை துண்டுகளை உருவாக்குதல்.
3. **உருவாக்கிய கோடையை இயக்குதல்**: நேரடி தகவல்களை பெற உருவாக்கிய கோடையை இயக்குதல்.
4. **பயண திட்டம் உருவாக்குதல்**: பெறப்பட்ட தரவுகளை தனிப்பயனாக்கப்பட்ட பயணத் திட்டமாக தொகுத்தல்.
5. **புள்ளிவிவரங்கள் அடிப்படையில் சீரமைத்தல்**: பயனர் கருத்துக்களைப் பெற்று முடிவுகளை மேம்படுத்த உருவாக்கிய கோடையை மீண்டும் ரெஜெனரேட் செய்தல்.

#### படி படியாக செயல்படுத்தல்

1. **பயனர் விருப்பங்களை சேகரித்தல்**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **தரவை மீட்டெடுக்க கோடை உருவாக்குதல்**

   ```python
   def generate_code_to_fetch_data(preferences):
       # உதாரணம்: பயனர் விருப்பத்திற்கு அடிப்படையாகக் கொண்டு விமானங்களை தேடக் குறியீட்டை உருவாக்கவும்
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # உதாரணம்: ஹோட்டல்களை தேடக் குறியீட்டை உருவாக்கவும்
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **உருவாக்கிய கோடையை இயக்குதல்**

   ```python
   def execute_code(code):
       # exec ஐப் பயன்படுத்தி உருவாக்கப்பட்ட குறியீட்டை இயக்கவும்
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **பயணத் திட்டம் உருவாக்குதல்**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **பின்விளைவுகளின் அடிப்படையில் சீரமைத்தல்**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # பயனர் கருத்துக்களை அடிப்படையாகக் கொண்டு விருப்பங்களை சரிசெய்க
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # புதுப்பிக்கப்பெற்ற விருப்பங்களுடன் குறியீட்டை மீண்டும் உருவாக்கி இயக்குக
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### சுற்றுச்சூழல் அறிவும் காரணிப்பும் பயன் பெறுதல்

அட்டவணையின் ஸ்கீமா அடிப்படையில் கேள்விகள் உருவாக்கும் செயல்முறையை சுற்றுச்சூழல் அறிவும் காரணிப்பும் மேம்படுத்த முடியும்.

இதனால் எப்படி செய்யலாம் என்று ஒரு உதாரணம்:

1. **ஸ்கீமாவை புரிந்து கொள்வது**: அமைப்பு அட்டவணையின் ஸ்கீமாவை புரிந்து கொண்டு கேள்வி உருவாக் கட்டமைப்பை நிலைநாட்டும்.
2. **பின்விளைவுகளின் அடிப்படையில் சீரமைத்தல்**: பயனர் கருத்துக்கள் அடிப்படையில் விருப்பங்களை மாற்றி எந்த ஸ்கீமா புலங்கள் புதுப்பிக்கப்பட வேண்டும் என்பதில் கருத்து விடுக்கும்.
3. **கேள்விகளை உருவாக்கி செயல்படுத்தல்**: புதுப்பிக்கப்பட்ட விருப்ப அடிப்படையில் விமானம் மற்றும் ஹோட்டல் தரவை மீட்டெடுக்க கேள்விகளை உருவாக்கி இயக்கும்.

இணங்குத் கொள்கையை உள்ளடக்கிய புதிய Python கோடை உதாரணம்:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # பயனர் கருத்துக்களை அடிப்படையாகக் கொண்டு விருப்பங்களை சரிசெய்க
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # பிற தொடர்புடைய விருப்பங்களை சரிசெய்வதற்கான திட்டக்கோப்பின் அடிப்படையில் மனதளிப்பு
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # திட்டக்கோப்பும் கருத்துக்களமும் அடிப்படையில் விருப்பங்களை சரிசெய்வதற்கான தனிப்பயன் logic
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # புதுப்பிக்கப்பட்ட விருப்பங்களின் அடிப்படையில் பயணத் தகவல்களைப் பெறக் கோடு உருவாக்கு
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # புதுப்பிக்கப்பட்ட விருப்பங்களின் அடிப்படையில் ஹோட்டல் தரவுகளைப் பெறக் கோடு உருவாக்கு
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # கோடை செயல்படுத்தி மெய்த்தத் தகவலைத் திரும்ப வழங்கு
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # விமானங்கள், ஹோட்டல்கள், மற்றும் கவர்ச்சிகள் அடிப்படையில் பயண திட்டம் உருவாக்கு
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# உதாரண திட்டக்கோப்பு
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# உதாரணப் பயன்பாடு
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# புதுப்பிக்கப்பட்ட விருப்பங்களுடன் கோட்டை மீண்டும் உருவாக்கி செயல்படுத்து
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### விளக்கம் - பின்விளைவுகள் அடிப்படையிலான முன்பதிவு

1. **ஸ்கீமா அறிவு**: `schema` அகராதி கருத்துக்கள் அடிப்படையில் விருப்பங்களைச் சீரமைக்க எப்படி என்பதை வரையறுக்கிறது. இதில் `favorites` மற்றும் `avoid` போன்ற புலங்கள் மற்றும் மாற்றங்கள் அடங்கும்.
2. **பின்விளைவுகளின் அடிப்படையில் விருப்பங்களை சீரமைத்தல் (`adjust_based_on_feedback` முறை)**: இந்த முறை பயனர் கருத்துக்களை மற்றும் ஸ்கீமாவை பயன்படுத்தி விருப்பங்களை சீரமைக்கிறது.
3. **சுற்றுச்சூழல் அடிப்படையிலான சீரமைத்தல் (`adjust_based_on_environment` முறை)**: இந்த முறை ஸ்கீமா மற்றும் கருத்துக்களின் அடிப்படையில் தனிப்பயனாக்கப்பட்ட சீரமைப்புகளை செய்கிறது.
4. **கேள்விகளை உருவாக்கி செயல்படுத்துதல்**: அமைக்கப்பட்ட விருப்பங்களைப் பொருத்து விமானமும் ஹோட்டலும் தரவுகளை மீட்டெடுக்கும் கேள்விகளைக் உருவாக்கி செயல்படுத்திறது.
5. **பயணத் திட்டம் உருவாக்குதல்**: புதிய விமானம், ஹோட்டல் மற்றும் ஈர்ப்பு தரவுகளின் அடிப்படையில் புதுப்பிக்கப்பட்ட பயணத் திட்டம் செய்முறைப்படுத்தப்படுகிறது.

அமைப்பு சுற்றுச்சூழலை அறிந்ததும், ஸ்கீமா அடிப்படையிலான காரணிப்பும் ஆகியவையால், இது இன்னும் துல்லியமான மற்றும் பொருத்தமான கேள்விகளை உருவாக்கி பயண பரிந்துரைகளை மேம்படுத்தி, தனிப்பட்ட பயனர் அனுபவத்தை வழங்கலாம்.

### SQL ஐ புனைகலை அடிப்படையாக்கிய தயாரிப்பு (RAG) தொழில்நுட்பமாகப் பயன்படுத்துதல்

SQL (Structed Query Language) என்பது தரவுத்தளங்களுடன் தொடர்பு கொள்ள சக்திவாய்ந்த கருவி. புனைகலை அடிப்படையாக்கிய தயாரிப்பு (RAG) முறையின் ஒரு பகுதியாக பயன்படுத்தும்போது, SQL தரவுத்தளங்களில் இருந்து பொருத்தமான தரவை மீட்டெடுத்து AI முகவர்களில் பதில்கள் அல்லது செயல்களை உருவாக்க உதவும். பயண முகவரின் சூழலில் SQL-ஐ RAG தொழில்நுட்பமாக எப்படி பயன்படுத்தலாம் என்பதைக் காண்போம்.

#### முக்கியக் கருத்துகள்

1. **தரவுத்தள தொடர்பு**:
   - SQL வினாக்கள் மூலம் தரவுத்தளங்களை வினவவும், பொருத்தமான தகவலைப் பெறவும், மாற்றவும்.
   - உதாரணம்: பயண தரவுத்தளத்திலிருந்து விமான விவரங்கள், ஹோட்டல் தகவல்கள் மற்றும் ஈர்ப்புகளை பெறுதல்.

2. **RAG உடன் ஒருங்கிணைப்பு**:
   - பயனர் உள்ளீடு மற்றும் விருப்பங்களின் அடிப்படையில் SQL வினாக்கள் உருவாக்கப்படுகின்றன.
   - பெறப்பட்ட தரவு தனிப்பயனாக்கப்பட்ட பரிந்துரைகள் அல்லது செயல்கள் உருவாக்க பயன்படுகிறது.

3. **தொர்மையான கேள்வி உருவாக்கம்**:
   - சூழல் மற்றும் பயனர் தேவைகளின் அடிப்படையில் AI முகவர் டைனமிக் SQL கேள்விகளை உருவாக்குகிறது.
   - உதாரணம்: பட்ஜெட், தேதிகள் மற்றும் விருப்பங்களை அடிப்படையாக வைத்து SQL கேள்விகளை வடிவமைத்தல்.

#### பயன்பாடுகள்

- **தானியங்கு கோடை உருவாக்கம்**: குறிப்பிட்ட பணிகளுக்கான கோட்டை உருவாக்குதல்.
- **RAG போல SQL**: தரவை மாற்ற SQL கேள்விகளைப் பயன்படுத்துதல்.
- **பிரச்சினை தீர்க்கும்**: பிரச்சினைகளைத் தீர்க்க கோடை உருவாக்கி இயக்குதல்.

**உதாரணம்**:
ஒரு தரவு பகுப்பாய்வு முகவர்:

1. **பணி**: புதிய போக்குகளை கண்டறிய தரவுத்தொகுப்பை பகுப்பாய்வு செய்தல்.
2. **படிகள்**:
   - தரவுத்தொகுப்பை ஏற்றுதல்.
   - தரவைத் துறக்க SQL வினாக்களை உருவாக்குதல்.
   - வினாக்களை இயக்கி முடிவுகளைப் பெறுதல்.
   - காட்சிப்படுத்தல்களும் தகவல்களும் உருவாக்குதல்.
3. **வளங்கள்**: தரவுத்தொகுப்பு அணுகல், SQL திறன்கள்.
4. **அனுபவம்**: காலத்துக்கு முந்தைய முடிவுகளை பயன் படுத்தி எதிர்காலங்களை மேம்படுத்தல்.

#### நடைமுறை உதாரணம்: பயண முகவரில் SQL பயன்பாடு

1. **பயனர் விருப்பங்களை சேகரித்தல்**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **SQL கேள்விகள் உருவாக்குதல்**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **SQL கேள்விகள் இயக்குதல்**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **பரிந்துரைகள் உருவாக்குதல்**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### உதாரண SQL கேள்விகள்

1. **விமான கேள்வி**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **ஹோட்டல் கேள்வி**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **ஈர்ப்பு கேள்வி**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

SQL ஐ புனைகலை அடிப்படையாக்கிய தயாரிப்பு (RAG) தொழில்நுட்பத்தின் ஒரு பகுதியாக பயன்படுத்துவதால், பயண முகவர்போன்ற AI முகவர்கள் தேவையான தரவை டைனமிக்காக மீட்டெடுக்க மற்றும் பயன்படுத்தி துல்லியமான தனிப்பயன் பரிந்துரைகளை வழங்க முடியும்.

### Metacognition (மேட்டகாப்னிஷன்) உதாரணம்

அதன் முடிவு எடுக்கும் செயல்முறையை *தன் மீது சிந்தித்துக்* பிரச்சினையை தீர்க்கும் ஒரு எளிய முகவரை உருவாக்குவோம். இந்த உதாரணத்தில், முகவர் மிகவும் குறைந்த விலை மற்றும் தரத்தை வைத்து ஹோட்டல் தேர்வு செய்கிறது, ஆனால் பின்னர் அதன் காரணிப்பை மதிப்பாய்வு செய்து அத்தகைய தவறு ஏற்பட்டால் தான்கு சரி செய்யும்.

இந்த நடைமுறை எளிய உதாரணமாகும், இதில் முகவர் தன் முடிவுகளைச் சிந்தித்து தனது செயல் திட்டத்தை மாற்றிக் கொள்ளும்.

#### இது எப்படி Metacognition-ஐ விளக்கும்:

1. **ஆரம்ப முடிவு**: முகவர் தரமான தாக்கத்தை புரிந்துகொள்ளாமல் மிகவும் குறைவான விலை கொண்ட ஹோட்டலை தேர்ந்தெடுக்கும்.
2. **ஆய்வு மற்றும் மதிப்பாய்வு**: ஆரம்பத் தேர்வுக்குப் பிறகு, பயனர் கருத்துக்களைப் பொருத்து இந்த ஹோட்டல் ஒரு "தீய" தேர்வா என்பதை முகவர் ஆய்வு செய்கிறது. தரம் குறைவாக இருந்தால், அது தன் காரணிப்பை மீண்டும் பார்க்கிறது.
3. **திட்டமாற்றம்**: முகவர் தன் காரணிப்பை மாற்றி “அதிகபட்ட தரம்” ஐ முன்னுரிமையாக மாற்றி, எதிர்கால முடிவுகளை மேம்படுத்துகிறது.

இதோ ஒரு உதாரணம்:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # முன்பு தேர்ந்தெடுக்கப்பட்ட ஹோட்டல்களை சேமிக்கிறது
        self.corrected_choices = []  # திருத்தப்பட்ட தேர்வுகளை சேமிக்கிறது
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # கிடைக்கக்கூடிய திட்டங்கள்

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # கடைசிப் தேர்வு நல்லதா இல்லையா என்பதை பராமரிப்பதற்கான பயனர் கருத்தை உள்ளது என்று நினைக்கலாம்
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # முன்பு செய்யப்பட்ட தேர்வு திருப்திகரவில்லையெனில் திட்டத்தை சரி செய்யவும்
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# ஒரு ஹோட்டல் பட்டியலை ஒளிர்ச்சி செய்க (விலை மற்றும் தரம்)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# ஒரு முகவரை உருவாக்கு
agent = HotelRecommendationAgent()

# படி 1: முகவர் "சிக்கனமான" திட்டத்தை பயன்படுத்தி ஒரு ஹோட்டலை பரிந்துரைக்கிறான்
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# படி 2: முகவர் தேர்வை பரிசலித்து, தேவையெனில் திட்டத்தை சரிசெய்கிறது
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# படி 3: முகவர் மீண்டும் பரிந்துரைக்கிறார், இந்த முறையில் சரிசெய்யப்பட்ட திட்டத்தை பயன்படுத்தி
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### முகவரின் Metacognition திறன்கள்

இங்கே முக்கியமெனில் முகவர்:

- தன் முந்தைய தேர்வுகள் மற்றும் முடிவு செயல்முறைகளை மதிப்பாய்வு செய்கிறது.
- அந்த சிந்தனையின் அடிப்படையில் தன் திட்டத்தை மாற்றிக்கொள்கிறது, அது தான் செயலில் Metacognition ஆகும்.

இது ஒரு எளிய வகை metacognition ஆகும், இதில் அமைப்பு உட்பிரதிபலிப்பு அடிப்படையில் தன் காரணிப்பை மாற்றுவதற்கான திறன் உள்ளது.

### முடிவு

Metacognition என்பது AI முகவர்களின் திறன்களை மிகுந்த வகையில் மேம்படுத்தும் சக்திமிக்க கருவி. இதைப் பொருத்து செயல்முறைகளை வடிவமைத்து, நீங்கள் இன்னும் புத்திசாலி, தகுந்த மற்றும் விளைவுள்ளது வாய்ந்த முகவர்களை உருவாக்க முடியும். மேலதிக வளங்களைப் பயன்படுத்தி AI முகவர்களில் metacognition உலகத்தை மேலும் ஆராய்வீர்கள்.

### Metacognition வடிவமைப்பு மாதிரியைக் குறித்து மேலும் கேள்விகள் உள்ளதா?

[Microsoft Foundry Discord](https://aka.ms/ai-agents/discord) இல் சேர்ந்து மற்ற பயில்பவர்களை சந்திக்கவும், அலுவலக நேரங்களில் கலந்துகொண்டு உங்கள் AI முகவர்களின் கேள்விகளுக்கு பதில் பெறுங்கள்.

## முந்தைய பாடம்

[பன்முகவர் வடிவமைப்பு மாதிரி](../08-multi-agent/README.md)

## அடுத்த பாடம்

[உற்பத்தியில் AI முகவர்கள்](../10-ai-agents-production/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**பிரேரிப்புரை**:
இந்த ஆவணம் AI மொழிமாற்று சேவை [Co-op Translator](https://github.com/Azure/co-op-translator) மூலம் மொழிபெயர்க்கப்பட்டுள்ளது. நாங்கள் துல்லியத்திற்காக முயற்சித்தும், தானாக செயல்படும் மொழிபெயர்ப்புகளில் தவறுகள் அல்லது துல்லியக்குறைவுகள் இருக்கக்கூடுதல் என்பதை நினைவில் கொள்ளுங்கள். இயல்பான மொழியில் உள்ள அசல் ஆவணம் அதிகாரப்பூர்வ மூலமாக கருதப்பட வேண்டும். முக்கியமான தகவல்களுக்கு, தொழில்முறை மனித மொழிபெயர்ப்பு பரிந்துரைக்கப்படுகிறது. இந்த மொழிபெயர்ப்பின் பயன்பாட்டினால் ஏற்படும் எந்த தவறான புரிதல்களுக்கும் அல்லது தவறான விளக்கங்களுக்கும் நாங்கள் பொறுப்பேற்கவில்லை.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->