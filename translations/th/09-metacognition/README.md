[![การออกแบบหลายเอเจนต์](../../../translated_images/th/lesson-9-thumbnail.38059e8af1a5b71d.webp)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(คลิกที่ภาพด้านบนเพื่อดูวิดีโอของบทเรียนนี้)_
# การรู้คิดในเอเจนต์ AI

## บทนำ

ยินดีต้อนรับสู่บทเรียนเกี่ยวกับการรู้คิดในเอเจนต์ AI! บทนี้ออกแบบมาสำหรับผู้เริ่มต้นที่อยากรู้ว่าเอเจนต์ AI จะคิดเกี่ยวกับกระบวนการคิดของตัวเองได้อย่างไร ในตอนท้ายของบทเรียนนี้ คุณจะเข้าใจแนวคิดสำคัญและมีตัวอย่างเชิงปฏิบัติเพื่อใช้การรู้คิดในการออกแบบเอเจนต์ AI

## เป้าหมายการเรียนรู้

หลังจากทำบทเรียนนี้เสร็จ คุณจะสามารถ:

1. เข้าใจผลกระทบของวงจรการให้เหตุผลในคำนิยามของเอเจนต์
2. ใช้เทคนิคการวางแผนและการประเมินเพื่อช่วยให้เอเจนต์สามารถแก้ไขตนเองได้
3. สร้างเอเจนต์ของคุณเองที่สามารถจัดการโค้ดเพื่อทำภารกิจให้สำเร็จ

## แนะนำการรู้คิด

การรู้คิดหมายถึงกระบวนการรับรู้ระดับสูงที่เกี่ยวข้องกับการคิดเกี่ยวกับการคิดของตนเอง สำหรับเอเจนต์ AI นี่หมายถึงความสามารถในการประเมินและปรับการกระทำของตนตามความตระหนักรู้ในตนเองและประสบการณ์ที่ผ่านมา การรู้คิด หรือ "การคิดเกี่ยวกับการคิด" เป็นแนวคิดสำคัญในการพัฒนาระบบเอเจนต์ิก AI ซึ่งเกี่ยวข้องกับระบบ AI ที่ตระหนักถึงกระบวนการภายในของตนเอง และสามารถตรวจสอบ ควบคุม และปรับพฤติกรรมของตนได้ คล้ายกับที่เราทำเมื่อเราสังเกตบรรยากาศหรือพิจารณาปัญหา การตระหนักรู้ในตนเองนี้สามารถช่วยให้ระบบ AI ตัดสินใจได้ดีขึ้น ระบุข้อผิดพลาด และปรับปรุงประสิทธิภาพเมื่อเวลาผ่านไป — ซึ่งเชื่อมโยงกลับไปยังการทดสอบทัวริงและการถกเถียงเกี่ยวกับว่า AI จะเข้ามาแทนที่หรือไม่

ในบริบทของระบบเอเจนต์ิก AI การรู้คิดสามารถช่วยแก้ปัญหาหลายประการ เช่น:
- ความโปร่งใส: ทำให้แน่ใจว่าระบบ AI สามารถอธิบายกระบวนการคิดและการตัดสินใจของตนได้
- การให้เหตุผล: เพิ่มความสามารถของระบบ AI ในการสังเคราะห์ข้อมูลและตัดสินใจอย่างมีเหตุผล
- การปรับตัว: อนุญาตให้ระบบ AI ปรับตัวเข้ากับสภาพแวดล้อมใหม่และเงื่อนไขที่เปลี่ยนแปลง
- การรับรู้: ปรับปรุงความแม่นยำของระบบ AI ในการจดจำและตีความข้อมูลจากสภาพแวดล้อม

### การรู้คิดคืออะไร?

การรู้คิด หรือ "การคิดเกี่ยวกับการคิด" เป็นกระบวนการรับรู้ระดับสูงที่เกี่ยวข้องกับการตระหนักรู้ในตนเองและการควบคุมกระบวนการรับรู้ของตนเอง ในวงการ AI การรู้คิดช่วยให้เอเจนต์สามารถประเมินและปรับกลยุทธ์และการกระทำของตนเอง นำไปสู่ความสามารถในการแก้ปัญหาและการตัดสินใจที่ดีขึ้น โดยการเข้าใจการรู้คิด คุณสามารถออกแบบเอเจนต์ AI ที่ไม่เพียงฉลาดขึ้น แต่ยังปรับตัวได้ดียิ่งขึ้นและมีประสิทธิภาพมากขึ้น ในการรู้คิดอย่างแท้จริง คุณจะเห็น AI ให้เหตุผลอย่างชัดเจนเกี่ยวกับการให้เหตุผลของตัวเอง

ตัวอย่าง: “ฉันให้ความสำคัญกับเที่ยวบินที่ถูกกว่าเพราะ… ฉันอาจพลาดเที่ยวบินตรง ดังนั้นขอเช็กอีกครั้ง”
ติดตามวิธีหรือเหตุผลที่เลือกเส้นทางหนึ่งๆ
- สังเกตว่ามันทำผิดพลาดเพราะพึ่งพาความชอบของผู้ใช้จากครั้งก่อนมากเกินไป ดังนั้นมันจึงปรับกลยุทธ์การตัดสินใจ ไม่ใช่แค่คำแนะนำสุดท้าย
- วินิจฉัยรูปแบบเช่น “เมื่อใดก็ตามที่ฉันเห็นผู้ใช้พูดว่า ‘คนแน่นเกินไป’ ฉันไม่ควรแค่ตัดสถานที่ท่องเที่ยวบางแห่งออก แต่ควรสะท้อนด้วยว่าวิธีการเลือก ‘สถานที่ยอดนิยม’ ของฉันมีปัญหา หากฉันจัดอันดับโดยความนิยมเสมอ”

### ความสำคัญของการรู้คิดในเอเจนต์ AI

![ความสำคัญของการรู้คิด](../../../translated_images/th/importance-of-metacognition.b381afe9aae352f7.webp)

- การสะท้อนตนเอง: เอเจนต์สามารถประเมินประสิทธิภาพของตนเองและระบุจุดที่ต้องปรับปรุง
- การปรับตัว: เอเจนต์สามารถปรับกลยุทธ์ตามประสบการณ์ที่ผ่านมาและสภาพแวดล้อมที่เปลี่ยนแปลง
- การแก้ไขข้อผิดพลาด: เอเจนต์สามารถตรวจพบและแก้ไขข้อผิดพลาดโดยอัตโนมัติ ทำให้ได้ผลลัพธ์ที่แม่นยำยิ่งขึ้น
- การจัดการทรัพยากร: เอเจนต์สามารถเพิ่มประสิทธิภาพการใช้ทรัพยากร เช่น เวลาและกำลังประมวลผล โดยการวางแผนและประเมินการกระทำของตน

## องค์ประกอบของเอเจนต์ AI

ก่อนที่จะดำดิ่งสู่กระบวนการรู้คิด จำเป็นต้องเข้าใจองค์ประกอบพื้นฐานของเอเจนต์ AI โดยทั่วไปเอเจนต์ AI ประกอบด้วย:

- บุคลิก (Persona): ลักษณะและคุณสมบัติของเอเจนต์ ซึ่งกำหนดวิธีที่มันโต้ตอบกับผู้ใช้
- เครื่องมือ (Tools): ความสามารถและฟังก์ชันที่เอเจนต์สามารถทำได้
- ทักษะ (Skills): ความรู้และความเชี่ยวชาญที่เอเจนต์มี

องค์ประกอบเหล่านี้ทำงานร่วมกันเพื่อสร้าง "หน่วยความเชี่ยวชาญ" ที่สามารถทำงานเฉพาะได้

**ตัวอย่าง**:
ลองพิจารณาตัวแทนท่องเที่ยว บริการเอเจนต์ที่ไม่เพียงแต่วางแผนวันหยุดของคุณ แต่ยังปรับเส้นทางตามข้อมูลเรียลไทม์และประสบการณ์การเดินทางของลูกค้าในอดีต

### ตัวอย่าง: การรู้คิดในบริการตัวแทนท่องเที่ยว

สมมติว่าคุณกำลังออกแบบบริการตัวแทนท่องเที่ยวที่ขับเคลื่อนด้วย AI เอเจนต์นี้ "ตัวแทนท่องเที่ยว" ช่วยผู้ใช้วางแผนวันหยุดของพวกเขา เพื่อผสานการรู้คิด ตัวแทนท่องเที่ยวจำเป็นต้องประเมินและปรับการกระทำของตัวเองตามความตระหนักในตนเองและประสบการณ์ที่ผ่านมา ต่อไปนี้คือวิธีที่การรู้คิดอาจมีบทบาท:

#### งานปัจจุบัน

งานปัจจุบันคือการช่วยผู้ใช้วางแผนทริปไปปารีส

#### ขั้นตอนในการทำงานให้เสร็จ

1. **รวบรวมความต้องการของผู้ใช้**: ถามผู้ใช้เกี่ยวกับวันที่เดินทาง งบประมาณ ความสนใจ (เช่น พิพิธภัณฑ์ อาหาร การช็อปปิง) และข้อกำหนดเฉพาะใดๆ
2. **ดึงข้อมูล**: ค้นหาตัวเลือกเที่ยวบิน ที่พัก สถานที่ท่องเที่ยว และร้านอาหารที่ตรงกับความต้องการของผู้ใช้
3. **สร้างคำแนะนำ**: ให้แผนการเดินทางที่ปรับตามบุคคลพร้อมรายละเอียดเที่ยวบิน การจองโรงแรม และกิจกรรมที่แนะนำ
4. **ปรับตามข้อเสนอแนะ**: ถามผู้ใช้ถึงข้อเสนอแนะเกี่ยวกับคำแนะนำและปรับตามที่จำเป็น

#### ทรัพยากรที่ต้องใช้

- การเข้าถึงฐานข้อมูลการจองเที่ยวบินและโรงแรม
- ข้อมูลเกี่ยวกับสถานที่ท่องเที่ยวและร้านอาหารในปารีส
- ข้อมูลข้อเสนอแนะจากผู้ใช้จากการโต้ตอบที่ผ่านมา

#### ประสบการณ์และการสะท้อนตนเอง

ตัวแทนท่องเที่ยวใช้การรู้คิดในการประเมินประสิทธิภาพและเรียนรู้จากประสบการณ์ที่ผ่านมา ตัวอย่างเช่น:

1. **วิเคราะห์ข้อเสนอแนะของผู้ใช้**: ตัวแทนท่องเที่ยวตรวจสอบข้อเสนอแนะของผู้ใช้เพื่อกำหนดว่าคำแนะนำใดได้รับการตอบรับดีและคำแนะนำใดไม่ดี จากนั้นปรับคำแนะนำในอนาคตตามนั้น
2. **การปรับตัว**: หากผู้ใช้เคยกล่าวว่าไม่ชอบสถานที่แออัด ตัวแทนท่องเที่ยวจะหลีกเลี่ยงการแนะนำจุดท่องเที่ยวยอดนิยมในช่วงชั่วโมงที่คนแน่นในอนาคต
3. **การแก้ไขข้อผิดพลาด**: หากตัวแทนท่องเที่ยวเคยแนะนำโรงแรมที่เต็มหมด มันจะเรียนรู้ที่จะตรวจสอบความพร้อมให้บริการอย่างเข้มงวดยิ่งขึ้นก่อนจะแนะนำ

#### ตัวอย่างสำหรับนักพัฒนา

นี่คือตัวอย่างที่เรียบง่ายของโค้ดตัวแทนท่องเที่ยวเมื่อผสานการรู้คิด:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # ค้นหาเที่ยวบิน โรงแรม และสถานที่ท่องเที่ยวตามความชอบ
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # วิเคราะห์ผลตอบรับและปรับคำแนะนำในอนาคต
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# ตัวอย่างการใช้งาน
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### ทำไมการรู้คิดจึงมีความสำคัญ

- **การสะท้อนตนเอง**: เอเจนต์สามารถวิเคราะห์ประสิทธิภาพของตนและระบุจุดที่ต้องปรับปรุง
- **การปรับตัว**: เอเจนต์สามารถปรับกลยุทธ์ตามข้อเสนอแนะและสภาพที่เปลี่ยนแปลง
- **การแก้ไขข้อผิดพลาด**: เอเจนต์สามารถตรวจพบและแก้ไขข้อผิดพลาดโดยอัตโนมัติ
- **การจัดการทรัพยากร**: เอเจนต์สามารถเพิ่มประสิทธิภาพการใช้ทรัพยากร เช่น เวลาและกำลังประมวลผล

โดยการผสานการรู้คิด ตัวแทนท่องเที่ยวสามารถให้คำแนะนำด้านการเดินทางที่ตรงตามบุคคลและแม่นยำมากขึ้น ช่วยยกระดับประสบการณ์ของผู้ใช้โดยรวม

---

## 2. การวางแผนในเอเจนต์

การวางแผนเป็นองค์ประกอบสำคัญของพฤติกรรมเอเจนต์ AI มันเกี่ยวข้องกับการวางขั้นตอนที่จำเป็นเพื่อบรรลุเป้าหมาย โดยพิจารณาสถานะปัจจุบัน ทรัพยากร และอุปสรรคที่อาจเกิดขึ้น

### องค์ประกอบของการวางแผน

- **งานปัจจุบัน**: กำหนดงานให้ชัดเจน
- **ขั้นตอนในการทำงานให้เสร็จ**: แยกงานออกเป็นขั้นตอนที่จัดการได้
- **ทรัพยากรที่ต้องใช้**: ระบุทรัพยากรที่จำเป็น
- **ประสบการณ์**: ใช้ประสบการณ์ที่ผ่านมาเพื่อประกอบการวางแผน

**ตัวอย่าง**:
นี่คือขั้นตอนที่ตัวแทนท่องเที่ยวต้องดำเนินการเพื่อช่วยผู้ใช้วางแผนทริปอย่างมีประสิทธิภาพ:

### ขั้นตอนสำหรับตัวแทนท่องเที่ยว

1. **รวบรวมความต้องการของผู้ใช้**
   - ถามผู้ใช้เกี่ยวกับรายละเอียดวันที่เดินทาง งบประมาณ ความสนใจ และข้อกำหนดเฉพาะ
   - ตัวอย่าง: "คุณวางแผนจะเดินทางเมื่อไหร่?" "ช่วงงบประมาณของคุณประมาณเท่าไหร่?" "กิจกรรมแบบไหนที่คุณชอบในวันหยุด?"

2. **ดึงข้อมูล**
   - ค้นหาตัวเลือกการเดินทางที่เกี่ยวข้องตามความต้องการของผู้ใช้
   - **เที่ยวบิน**: มองหาเที่ยวบินที่มีให้บริการภายในงบประมาณและวันที่ที่ผู้ใช้ต้องการ
   - **ที่พัก**: ค้นหาโรงแรมหรือที่พักเช่าเหมาะสมตามตำแหน่ง ราคา และสิ่งอำนวยความสะดวกที่ผู้ใช้ต้องการ
   - **สถานที่ท่องเที่ยวและร้านอาหาร**: ระบุสถานที่ท่องเที่ยว กิจกรรม และร้านอาหารที่สอดคล้องกับความสนใจของผู้ใช้

3. **สร้างคำแนะนำ**
   - รวบรวมข้อมูลที่ดึงมาเป็นแผนการเดินทางที่ปรับตามบุคคล
   - ให้รายละเอียด เช่น ตัวเลือกเที่ยวบิน การจองโรงแรม และกิจกรรมที่แนะนำ โดยปรับคำแนะนำให้ตรงกับความต้องการของผู้ใช้

4. **นำเสนอแผนการเดินทางให้ผู้ใช้**
   - แบ่งปันแผนการเดินทางที่เสนอให้ผู้ใช้ตรวจสอบ
   - ตัวอย่าง: "นี่คือแผนการเดินทางที่แนะนำสำหรับทริปไปปารีสของคุณ ประกอบด้วยรายละเอียดเที่ยวบิน การจองโรงแรม และรายการกิจกรรมและร้านอาหารที่แนะนำ แจ้งให้ฉันทราบความคิดเห็นของคุณได้เลย!"

5. **เก็บข้อเสนอแนะ**
   - ถามผู้ใช้เกี่ยวกับข้อเสนอแนะต่อแผนการเดินทางที่เสนอ
   - ตัวอย่าง: "คุณชอบตัวเลือกเที่ยวบินไหม?" "โรงแรมนี้เหมาะกับความต้องการของคุณหรือไม่?" "มีกิจกรรมใดที่คุณอยากเพิ่มหรือลบออกไหม?"

6. **ปรับตามข้อเสนอแนะ**
   - ปรับแผนการเดินทางตามข้อเสนอแนะของผู้ใช้
   - ทำการเปลี่ยนแปลงที่จำเป็นกับคำแนะนำเที่ยวบิน ที่พัก และกิจกรรมเพื่อให้ตรงกับความต้องการของผู้ใช้มากขึ้น

7. **ยืนยันสุดท้าย**
   - นำเสนอแผนการเดินทางที่อัปเดตให้ผู้ใช้เพื่อยืนยันครั้งสุดท้าย
   - ตัวอย่าง: "ฉันได้ปรับตามข้อเสนอแนะของคุณแล้ว นี่คือแผนการเดินทางที่อัปเดต ดูเรียบร้อยดีไหม?"

8. **จองและยืนยันการสำรอง**
   - เมื่อผู้ใช้อนุมัติแผน ให้ดำเนินการจองเที่ยวบิน ที่พัก และกิจกรรมที่วางแผนไว้
   - ส่งรายละเอียดการยืนยันให้ผู้ใช้

9. **ให้การสนับสนุนอย่างต่อเนื่อง**
   - พร้อมช่วยเหลือผู้ใช้ในกรณีที่มีการเปลี่ยนแปลงหรือคำขอเพิ่มเติมทั้งก่อนและระหว่างการเดินทาง
   - ตัวอย่าง: "หากคุณต้องการความช่วยเหลือเพิ่มเติมระหว่างการเดินทาง ติดต่อฉันได้ตลอดเวลา!"

### ตัวอย่างการโต้ตอบ

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# ตัวอย่างการใช้งานภายในคำขอการโห่
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. ระบบ RAG แบบแก้ไข

Firstly let's start by understanding the difference between RAG Tool and Pre-emptive Context Load

![RAG เทียบกับการโหลดบริบท](../../../translated_images/th/rag-vs-context.9eae588520c00921.webp)

### Retrieval-Augmented Generation (RAG)

RAG ผสานระบบการสืบค้นเข้ากับโมเดลเชิงสร้าง เมื่อมีการสอบถาม ระบบการสืบค้นจะดึงเอกสารหรือข้อมูลที่เกี่ยวข้องจากแหล่งภายนอก และข้อมูลที่ดึงมานั้นจะถูกใช้เพื่อเสริมเข้าไปในอินพุตของโมเดลเชิงสร้าง วิธีนี้ช่วยให้โมเดลสร้างคำตอบที่แม่นยำและสอดคล้องกับบริบทมากขึ้น

ในระบบ RAG เอเจนต์จะดึงข้อมูลที่เกี่ยวข้องจากฐานความรู้และใช้เพื่อสร้างคำตอบหรือการกระทำที่เหมาะสม

### แนวทาง Corrective RAG

แนวทาง Corrective RAG มุ่งเน้นการใช้เทคนิค RAG เพื่อแก้ไขข้อผิดพลาดและปรับปรุงความแม่นยำของเอเจนต์ AI ซึ่งรวมถึง:

1. **เทคนิคการกระตุ้น (Prompting Technique)**: ใช้พรอมต์เฉพาะเพื่อชี้นำเอเจนต์ในการดึงข้อมูลที่เกี่ยวข้อง
2. **เครื่องมือ (Tool)**: นำอัลกอริทึมและกลไกที่ช่วยให้เอเจนต์ประเมินความเกี่ยวข้องของข้อมูลที่ดึงมาและสร้างคำตอบที่แม่นยำ
3. **การประเมิน (Evaluation)**: ประเมินประสิทธิภาพของเอเจนต์อย่างต่อเนื่องและปรับปรุงเพื่อเพิ่มความถูกต้องและประสิทธิภาพ

#### ตัวอย่าง: Corrective RAG ในเอเจนต์ค้นหา

ลองพิจารณาเอเจนต์ค้นหาที่ดึงข้อมูลจากเว็บเพื่อตอบคำถามของผู้ใช้ แนวทาง Corrective RAG อาจรวมถึง:

1. **เทคนิคการกระตุ้น**: สร้างคำค้นหาโดยอิงจากอินพุตของผู้ใช้
2. **เครื่องมือ**: ใช้การประมวลผลภาษาธรรมชาติและอัลกอริทึมการเรียนรู้ของเครื่องเพื่อจัดอันดับและกรองผลการค้นหา
3. **การประเมิน**: วิเคราะห์ข้อเสนอแนะจากผู้ใช้เพื่อตรวจหาจุดที่ไม่ถูกต้องในข้อมูลที่ดึงมาและแก้ไข

### Corrective RAG ในตัวแทนท่องเที่ยว

Corrective RAG (Retrieval-Augmented Generation) ช่วยเพิ่มความสามารถของ AI ในการดึงและสร้างข้อมูลพร้อมกับการแก้ไขความไม่ถูกต้อง ลองดูว่าตัวแทนท่องเที่ยวสามารถใช้แนวทาง Corrective RAG เพื่อให้คำแนะนำการเดินทางที่แม่นยำและสอดคล้องได้อย่างไร

สิ่งนี้รวมถึง:

- **เทคนิคการกระตุ้น:** ใช้พรอมต์เฉพาะเพื่อชี้นำเอเจนต์ให้ดึงข้อมูลที่เกี่ยวข้อง
- **เครื่องมือ:** นำอัลกอริทึมและกลไกมาใช้เพื่อให้เอเจนต์ประเมินความเกี่ยวข้องของข้อมูลที่ดึงมาและสร้างคำตอบที่แม่นยำ
- **การประเมิน:** ประเมินประสิทธิภาพของเอเจนต์อย่างต่อเนื่องและปรับปรุงเพื่อเพิ่มความถูกต้องและประสิทธิภาพ

#### ขั้นตอนสำหรับการนำ Corrective RAG ไปใช้ในตัวแทนท่องเที่ยว

1. **การโต้ตอบเริ่มต้นกับผู้ใช้**
   - ตัวแทนท่องเที่ยวรวบรวมความต้องการเริ่มต้นจากผู้ใช้ เช่น ปลายทาง วันที่เดินทาง งบประมาณ และความสนใจ
   - ตัวอย่าง:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **การดึงข้อมูล**
   - ตัวแทนท่องเที่ยวดึงข้อมูลเกี่ยวกับเที่ยวบิน ที่พัก สถานที่ท่องเที่ยว และร้านอาหารตามความต้องการของผู้ใช้
   - ตัวอย่าง:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **การสร้างคำแนะนำเริ่มต้น**
   - ตัวแทนท่องเที่ยวใช้ข้อมูลที่ดึงมาเพื่อสร้างแผนการเดินทางที่ปรับตามบุคคล
   - ตัวอย่าง:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **การเก็บข้อเสนอแนะจากผู้ใช้**
   - ตัวแทนท่องเที่ยวขอความคิดเห็นจากผู้ใช้เกี่ยวกับคำแนะนำเริ่มต้น
   - ตัวอย่าง:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **กระบวนการ Corrective RAG**
   - **เทคนิคการกระตุ้น**: ตัวแทนท่องเที่ยวสร้างคำค้นหาใหม่ตามข้อเสนอแนะของผู้ใช้
     - ตัวอย่าง:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **เครื่องมือ**: ตัวแทนท่องเที่ยวใช้กลไกเพื่อจัดอันดับและกรองผลการค้นหาใหม่ โดยเน้นความเกี่ยวข้องตามข้อเสนอแนะของผู้ใช้
     - ตัวอย่าง:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **การประเมิน**: ตัวแทนท่องเที่ยวประเมินความเกี่ยวข้องและความถูกต้องของคำแนะนำอย่างต่อเนื่องโดยวิเคราะห์ข้อเสนอแนะจากผู้ใช้และปรับเปลี่ยนตามที่จำเป็น
     - ตัวอย่าง:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### ตัวอย่างเชิงปฏิบัติ

นี่คือตัวอย่างโค้ด Python แบบเรียบง่ายที่ผนวกแนวทาง Corrective RAG ในตัวแทนท่องเที่ยว:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# ตัวอย่างการใช้งาน
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### การโหลดบริบทเชิงป้องกัน (Pre-emptive Context Load)
Pre-emptive Context Load เกี่ยวข้องกับการโหลดบริบทหรือข้อมูลพื้นหลังที่เกี่ยวข้องเข้าสู่โมเดลก่อนที่จะประมวลผลคำถาม ซึ่งหมายความว่าโมเดลสามารถเข้าถึงข้อมูลนี้ตั้งแต่เริ่มต้น ซึ่งช่วยให้สามารถสร้างคำตอบที่มีข้อมูลมากขึ้นโดยไม่ต้องดึงข้อมูลเพิ่มเติมในระหว่างกระบวนการ

นี่คือตัวอย่างที่เรียบง่ายของวิธีที่การโหลดบริบทเชิงป้องกันล่วงหน้าอาจมีลักษณะสำหรับแอปพลิเคชันตัวแทนท่องเที่ยวใน Python:

```python
class TravelAgent:
    def __init__(self):
        # เตรียมข้อมูลปลายทางยอดนิยมไว้ล่วงหน้า
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # ดึงข้อมูลปลายทางจากบริบทที่เตรียมไว้ล่วงหน้า
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# ตัวอย่างการใช้งาน
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### คำอธิบาย

1. **การเริ่มต้น (`__init__` method)**: คลาส `TravelAgent` โหลดพจนานุกรมที่มีข้อมูลเกี่ยวกับจุดหมายยอดนิยมเช่น Paris, Tokyo, New York, และ Sydney ล่วงหน้า พจนานุกรมนี้รวมรายละเอียดเช่นประเทศ สกุลเงิน ภาษา และสถานที่ท่องเที่ยวสำคัญสำหรับแต่ละจุดหมาย

2. **การดึงข้อมูล (`get_destination_info` method)**: เมื่อผู้ใช้สอบถามเกี่ยวกับจุดหมายเฉพาะ วิธีการ `get_destination_info` จะดึงข้อมูลที่เกี่ยวข้องจากพจนานุกรมบริบทที่โหลดล่วงหน้า

โดยการโหลดบริบทล่วงหน้า แอปตัวแทนท่องเที่ยวสามารถตอบคำถามของผู้ใช้ได้อย่างรวดเร็วโดยไม่ต้องดึงข้อมูลจากแหล่งภายนอกแบบเรียลไทม์ ซึ่งทำให้แอปมีประสิทธิภาพและตอบสนองได้ดีขึ้น

### Bootstrapping the Plan with a Goal Before Iterating

การบูตสแตรปแผนด้วยเป้าหมายเกี่ยวข้องกับการเริ่มต้นด้วยวัตถุประสงค์หรือผลลัพธ์ที่ชัดเจนตั้งแต่ต้น โดยการกำหนดเป้าหมายนี้ล่วงหน้า โมเดลสามารถใช้มันเป็นหลักการชี้นำตลอดกระบวนการเชิงวนซ้ำ ช่วยให้แต่ละรอบของการปรับปรุงเคลื่อนที่ไปใกล้เป้าหมายที่ต้องการมากขึ้น ทำให้กระบวนการมีประสิทธิภาพและมีโฟกัสมากขึ้น

นี่คือตัวอย่างวิธีที่คุณอาจบูตสแตรปแผนการเดินทางด้วยเป้าหมายก่อนการวนซ้ำสำหรับตัวแทนท่องเที่ยวใน Python:

### สถานการณ์

ตัวแทนท่องเที่ยวต้องการวางแผนวันหยุดที่ปรับแต่งสำหรับลูกค้า เป้าหมายคือการสร้างแผนการเดินทางที่เพิ่มความพึงพอใจของลูกค้ามากที่สุดตามความชอบและงบประมาณของพวกเขา

### ขั้นตอน

1. กำหนดความชอบและงบประมาณของลูกค้า
2. บูตสแตรปแผนเริ่มต้นตามความชอบเหล่านี้
3. วนซ้ำเพื่อปรับปรุงแผน โดยเพิ่มประสิทธิภาพตามความพึงพอใจของลูกค้า

#### Python Code

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# ตัวอย่างการใช้งาน
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### คำอธิบายของโค้ด

1. **การเริ่มต้น (`__init__` method)**: คลาส `TravelAgent` ถูกเริ่มต้นด้วยรายการจุดหมายที่เป็นไปได้แต่ละรายการมีคุณลักษณะเช่นชื่อ ค่าใช้จ่าย และประเภทกิจกรรม

2. **การบูตสแตรปแผน (`bootstrap_plan` method)**: วิธีนี้สร้างแผนการเดินทางเริ่มต้นตามความชอบและงบประมาณของลูกค้า มันวนผ่านรายการจุดหมายและเพิ่มพวกมันเข้าสู่แผนหากพวกมันตรงกับความชอบของลูกค้าและพอดีกับงบประมาณ

3. **การจับคู่ความชอบ (`match_preferences` method)**: วิธีนี้ตรวจสอบว่าจุดหมายนั้นตรงกับความชอบของลูกค้าหรือไม่

4. **การวนซ้ำแผน (`iterate_plan` method)**: วิธีนี้ปรับปรุงแผนเริ่มต้นโดยพยายามแทนที่แต่ละจุดหมายในแผนด้วยตัวเลือกที่ดีกว่า โดยคำนึงถึงความชอบของลูกค้าและข้อจำกัดด้านงบประมาณ

5. **การคำนวณค่าใช้จ่าย (`calculate_cost` method)**: วิธีนี้คำนวณต้นทุนรวมของแผนปัจจุบัน รวมถึงจุดหมายใหม่ที่เป็นไปได้

#### ตัวอย่างการใช้งาน

- **แผนเริ่มต้น**: ตัวแทนท่องเที่ยวสร้างแผนเริ่มต้นตามความชอบของลูกค้าที่ชอบการเที่ยวชมสถานที่และมีงบประมาณ $2000
- **แผนที่ปรับปรุงแล้ว**: ตัวแทนท่องเที่ยววนซ้ำแผน ปรับแต่งให้เหมาะสมกับความชอบและงบประมาณของลูกค้า

โดยการบูตสแตรปแผนด้วยเป้าหมายที่ชัดเจน (เช่น เพิ่มความพึงพอใจของลูกค้ามากที่สุด) และวนซ้ำเพื่อปรับปรุง ตัวแทนท่องเที่ยวสามารถสร้างแผนการเดินทางที่ปรับแต่งและเพิ่มประสิทธิภาพได้ วิธีนี้ช่วยให้แผนการเดินทางสอดคล้องกับความชอบและงบประมาณของลูกค้าตั้งแต่ต้นและพัฒนาขึ้นในแต่ละรอบ

### Taking Advantage of LLM for Re-ranking and Scoring

โมเดลภาษาใหญ่ (LLMs) สามารถใช้สำหรับการจัดลำดับใหม่และการให้คะแนนโดยประเมินความเกี่ยวข้องและคุณภาพของเอกสารที่ดึงมา หรือคำตอบที่สร้างขึ้น วิธีการทำงานมีดังนี้:

**การดึงข้อมูล:** ขั้นตอนการดึงข้อมูลเริ่มต้นจะดึงชุดเอกสารหรือคำตอบที่เป็นผู้สมัครตามคำค้น

**การจัดลำดับใหม่:** LLM จะประเมินผู้สมัครเหล่านี้และจัดลำดับใหม่ตามความเกี่ยวข้องและคุณภาพ ขั้นตอนนี้ช่วยให้มั่นใจได้ว่าข้อมูลที่เกี่ยวข้องและมีคุณภาพสูงสุดจะถูกนำเสนอเป็นอันดับแรก

**การให้คะแนน:** LLM จะกำหนดคะแนนให้กับแต่ละผู้สมัครสะท้อนความเกี่ยวข้องและคุณภาพของพวกเขา ซึ่งช่วยในการเลือกคำตอบหรือเอกสารที่ดีที่สุดให้กับผู้ใช้

โดยการใช้ LLM สำหรับการจัดลำดับใหม่และการให้คะแนน ระบบสามารถให้ข้อมูลที่ถูกต้องและสอดคล้องกับบริบทได้มากขึ้น ส่งเสริมประสบการณ์ผู้ใช้โดยรวม

นี่คือตัวอย่างว่าตัวแทนท่องเที่ยวอาจใช้โมเดลภาษาใหญ่ (LLM) สำหรับการจัดลำดับใหม่และการให้คะแนนจุดหมายการเดินทางตามความชอบของผู้ใช้ใน Python:

#### สถานการณ์ - การเดินทางตามความชอบ

ตัวแทนท่องเที่ยวต้องการแนะนำจุดหมายที่ดีที่สุดให้กับลูกค้าตามความชอบของพวกเขา LLM จะช่วยจัดลำดับใหม่และให้คะแนนจุดหมายเพื่อให้แน่ใจว่าได้ตัวเลือกที่เกี่ยวข้องที่สุด

#### ขั้นตอน:

1. รวบรวมความชอบของผู้ใช้
2. ดึงรายการจุดหมายการเดินทางที่เป็นไปได้
3. ใช้ LLM เพื่อจัดลำดับใหม่และให้คะแนนจุดหมายตามความชอบของผู้ใช้

นี่คือวิธีที่คุณสามารถอัปเดตก่อนหน้านี้เพื่อใช้บริการ Azure OpenAI:

#### ความต้องการ

1. คุณต้องมีการสมัครสมาชิก Azure
2. สร้างทรัพยากร Azure OpenAI และรับคีย์ API ของคุณ

#### ตัวอย่างโค้ด Python

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # สร้างพรอมต์สำหรับ Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # กำหนดส่วนหัวและเพย์โหลดสำหรับคำขอ
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # เรียกใช้ Azure OpenAI API เพื่อรับรายการปลายทางที่จัดอันดับใหม่และมีคะแนน
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # ดึงและคืนคำแนะนำ
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# ตัวอย่างการใช้งาน
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### คำอธิบายของโค้ด - Preference Booker

1. **การเริ่มต้น**: คลาส `TravelAgent` ถูกเริ่มต้นด้วยรายการจุดหมายการเดินทางที่เป็นไปได้แต่ละรายการมีคุณลักษณะเช่นชื่อและคำอธิบาย

2. **การขอคำแนะนำ (`get_recommendations` method)**: วิธีนี้สร้าง prompt สำหรับบริการ Azure OpenAI ตามความชอบของผู้ใช้และทำคำขอ HTTP POST ไปยัง API ของ Azure OpenAI เพื่อรับจุดหมายที่ถูกจัดลำดับใหม่และให้คะแนน

3. **การสร้าง Prompt (`generate_prompt` method)**: วิธีนี้สร้าง prompt สำหรับ Azure OpenAI รวมถึงความชอบของผู้ใช้และรายการจุดหมาย Prompt นี้จะชี้นำโมเดลให้จัดลำดับใหม่และให้คะแนนจุดหมายตามความชอบที่ให้มา

4. **การเรียก API**: ไลบรารี `requests` ถูกใช้เพื่อทำคำขอ HTTP POST ไปยัง endpoint ของ Azure OpenAI การตอบกลับจะมีจุดหมายที่ถูกจัดลำดับใหม่และให้คะแนน

5. **ตัวอย่างการใช้งาน**: ตัวแทนท่องเที่ยวรวบรวมความชอบของผู้ใช้ (เช่น สนใจการเที่ยวชมสถานที่และวัฒนธรรมที่หลากหลาย) และใช้บริการ Azure OpenAI เพื่อรับคำแนะนำที่ถูกจัดลำดับใหม่และให้คะแนนสำหรับจุดหมายการเดินทาง

ตรวจสอบให้แน่ใจว่าได้แทนที่ `your_azure_openai_api_key` ด้วยคีย์ Azure OpenAI ที่แท้จริงของคุณ และ `https://your-endpoint.com/...` ด้วย URL endpoint จริงของการปรับใช้ Azure OpenAI ของคุณ

โดยการใช้ LLM สำหรับการจัดลำดับใหม่และการให้คะแนน ตัวแทนท่องเที่ยวสามารถให้คำแนะนำที่เป็นส่วนตัวและเกี่ยวข้องมากขึ้นแก่ลูกค้า ปรับปรุงประสบการณ์โดยรวม

### RAG: Prompting Technique vs Tool

Retrieval-Augmented Generation (RAG) สามารถเป็นได้ทั้งเทคนิคการสร้าง prompt และเครื่องมือในการพัฒนาเอเจนต์ AI การเข้าใจความแตกต่างระหว่างทั้งสองสามารถช่วยให้คุณใช้ RAG ได้อย่างมีประสิทธิภาพมากขึ้นในโครงการของคุณ

#### RAG ในฐานะเทคนิคการสร้าง Prompt

**มันคืออะไร?**

- ในฐานะเทคนิคการสร้าง prompt, RAG เกี่ยวข้องกับการกำหนดคำถามหรือ prompt เฉพาะเพื่อชี้นำการดึงข้อมูลที่เกี่ยวข้องจากคอร์ปัสหรือฐานข้อมูลขนาดใหญ่ ข้อมูลนี้จะถูกนำไปใช้ในการสร้างคำตอบหรือการกระทำ

**มันทำงานอย่างไร:**

1. **กำหนด Prompt**: สร้าง prompt หรือตัวถามที่มีโครงสร้างดีตามงานหรือตามข้อมูลจากผู้ใช้
2. **ดึงข้อมูล**: ใช้ prompt เพื่อค้นหาข้อมูลที่เกี่ยวข้องจากฐานความรู้หรือชุดข้อมูลที่มีอยู่
3. **สร้างคำตอบ**: ผสานข้อมูลที่ดึงมาเข้ากับโมเดลสร้างสรรค์เพื่อผลิตคำตอบที่ครอบคลุมและต่อเนื่อง

**ตัวอย่างในตัวแทนท่องเที่ยว**:

- ข้อความจากผู้ใช้: "I want to visit museums in Paris."
- Prompt: "Find top museums in Paris."
- ข้อมูลที่ดึงมา: รายละเอียดเกี่ยวกับ Louvre Museum, Musée d'Orsay เป็นต้น
- คำตอบที่สร้าง: "Here are some top museums in Paris: Louvre Museum, Musée d'Orsay, and Centre Pompidou."

#### RAG ในฐานะเครื่องมือ

**มันคืออะไร?**

- ในฐานะเครื่องมือ RAG เป็นระบบแบบบูรณาการที่ทำให้อัตโนมัติการดึงและการสร้างผลลัพธ์ ช่วยให้นักพัฒนาสามารถใช้งานฟังก์ชัน AI ที่ซับซ้อนได้ง่ายขึ้นโดยไม่ต้องสร้าง prompt ด้วยมือสำหรับทุกคำถาม

**มันทำงานอย่างไร:**

1. **การรวมเข้าด้วยกัน**: ฝัง RAG ภายในสถาปัตยกรรมของเอเจนต์ AI ให้มันจัดการการดึงและการสร้างผลลัพธ์โดยอัตโนมัติ
2. **การอัตโนมัติ**: เครื่องมือจัดการกระบวนการทั้งหมด ตั้งแต่รับอินพุตของผู้ใช้จนถึงการสร้างคำตอบสุดท้าย โดยไม่ต้องมี prompt เฉพาะสำหรับแต่ละขั้นตอน
3. **ประสิทธิภาพ**: เพิ่มประสิทธิภาพของเอเจนต์โดยการทำให้กระบวนการดึงและการสร้างราบรื่นยิ่งขึ้น ทำให้ตอบสนองได้เร็วขึ้นและแม่นยำขึ้น

**ตัวอย่างในตัวแทนท่องเที่ยว**:

- ข้อความจากผู้ใช้: "I want to visit museums in Paris."
- เครื่องมือ RAG: ดึงข้อมูลเกี่ยวกับพิพิธภัณฑ์โดยอัตโนมัติและสร้างคำตอบ
- คำตอบที่สร้าง: "Here are some top museums in Paris: Louvre Museum, Musée d'Orsay, and Centre Pompidou."

### Comparison

| Aspect                 | Prompting Technique                                        | Tool                                                  |
|------------------------|-------------------------------------------------------------|-------------------------------------------------------|
| **Manual vs Automatic**| การสร้าง prompt ด้วยมือสำหรับแต่ละคำถาม                          | กระบวนการอัตโนมัติสำหรับการดึงและการสร้างผลลัพธ์         |
| **Control**            | ให้การควบคุมกระบวนการดึงข้อมูลมากขึ้น                         | ทำให้การดึงและการสร้างเป็นไปอย่างราบรื่นและอัตโนมัติ      |
| **Flexibility**        | อนุญาตให้ปรับแต่ง prompt ตามความต้องการเฉพาะได้               | มีประสิทธิภาพมากขึ้นสำหรับการใช้งานในระดับใหญ่            |
| **Complexity**         | ต้องสร้างและปรับแต่ง prompt อยู่เสมอ                         | ง่ายต่อการรวมเข้ากับสถาปัตยกรรมของเอเจนต์ AI             |

### Practical Examples

**Prompting Technique Example:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**Tool Example:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### Evaluating Relevancy

การประเมินความเกี่ยวข้องเป็นแง่มุมสำคัญของประสิทธิภาพเอเจนต์ AI มันช่วยให้แน่ใจว่าข้อมูลที่ถูกดึงมาและสร้างโดยเอเจนต์นั้นเหมาะสม ถูกต้อง และเป็นประโยชน์ต่อผู้ใช้ มาดูวิธีการประเมินความเกี่ยวข้องในเอเจนต์ AI รวมถึงตัวอย่างเชิงปฏิบัติและเทคนิคต่างๆ

#### แนวคิดสำคัญในการประเมินความเกี่ยวข้อง

1. **การตระหนักถึงบริบท**:
   - เอเจนต์ต้องเข้าใจบริบทของคำถามของผู้ใช้เพื่อดึงและสร้างข้อมูลที่เกี่ยวข้อง
   - ตัวอย่าง: หากผู้ใช้ถามหา "best restaurants in Paris" เอเจนต์ควรพิจารณาความชอบของผู้ใช้ เช่น ประเภทอาหารและงบประมาณ

2. **ความถูกต้อง**:
   - ข้อมูลที่เอเจนต์ให้ควรเป็นความจริงและเป็นปัจจุบัน
   - ตัวอย่าง: แนะนำร้านอาหารที่เปิดอยู่ในปัจจุบันและมีรีวิวดี แทนที่จะเป็นตัวเลือกที่ล้าสมัยหรือปิดแล้ว

3. **เจตนารมณ์ของผู้ใช้**:
   - เอเจนต์ควรตีความเจตนารมณ์ของผู้ใช้เบื้องหลังคำถามเพื่อให้ข้อมูลที่เกี่ยวข้องที่สุด
   - ตัวอย่าง: หากผู้ใช้ถามหา "budget-friendly hotels" เอเจนต์ควรจัดลำดับตัวเลือกที่ประหยัดเป็นหลัก

4. **วงจรป้อนกลับ**:
   - การเก็บและวิเคราะห์ความคิดเห็นของผู้ใช้อย่างต่อเนื่องช่วยให้เอเจนต์ปรับปรุงกระบวนการประเมินความเกี่ยวข้อง
   - ตัวอย่าง: นำคะแนนและความคิดเห็นของผู้ใช้เกี่ยวกับคำแนะนำก่อนหน้านี้มาปรับปรุงคำตอบในอนาคต

#### เทคนิคเชิงปฏิบัติในการประเมินความเกี่ยวข้อง

1. **การให้คะแนนความเกี่ยวข้อง**:
   - กำหนดคะแนนความเกี่ยวข้องให้กับแต่ละรายการที่ดึงมาโดยอิงจากความสอดคล้องกับคำถามและความชอบของผู้ใช้
   - ตัวอย่าง:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **การกรองและการจัดอันดับ**:
   - กรองรายการที่ไม่เกี่ยวข้องออกและจัดอันดับรายการที่เหลือตามคะแนนความเกี่ยวข้อง
   - ตัวอย่าง:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # ส่งคืน 10 รายการที่เกี่ยวข้องที่สุด
     ```

3. **การประมวลผลภาษาธรรมชาติ (NLP)**:
   - ใช้เทคนิค NLP เพื่อเข้าใจคำถามภาษาธรรมชาติของผู้ใช้และดึงข้อมูลที่เกี่ยวข้อง
   - ตัวอย่าง:

     ```python
     def process_query(query):
         # ใช้การประมวลผลภาษาธรรมชาติเพื่อสกัดข้อมูลสำคัญจากคำถามของผู้ใช้
         processed_query = nlp(query)
         return processed_query
     ```

4. **การผนวกความคิดเห็นของผู้ใช้**:
   - เก็บความคิดเห็นจากผู้ใช้เกี่ยวกับคำแนะนำที่ให้และใช้ข้อมูลนั้นในการปรับการประเมินความเกี่ยวข้องในอนาคต
   - ตัวอย่าง:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### ตัวอย่าง: การประเมินความเกี่ยวข้องในตัวแทนท่องเที่ยว

นี่คือตัวอย่างเชิงปฏิบัติของวิธีที่ตัวแทนท่องเที่ยวสามารถประเมินความเกี่ยวข้องของคำแนะนำการเดินทาง:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # คืน 10 รายการที่เกี่ยวข้องมากที่สุด

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# ตัวอย่างการใช้งาน
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### Search with Intent

การค้นหาด้วยเจตนารมณ์เกี่ยวข้องกับการเข้าใจและตีความวัตถุประสงค์หรือเป้าหมายเบื้องหลังคำถามของผู้ใช้เพื่อดึงและสร้างข้อมูลที่เกี่ยวข้องและมีประโยชน์ที่สุด วิธีนี้ไปไกลกว่าการจับคีย์เวิร์ดเพียงอย่างเดียวและมุ่งเน้นที่การเข้าใจความต้องการที่แท้จริงและบริบทของผู้ใช้

#### แนวคิดสำคัญในการค้นหาด้วยเจตนารมณ์

1. **การเข้าใจเจตนารมณ์ของผู้ใช้**:
   - เจตนารมณ์ของผู้ใช้สามารถจัดหมวดเป็นสามประเภทหลัก: ข้อมูล (informational), นำทาง (navigational), และธุรกรรม (transactional)
     - **เจตนารมณ์เชิงข้อมูล**: ผู้ใช้ต้องการข้อมูลเกี่ยวกับหัวข้อ (เช่น "What are the best museums in Paris?")
     - **เจตนารมณ์เชิงนำทาง**: ผู้ใช้ต้องการไปยังเว็บไซต์หรือหน้าที่เฉพาะ (เช่น "Louvre Museum official website")
     - **เจตนารมณ์เชิงธุรกรรม**: ผู้ใช้มีเป้าหมายในการทำธุรกรรม เช่น การจองเที่ยวบินหรือการซื้อของ (เช่น "Book a flight to Paris")

2. **การตระหนักถึงบริบท**:
   - การวิเคราะห์บริบทของคำถามของผู้ใช้ช่วยให้ระบุเจตนารมณ์ได้อย่างแม่นยำ ซึ่งรวมถึงการพิจารณาการโต้ตอบก่อนหน้า ความชอบของผู้ใช้ และรายละเอียดเฉพาะของคำถามปัจจุบัน

3. **การประมวลผลภาษาธรรมชาติ (NLP)**:
   - ใช้เทคนิค NLP เพื่อเข้าใจและตีความคำถามภาษาธรรมชาติที่ผู้ใช้ป้อน ซึ่งรวมถึงงานอย่างการจดจำเอนทิตี้ การวิเคราะห์ความรู้สึก และการแยกวิเคราะห์คำถาม

4. **การปรับให้เป็นส่วนบุคคล**:
   - ปรับผลการค้นหาตามประวัติ ความชอบ และความคิดเห็นของผู้ใช้ เพื่อเพิ่มความเกี่ยวข้องของข้อมูลที่ดึงมา

#### ตัวอย่างเชิงปฏิบัติ: การค้นหาด้วยเจตนารมณ์ในตัวแทนท่องเที่ยว

มาดูตัวอย่างว่า Travel Agent สามารถนำการค้นหาด้วยเจตนารมณ์ไปใช้ได้อย่างไร

1. **การรวบรวมความชอบของผู้ใช้**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **การเข้าใจเจตนารมณ์ของผู้ใช้**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **การตระหนักถึงบริบท**
   ```python
   def analyze_context(query, user_history):
       # รวมคำค้นหาปัจจุบันกับประวัติผู้ใช้เพื่อเข้าใจบริบท
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **ค้นหาและปรับผลลัพธ์ให้เป็นส่วนตัว**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # ตัวอย่างตรรกะการค้นหาสำหรับเจตนาหาข้อมูล
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # ตัวอย่างตรรกะการค้นหาสำหรับเจตนานำทาง
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # ตัวอย่างตรรกะการค้นหาสำหรับเจตนาเชิงธุรกรรม
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # ตัวอย่างตรรกะการปรับแต่งส่วนบุคคล
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # ส่งคืนผลลัพธ์ที่ปรับแต่ง 10 อันดับแรก
   ```

5. **ตัวอย่างการใช้งาน**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. การสร้างโค้ดเป็นเครื่องมือ

เอเจนต์ที่สร้างโค้ดใช้โมเดล AI เพื่อเขียนและรันโค้ด แก้ปัญหาที่ซับซ้อน และทำงานอัตโนมัติ

### เอเจนต์ผู้สร้างโค้ด

เอเจนต์ผู้สร้างโค้ดใช้โมเดลปัญญาประดิษฐ์เชิงกำเนิดเพื่อเขียนและรันโค้ด เอเจนต์เหล่านี้สามารถแก้ปัญหาที่ซับซ้อน ทำงานอัตโนมัติ และให้ข้อมูลเชิงลึกอันมีค่าโดยการสร้างและรันโค้ดในภาษาการเขียนโปรแกรมต่าง ๆ

#### การประยุกต์ใช้งานเชิงปฏิบัติ

1. **การสร้างโค้ดอัตโนมัติ**: สร้างสคริปต์โค้ดสำหรับงานเฉพาะ เช่น การวิเคราะห์ข้อมูล การดึงข้อมูลเว็บ หรือการเรียนรู้ของเครื่อง
2. **SQL ในฐานะ RAG**: ใช้คำสั่ง SQL เพื่อดึงและจัดการข้อมูลจากฐานข้อมูล
3. **การแก้ปัญหา**: สร้างและรันโค้ดเพื่อแก้ปัญหาเฉพาะ เช่น การปรับปรุงอัลกอริธึมหรือการวิเคราะห์ข้อมูล

#### ตัวอย่าง: เอเจนต์ผู้สร้างโค้ดสำหรับการวิเคราะห์ข้อมูล

สมมติว่าคุณกำลังออกแบบเอเจนต์ผู้สร้างโค้ด นี่คือวิธีการทำงานที่เป็นไปได้:

1. **งานที่ต้องทำ**: วิเคราะห์ชุดข้อมูลเพื่อระบุแนวโน้มและรูปแบบ
2. **ขั้นตอน**:
   - โหลดชุดข้อมูลเข้าสู่เครื่องมือวิเคราะห์ข้อมูล
   - สร้างคำสั่ง SQL เพื่อกรองและรวมข้อมูล
   - รันคำสั่งและดึงผลลัพธ์
   - ใช้ผลลัพธ์เพื่อสร้างภาพแสดงข้อมูลและข้อสรุป
3. **ทรัพยากรที่ต้องการ**: การเข้าถึงชุดข้อมูล เครื่องมือวิเคราะห์ข้อมูล และความสามารถในการใช้ SQL
4. **ประสบการณ์**: ใช้ผลการวิเคราะห์ที่ผ่านมาเพื่อปรับปรุงความแม่นยำและความเกี่ยวข้องของการวิเคราะห์ในอนาคต

### ตัวอย่าง: เอเจนต์ผู้สร้างโค้ดสำหรับตัวแทนการเดินทาง

ในตัวอย่างนี้ เราจะออกแบบเอเจนต์ผู้สร้างโค้ด ชื่อ Travel Agent เพื่อช่วยผู้ใช้วางแผนการเดินทางโดยการสร้างและรันโค้ด เอเจนต์นี้สามารถจัดการงานเช่น ดึงตัวเลือกการเดินทาง กรองผลลัพธ์ และจัดทำแผนการเดินทางโดยใช้ AI เชิงกำเนิด

#### ภาพรวมของเอเจนต์ผู้สร้างโค้ด

1. **รวบรวมความชอบของผู้ใช้**: เก็บข้อมูลจากผู้ใช้ เช่น ปลายทาง วันที่เดินทาง งบประมาณ และความสนใจ
2. **สร้างโค้ดเพื่อดึงข้อมูล**: สร้างสคริปต์โค้ดเพื่อดึงข้อมูลเกี่ยวกับเที่ยวบิน โรงแรม และสถานที่ท่องเที่ยว
3. **รันโค้ดที่สร้างขึ้น**: รันโค้ดที่สร้างขึ้นเพื่อนำข้อมูลเรียลไทม์
4. **สร้างแผนการเดินทาง**: รวบรวมข้อมูลที่ดึงมาเป็นแผนการเดินทางที่เป็นส่วนตัว
5. **ปรับตามความคิดเห็น**: รับฟังความคิดเห็นผู้ใช้และสร้างโค้ดใหม่หากจำเป็นเพื่อปรับผลลัพธ์

#### การใช้งานเป็นขั้นตอนทีละขั้น

1. **รวบรวมความชอบของผู้ใช้**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **สร้างโค้ดเพื่อดึงข้อมูล**

   ```python
   def generate_code_to_fetch_data(preferences):
       # ตัวอย่าง: สร้างโค้ดเพื่อค้นหาเที่ยวบินตามความต้องการของผู้ใช้
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # ตัวอย่าง: สร้างโค้ดเพื่อค้นหาโรงแรม
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **รันโค้ดที่สร้างขึ้น**

   ```python
   def execute_code(code):
       # เรียกใช้โค้ดที่สร้างขึ้นโดยใช้ exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **สร้างแผนการเดินทาง**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **ปรับตามความคิดเห็น**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # ปรับการตั้งค่าตามคำติชมของผู้ใช้
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # สร้างและเรียกใช้โค้ดใหม่ด้วยการตั้งค่าที่อัปเดต
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### การใช้ความตระหนักต่อสภาพแวดล้อมและการให้เหตุผล

การอาศัยโครงร่างของตารางสามารถปรับปรุงกระบวนการสร้างคำสั่งค้นหาโดยใช้ความตระหนักต่อสภาพแวดล้อมและการให้เหตุผลได้จริง

นี่คือตัวอย่างว่าทำได้อย่างไร:

1. **เข้าใจสกีมา**: ระบบจะเข้าใจสกีมาของตารางและใช้ข้อมูลนี้เป็นฐานในการสร้างคำสั่งค้นหา
2. **ปรับตามความคิดเห็น**: ระบบจะปรับความชอบของผู้ใช้ตามความคิดเห็นและใช้เหตุผลว่าสนามข้อมูลใดในสกีมาที่จำเป็นต้องอัปเดต
3. **สร้างและรันคำสั่งค้นหา**: ระบบจะสร้างและรันคำสั่งเพื่อดึงข้อมูลเที่ยวบินและโรงแรมที่อัปเดตตามความชอบใหม่

ต่อไปนี้เป็นตัวอย่างโค้ด Python ที่อัปเดตซึ่งผสานแนวคิดเหล่านี้:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # ปรับความชอบตามข้อเสนอแนะของผู้ใช้
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # ใช้เหตุผลตามสคีมาเพื่อปรับความชอบที่เกี่ยวข้องอื่นๆ
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # ตรรกะที่กำหนดเองเพื่อปรับความชอบตามสคีมาและข้อเสนอแนะ
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # สร้างโค้ดเพื่อดึงข้อมูลเที่ยวบินตามความชอบที่อัปเดต
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # สร้างโค้ดเพื่อดึงข้อมูลโรงแรมตามความชอบที่อัปเดต
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # จำลองการรันโค้ดและส่งคืนข้อมูลจำลอง
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # สร้างแผนการเดินทางตามเที่ยวบิน โรงแรม และสถานที่ท่องเที่ยว
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# ตัวอย่างสคีมา
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# ตัวอย่างการใช้งาน
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# สร้างโค้ดใหม่และรันด้วยความชอบที่อัปเดต
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### คำอธิบาย - การจองตามความคิดเห็น

1. **การตระหนักถึงสกีมา**: พจนานุกรม `schema` กำหนดว่าแต่ละความชอบควรถูกปรับตามความคิดเห็นอย่างไร ซึ่งรวมฟิลด์เช่น `favorites` และ `avoid` พร้อมการปรับที่เกี่ยวข้อง
2. **การปรับความชอบ (`adjust_based_on_feedback` method)**: เมธอดนี้ปรับความชอบตามความคิดเห็นของผู้ใช้และสกีมา
3. **การปรับตามสภาพแวดล้อม (`adjust_based_on_environment` method)**: เมธอดนี้ปรับแต่งการปรับเปลี่ยนตามสกีมาและความคิดเห็น
4. **การสร้างและรันคำสั่งค้นหา**: ระบบสร้างโค้ดเพื่อดึงข้อมูลเที่ยวบินและโรงแรมที่อัปเดตตามความชอบที่ปรับแล้วและจำลองการรันคำสั่งเหล่านี้
5. **การสร้างแผนการเดินทาง**: ระบบสร้างแผนการเดินทางที่อัปเดตตามข้อมูลเที่ยวบิน โรงแรม และสถานที่ท่องเที่ยวใหม่

การทำให้ระบบมีความตระหนักถึงสภาพแวดล้อมและให้เหตุผลตามสกีมาจะช่วยให้มันสร้างคำสั่งค้นหาที่แม่นยำและเกี่ยวข้องมากขึ้น นำไปสู่คำแนะนำการเดินทางที่ดีกว่าและประสบการณ์ผู้ใช้ที่เป็นส่วนตัวมากขึ้น

### การใช้ SQL เป็นเทคนิค Retrieval-Augmented Generation (RAG)

SQL (Structured Query Language) เป็นเครื่องมือที่ทรงพลังสำหรับโต้ตอบกับฐานข้อมูล เมื่อนำมาใช้เป็นส่วนหนึ่งของแนวทาง Retrieval-Augmented Generation (RAG) SQL สามารถดึงข้อมูลที่เกี่ยวข้องจากฐานข้อมูลเพื่อให้ข้อมูลประกอบการตอบหรือการกระทำในเอเจนต์ AI มาดูกันว่า SQL สามารถใช้เป็นเทคนิค RAG ในบริบทของ Travel Agent ได้อย่างไร

#### แนวคิดสำคัญ

1. **การโต้ตอบกับฐานข้อมูล**:
   - SQL ถูกใช้งานเพื่อสืบค้นฐานข้อมูล ดึงข้อมูลที่เกี่ยวข้อง และจัดการข้อมูล
   - ตัวอย่าง: ดึงรายละเอียดเที่ยวบิน ข้อมูลโรงแรม และสถานที่ท่องเที่ยวจากฐานข้อมูลการเดินทาง

2. **การรวมเข้ากับ RAG**:
   - คำสั่ง SQL ถูกสร้างขึ้นตามข้อมูลป้อนและความชอบของผู้ใช้
   - ข้อมูลที่ดึงได้จะถูกนำมาใช้เพื่อสร้างคำแนะนำหรือการกระทำที่เป็นส่วนตัว

3. **การสร้างคำสั่งค้นหาแบบไดนามิก**:
   - เอเจนต์ AI สร้างคำสั่ง SQL แบบไดนามิกตามบริบทและความต้องการของผู้ใช้
   - ตัวอย่าง: ปรับคำสั่ง SQL เพื่อกรองผลลัพธ์ตามงบประมาณ วันที่ และความสนใจ

#### การประยุกต์ใช้งาน

- **การสร้างโค้ดอัตโนมัติ**: สร้างสคริปต์โค้ดสำหรับงานเฉพาะ
- **SQL ในฐานะ RAG**: ใช้คำสั่ง SQL เพื่อจัดการข้อมูล
- **การแก้ปัญหา**: สร้างและรันโค้ดเพื่อแก้ปัญหา

**ตัวอย่าง**:
เอเจนต์วิเคราะห์ข้อมูล:

1. **งานที่ต้องทำ**: วิเคราะห์ชุดข้อมูลเพื่อค้นหาแนวโน้ม
2. **ขั้นตอน**:
   - โหลดชุดข้อมูล
   - สร้างคำสั่ง SQL เพื่อกรองข้อมูล
   - รันคำสั่งและดึงผลลัพธ์
   - สร้างภาพและข้อสรุป
3. **ทรัพยากร**: การเข้าถึงชุดข้อมูล ความสามารถ SQL
4. **ประสบการณ์**: ใช้ผลลัพธ์ที่ผ่านมาเพื่อปรับปรุงการวิเคราะห์ในอนาคต

#### ตัวอย่างเชิงปฏิบัติ: การใช้ SQL ใน Travel Agent

1. **รวบรวมความชอบของผู้ใช้**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **สร้างคำสั่ง SQL**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **รันคำสั่ง SQL**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **สร้างคำแนะนำ**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### ตัวอย่างคำสั่ง SQL

1. **คำสั่งค้นหาเที่ยวบิน**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **คำสั่งค้นหาโรงแรม**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **คำสั่งค้นหาสถานที่ท่องเที่ยว**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

โดยการใช้ SQL เป็นส่วนหนึ่งของเทคนิค Retrieval-Augmented Generation (RAG) เอเจนต์ AI อย่าง Travel Agent สามารถดึงและใช้ข้อมูลที่เกี่ยวข้องได้อย่างไดนามิกเพื่อให้คำแนะนำที่แม่นยำและเป็นส่วนตัวมากขึ้น

### Example of Metacongition

ดังนั้นเพื่อสาธิตการนำ Metacongition มาใช้ เรามาสร้างเอเจนต์ง่าย ๆ ที่ *สะท้อนกระบวนการตัดสินใจของตัวเอง* ขณะแก้ปัญหา สำหรับตัวอย่างนี้ เราจะสร้างระบบที่เอเจนต์พยายามปรับตัวเลือกโรงแรมให้เหมาะสม จากนั้นจะประเมินเหตุผลของตัวเองและปรับกลยุทธ์เมื่อทำพลาดหรือเลือกไม่ดีพอ

เราจะจำลองสิ่งนี้โดยใช้ตัวอย่างพื้นฐานที่เอเจนต์เลือกโรงแรมโดยอาศัยการผสมผสานระหว่างราคาและคุณภาพ แต่เอเจนต์จะ "สะท้อน" การตัดสินใจของตัวเองและปรับตามนั้น

#### วิธีที่แสดง metacognition นี้:

1. **การตัดสินใจเริ่มต้น**: เอเจนต์จะเลือกโรงแรมที่ถูกที่สุด โดยยังไม่พิจารณาผลกระทบจากคุณภาพ
2. **การสะท้อนและการประเมิน**: หลังการเลือกครั้งแรก เอเจนต์จะตรวจสอบว่าโรงแรมเป็นการเลือกที่ "ไม่ดี" หรือไม่ โดยใช้ความคิดเห็นของผู้ใช้ หากพบว่าโรงแรมมีคุณภาพต่ำเกินไป มันจะสะท้อนเหตุผลของตนเอง
3. **การปรับกลยุทธ์**: เอเจนต์ปรับกลยุทธ์ตามการสะท้อน เปลี่ยนจาก "ถูกที่สุด" เป็น "คุณภาพสูงสุด" ส่งผลให้การตัดสินใจดีขึ้นในรอบถัดไป

นี่คือตัวอย่าง:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # เก็บโรงแรมที่เลือกไว้ก่อนหน้า
        self.corrected_choices = []  # เก็บตัวเลือกที่แก้ไขแล้ว
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # กลยุทธ์ที่มีอยู่

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # สมมติว่าเรามีข้อเสนอแนะจากผู้ใช้ที่บอกได้ว่าการเลือกครั้งสุดท้ายดีหรือไม่
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # ปรับกลยุทธ์หากการเลือกก่อนหน้านั้นไม่เป็นที่น่าพอใจ
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# จำลองรายการโรงแรม (ราคาและคุณภาพ)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# สร้างตัวแทน
agent = HotelRecommendationAgent()

# ขั้นตอนที่ 1: ตัวแทนแนะนำโรงแรมโดยใช้กลยุทธ์ "ถูกที่สุด"
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# ขั้นตอนที่ 2: ตัวแทนทบทวนการเลือกและปรับกลยุทธ์หากจำเป็น
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# ขั้นตอนที่ 3: ตัวแทนแนะนำอีกครั้ง โดยครั้งนี้ใช้กลยุทธ์ที่ปรับแล้ว
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### ความสามารถ metacognition ของเอเจนต์

จุดสำคัญที่นี่คือความสามารถของเอเจนต์ในการ:
- ประเมินการเลือกและกระบวนการตัดสินใจในอดีต
- ปรับกลยุทธ์ของตนตามการสะท้อน กล่าวคือ metacognition ในการปฏิบัติ

นี่เป็นรูปแบบพื้นฐานของ metacognition ที่ระบบสามารถปรับกระบวนการให้เหตุผลของตนเองตามฟีดแบ็กภายในได้

### สรุป

Metacognition เป็นเครื่องมือที่ทรงพลังซึ่งสามารถขยายความสามารถของเอเจนต์ AI ได้อย่างมาก โดยการผนวกกระบวนการ metacognitive คุณสามารถออกแบบเอเจนต์ที่มีความฉลาด ยืดหยุ่น และมีประสิทธิภาพยิ่งขึ้น ใช้แหล่งข้อมูลเพิ่มเติมเพื่อสำรวจโลกที่น่าสนใจของ metacognition ในเอเจนต์ AI ต่อไป

### มีคำถามเพิ่มเติมเกี่ยวกับรูปแบบการออกแบบ Metacognition ไหม?

เข้าร่วมที่ [Microsoft Foundry Discord](https://aka.ms/ai-agents/discord) เพื่อพบกับผู้เรียนคนอื่น ๆ เข้าร่วมชั่วโมงให้คำปรึกษา และขอคำตอบสำหรับคำถามเกี่ยวกับ AI Agents ของคุณ

## บทเรียนก่อนหน้า

[รูปแบบการออกแบบหลายเอเจนต์](../08-multi-agent/README.md)

## บทเรียนถัดไป

[เอเจนต์ AI ในการผลิต](../10-ai-agents-production/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
ข้อจำกัดความรับผิด:
เอกสารฉบับนี้ได้รับการแปลโดยใช้บริการแปลด้วย AI [Co-op Translator](https://github.com/Azure/co-op-translator) แม้ว่าเราจะพยายามให้การแปลมีความถูกต้อง โปรดทราบว่าการแปลอัตโนมัติอาจมีข้อผิดพลาดหรือความคลาดเคลื่อน เอกสารต้นฉบับในภาษาเดิมควรถือเป็นแหล่งข้อมูลที่เชื่อถือได้ หากเป็นข้อมูลที่สำคัญ ขอแนะนำให้ใช้การแปลโดยนักแปลมืออาชีพ (มนุษย์) เราไม่รับผิดชอบต่อความเข้าใจผิดหรือการตีความผิดที่เกิดจากการใช้การแปลฉบับนี้
<!-- CO-OP TRANSLATOR DISCLAIMER END -->