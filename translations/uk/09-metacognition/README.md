[![Дизайн мультиагентної системи](../../../translated_images/uk/lesson-9-thumbnail.38059e8af1a5b71d.webp)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(Клацніть на зображення вище, щоб переглянути відео цього уроку)_
# Метакогніція в AI-агентах

## Вступ

Ласкаво просимо до уроку з метакогніції в AI-агентах! Ця глава призначена для початківців, які цікавляться тим, як AI-агенти можуть мислити про власні процеси мислення. До кінця цього уроку ви зрозумієте ключові концепції і отримаєте практичні приклади застосування метакогніції в проєктуванні AI-агентів.

## Цілі навчання

Після завершення цього уроку ви зможете:

1. Зрозуміти наслідки циклів міркування в визначеннях агентів.
2. Використовувати техніки планування та оцінювання, щоб допомогти агентам самокоригуватися.
3. Створювати власних агентів, здатних маніпулювати кодом для виконання завдань.

## Вступ до метакогніції

Метакогніція стосується вищих когнітивних процесів, що включають мислення про власне мислення. Для AI-агентів це означає здатність оцінювати та коригувати свої дії на основі самоусвідомлення та попереднього досвіду. Метакогніція, або «мислення про мислення», є важливою концепцією в розвитку агентних систем AI. Вона передбачає, що AI-системи усвідомлюють власні внутрішні процеси й можуть контролювати, регулювати та адаптувати свою поведінку відповідно. Подібно до того, як ми оцінюємо атмосферу в кімнаті або розглядаємо проблему. Це самоусвідомлення може допомогти AI-системам приймати кращі рішення, виявляти помилки та покращувати свою продуктивність з часом — що знову повертає нас до тесту Тьюрінга та дебатів про те, чи захопить AI контроль.

У контексті агентних AI-систем метакогніція може допомогти вирішити кілька завдань, таких як:
- Прозорість: Забезпечення здатності AI-систем пояснювати свої міркування та рішення.
- Міркування: Покращення здатності AI-систем синтезувати інформацію та приймати обґрунтовані рішення.
- Адаптація: Дозволяє AI-системам підлаштовуватися під нові середовища та змінні умови.
- Сприйняття: Покращення точності AI-систем у розпізнаванні та інтерпретації даних із навколишнього середовища.

### Що таке метакогніція?

Метакогніція, або «мислення про мислення», — це вищий когнітивний процес, що включає самоусвідомлення та саморегуляцію власних когнітивних процесів. У сфері AI метакогніція дає агентам змогу оцінювати та адаптувати свої стратегії й дії, що веде до поліпшеного розв’язання проблем і прийняття рішень. Розуміючи метакогніцію, ви можете проєктувати AI-агентів, які не лише розумніші, але й більш гнучкі та ефективні. У справжній метакогніції ви побачите, як AI явно міркує про власне міркування.

Приклад: “Я віддав пріоритет дешевшим рейсам, тому що… Можливо, я втрачаю можливість прямого рейсу, тому перевірю ще раз.”.
Відстеження того, як або чому він обрав певний маршрут.
- Помічати, що він помилявся через надмірну опору на вподобання користувача з минулого разу, тому він змінює свою стратегію прийняття рішень, а не лише кінцеву рекомендацію.
- Діагностувати шаблони, наприклад: «Щоразу, коли я бачу, що користувач згадує «занадто людно», я повинен не лише виключати певні атракції, але й усвідомити, що мій метод вибору «топ-атракцій» несправний, якщо я завжди ранжую за популярністю.»

### Важливість метакогніції в AI-агентах

Метакогніція відіграє вирішальну роль у проєктуванні AI-агентів з кількох причин:

![Важливість метакогніції](../../../translated_images/uk/importance-of-metacognition.b381afe9aae352f7.webp)

- Саморефлексія: Агенти можуть оцінювати власну продуктивність і виявляти області для покращення.
- Адаптивність: Агенти можуть змінювати свої стратегії на основі попереднього досвіду та змін у середовищі.
- Виправлення помилок: Агенти можуть автономно виявляти й виправляти помилки, що призводить до точніших результатів.
- Управління ресурсами: Агенти можуть оптимізувати використання ресурсів, таких як час і обчислювальна потужність, шляхом планування та оцінювання своїх дій.

## Компоненти AI-агента

Перед тим як заглиблюватися в метакогнітивні процеси, важливо зрозуміти базові компоненти AI-агента. Зазвичай AI-агент складається з:

- Персона: Особистість і характеристики агента, які визначають, як він взаємодіє з користувачами.
- Інструменти: Можливості та функції, які агент може виконувати.
- Навички: Знання та експертиза, які має агент.

Ці компоненти працюють разом, створюючи «одиницю експертизи», яка може виконувати певні завдання.

**Приклад**:
Розглянемо туристичного агента, сервіс агента, який не лише планує вашу відпустку, але й коригує свій шлях на основі даних у реальному часі та попереднього досвіду користувацьких подорожей.

### Приклад: метакогніція в сервісі туристичного агента

Уявіть, що ви проєктуєте сервіс туристичного агента на базі AI. Цей агент, "Travel Agent", допомагає користувачам планувати їхні відпустки. Щоб інтегрувати метакогніцію, Travel Agent має оцінювати та коригувати свої дії на основі самоусвідомлення та минулого досвіду. Ось як метакогніція може відігравати роль:

#### Поточне завдання

Поточне завдання — допомогти користувачеві спланувати поїздку до Парижа.

#### Кроки для виконання завдання

1. **Збір вподобань користувача**: Запитайте в користувача дати подорожі, бюджет, інтереси (наприклад, музеї, кухня, шопінг) та будь-які конкретні вимоги.
2. **Отримання інформації**: Пошук варіантів рейсів, проживання, атракцій та ресторанів, що відповідають вподобанням користувача.
3. **Формування рекомендацій**: Надання персоналізованого маршруту з деталями рейсів, бронюванням готелів і запропонованими активностями.
4. **Коригування на основі зворотного зв’язку**: Запитайте користувача про відгук щодо рекомендацій і внесіть необхідні корективи.

#### Необхідні ресурси

- Доступ до баз даних бронювання авіарейсів і готелів.
- Інформація про парижські атракції та ресторани.
- Дані зворотного зв’язку від користувачів із попередніх взаємодій.

#### Досвід і саморефлексія

Travel Agent використовує метакогніцію для оцінки своєї роботи та навчання на попередньому досвіді. Наприклад:

1. **Аналіз зворотного зв’язку користувачів**: Travel Agent переглядає відгуки користувачів, щоб визначити, які рекомендації були добре сприйняті, а які — ні. Він відповідно коригує свої майбутні пропозиції.
2. **Адаптивність**: Якщо користувач раніше згадував, що не любить людні місця, Travel Agent уникатиме рекомендацій популярних туристичних місць у години пік у майбутньому.
3. **Виправлення помилок**: Якщо Travel Agent допустив помилку в минулому бронюванні, наприклад запропонував готель, який був повністю заброньований, він навчається перевіряти доступність більш ретельно перед тим, як зробити рекомендацію.

#### Практичний приклад для розробника

Ось спрощений приклад того, як може виглядати код Travel Agents при інтеграції метакогніції:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # Шукати рейси, готелі та визначні місця відповідно до переваг
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # Аналізувати відгуки та коригувати майбутні рекомендації
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Приклад використання
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### Чому метакогніція має значення

- **Саморефлексія**: Агенти можуть аналізувати свою продуктивність і визначати області для покращення.
- **Адаптивність**: Агенти можуть змінювати стратегії на основі відгуків і змінних умов.
- **Виправлення помилок**: Агенти можуть автономно виявляти і виправляти помилки.
- **Управління ресурсами**: Агенти можуть оптимізувати використання ресурсів, таких як час і обчислювальні потужності.

Інтегруючи метакогніцію, Travel Agent може надавати більш персоналізовані та точні рекомендації щодо подорожей, покращуючи загальний досвід користувача.

---

## 2. Планування в агентів

Планування — критичний компонент поведінки AI-агента. Воно включає окреслення кроків, необхідних для досягнення мети, враховуючи поточний стан, ресурси та можливі перешкоди.

### Елементи планування

- **Поточне завдання**: Чітко визначте завдання.
- **Кроки для виконання завдання**: Розбийте завдання на керовані кроки.
- **Необхідні ресурси**: Визначте потрібні ресурси.
- **Досвід**: Використовуйте попередній досвід для інформування планування.

**Приклад**:
Ось кроки, які Travel Agent має виконати, щоб ефективно допомогти користувачеві спланувати поїздку:

### Кроки для Travel Agent

1. **Збір вподобань користувача**
   - Запитайте в користувача деталі щодо дат подорожі, бюджету, інтересів та будь-яких конкретних вимог.
   - Приклади: "Коли ви плануєте подорож?" "Який у вас діапазон бюджету?" "Які активності ви любите під час відпустки?"

2. **Отримання інформації**
   - Шукайте релевантні варіанти подорожей на основі вподобань користувача.
   - **Рейси**: Пошук доступних рейсів у межах бюджету користувача та бажаних дат подорожі.
   - **Проживання**: Пошук готелів або оренд, що відповідають вподобанням користувача щодо розташування, ціни та зручностей.
   - **Атракції та ресторани**: Визначення популярних атракцій, активностей і закладів харчування, що відповідають інтересам користувача.

3. **Формування рекомендацій**
   - Скомпілюйте отриману інформацію в персоналізований маршрут.
   - Надайте деталі, такі як варіанти рейсів, бронювання готелів і запропоновані активності, переконавшись, що рекомендації відповідають вподобанням користувача.

4. **Представлення маршруту користувачу**
   - Поділіться запропонованим маршрутом з користувачем для перегляду.
   - Приклад: "Ось запропонований маршрут для вашої поїздки до Парижа. Він включає деталі рейсів, бронювання готелів і список рекомендованих активностей та ресторанів. Повідомте мені вашу думку!"

5. **Збір відгуків**
   - Запитайте користувача про відгук щодо запропонованого маршруту.
   - Приклади: "Чи подобаються вам варіанти рейсів?" "Чи підходить готель для ваших потреб?" "Чи є якісь активності, які ви хотіли б додати або видалити?"

6. **Коригування на основі відгуків**
   - Змініть маршрут на основі відгуків користувача.
   - Внесіть необхідні зміни до рекомендацій щодо рейсів, проживання та активностей, щоб краще відповідати вподобанням користувача.

7. **Остаточне підтвердження**
   - Подайте оновлений маршрут користувачу для остаточного підтвердження.
   - Приклад: "Я вніс корективи на основі вашого відгуку. Ось оновлений маршрут. Чи все виглядає добре?"

8. **Бронювання та підтвердження резервувань**
   - Після схвалення маршруту користувачем перейдьте до бронювання рейсів, проживання та будь-яких попередньо запланованих активностей.
   - Надішліть користувачу деталі підтвердження.

9. **Надання постійної підтримки**
   - Будьте доступні, щоб допомогти користувачеві з будь-якими змінами або додатковими запитами до і під час подорожі.
   - Приклад: "Якщо вам потрібна додаткова допомога під час подорожі, звертайтесь до мене в будь-який час!"

### Приклад взаємодії

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Приклад використання в запиті на освистування
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. Корекційна система RAG

По-перше, давайте почнемо з розуміння різниці між RAG Tool і попереднім завантаженням контексту

![RAG проти завантаження контексту](../../../translated_images/uk/rag-vs-context.9eae588520c00921.webp)

### Retrieval-Augmented Generation (RAG)

RAG поєднує систему витягування з генеративною моделлю. Коли надходить запит, система витягування знаходить релевантні документи або дані з зовнішнього джерела, і ця отримана інформація використовується для розширення вхідних даних для генеративної моделі. Це допомагає моделі генерувати більш точні та контекстуально релевантні відповіді.

У системі RAG агент отримує релевантну інформацію з бази знань і використовує її для генерації відповідних відповідей або дій.

### Корекційний підхід RAG

Корекційний підхід RAG зосереджений на використанні технік RAG для виправлення помилок і підвищення точності AI-агентів. Це включає:

1. **Техніка підказок**: Використання конкретних підказок для спрямування агента у витягуванні релевантної інформації.
2. **Інструмент**: Реалізація алгоритмів і механізмів, що дозволяють агенту оцінювати релевантність отриманої інформації і генерувати точні відповіді.
3. **Оцінювання**: Постійна оцінка продуктивності агента та внесення коректив для покращення його точності й ефективності.

#### Приклад: Корекційний RAG у пошуковому агенті

Розглянемо пошукового агента, який отримує інформацію з вебу для відповіді на запити користувачів. Корекційний підхід RAG може включати:

1. **Техніка підказок**: Формулювання запитів пошуку на основі вводу користувача.
2. **Інструмент**: Використання обробки природної мови та алгоритмів машинного навчання для ранжування і фільтрації результатів пошуку.
3. **Оцінювання**: Аналіз зворотного зв’язку від користувачів для виявлення і виправлення неточностей в отриманій інформації.

### Корекційний RAG у Travel Agent

Корекційний RAG (Retrieval-Augmented Generation) підвищує здатність AI отримувати й генерувати інформацію, одночасно виправляючи будь-які неточності. Подивімося, як Travel Agent може використовувати корекційний підхід RAG для надання більш точних і релевантних рекомендацій щодо подорожей.

Це включає:

- **Техніка підказок:** Використання конкретних підказок для спрямування агента у витягуванні релевантної інформації.
- **Інструмент:** Реалізація алгоритмів і механізмів, що дозволяють агенту оцінювати релевантність отриманої інформації і генерувати точні відповіді.
- **Оцінювання:** Постійний контроль за продуктивністю агента і внесення коректив для підвищення його точності й ефективності.

#### Кроки впровадження корекційного RAG у Travel Agent

1. **Початкова взаємодія з користувачем**
   - Travel Agent збирає початкові вподобання користувача, такі як напрямок, дати подорожі, бюджет та інтереси.
   - Приклад:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **Отримання інформації**
   - Travel Agent отримує інформацію про рейси, проживання, атракції та ресторани на основі вподобань користувача.
   - Приклад:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **Генерація початкових рекомендацій**
   - Travel Agent використовує отриману інформацію для створення персоналізованого маршруту.
   - Приклад:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **Збір відгуків користувача**
   - Travel Agent просить користувача надати відгук щодо початкових рекомендацій.
   - Приклад:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **Процес корекційного RAG**
   - **Техніка підказок**: Travel Agent формулює нові пошукові запити на основі зворотного зв’язку користувача.
     - Приклад:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **Інструмент**: Travel Agent використовує алгоритми для ранжування і фільтрації нових результатів пошуку, акцентуючи увагу на релевантності з урахуванням відгуків користувача.
     - Приклад:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **Оцінювання**: Travel Agent постійно оцінює релевантність і точність своїх рекомендацій, аналізуючи відгуки користувачів і вносячи необхідні корективи.
     - Приклад:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### Практичний приклад

Ось спрощений приклад коду на Python, що включає корекційний підхід RAG у Travel Agent:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# Приклад використання
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### Попереднє завантаження контексту
Попереднє завантаження контексту (Pre-emptive Context Load) полягає в завантаженні релевантного контексту або фонового матеріалу в модель до обробки запиту. Це означає, що модель має доступ до цієї інформації від самого початку, що допомагає їй генерувати більш обґрунтовані відповіді без необхідності додаткового витягання даних під час процесу.

Ось спрощений приклад того, як може виглядати попереднє завантаження контексту для програми турагента на Python:

```python
class TravelAgent:
    def __init__(self):
        # Попередньо завантажити популярні напрямки та їхню інформацію
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # Отримати інформацію про напрямок із попередньо завантаженого контексту
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# Приклад використання
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### Пояснення

1. **Ініціалізація (`__init__` method)**: Клас `TravelAgent` попередньо завантажує словник з інформацією про популярні напрямки, такі як Paris, Tokyo, New York, and Sydney. Цей словник містить деталі, як-от країну, валюту, мову та основні пам'ятки для кожного напрямку.

2. **Отримання інформації (`get_destination_info` method)**: Коли користувач запитує про конкретний напрямок, метод `get_destination_info` витягає відповідну інформацію зі словника попередньо завантаженого контексту.

За допомогою попереднього завантаження контексту програма турагента може швидко відповідати на запити користувачів, не звертаючись у реальному часі до зовнішніх джерел. Це робить додаток ефективнішим і більш чутливим.

### Ініціалізація плану з метою перед ітерацією

Ініціалізація плану з метою означає початок з чіткої цілі або бажаного результату. Визначивши ціль на початку, модель може використовувати її як орієнтир протягом ітеративного процесу. Це допомагає забезпечити, щоб кожна ітерація наближала до досягнення бажаного результату, роблячи процес більш ефективним і сфокусованим.

Ось приклад того, як ви можете ініціалізувати план подорожі з метою перед ітерацією для турагента на Python:

### Сценарій

Турагент хоче спланувати індивідуальну відпустку для клієнта. Мета — створити маршрут подорожі, який максимізує задоволення клієнта з урахуванням його вподобань і бюджету.

### Кроки

1. Визначити вподобання клієнта та бюджет.
2. Ініціалізувати початковий план на основі цих вподобань.
3. Ітерувати для уточнення плану, оптимізуючи його для максимального задоволення клієнта.

#### Python Код

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# Приклад використання
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### Пояснення коду

1. **Ініціалізація (`__init__` method)**: Клас `TravelAgent` ініціалізується зі списком потенційних напрямків, кожен із яких має атрибути, як-от назва, вартість і тип активності.

2. **Ініціалізація плану (`bootstrap_plan` method)**: Цей метод створює початковий план подорожі на основі вподобань і бюджету клієнта. Він проходить список напрямків і додає їх до плану, якщо вони відповідають вподобанням клієнта і вкладаються в бюджет.

3. **Підбір вподобань (`match_preferences` method)**: Цей метод перевіряє, чи відповідає напрямок вподобанням клієнта.

4. **Ітерація плану (`iterate_plan` method)**: Цей метод уточнює початковий план, намагаючись замінити кожен напрямок у плані на кращий варіант з урахуванням вподобань та бюджетних обмежень клієнта.

5. **Розрахунок вартості (`calculate_cost` method)**: Цей метод обчислює загальну вартість поточного плану, враховуючи потенційно новий напрямок.

#### Приклад використання

- **Початковий план**: Турагент створює початковий план на основі вподобань клієнта щодо огляду визначних місць та бюджету $2000.
- **Удосконалений план**: Турагент ітерує план, оптимізуючи його відповідно до вподобань клієнта та бюджету.

Завдяки ініціалізації плану з чіткою метою (наприклад, максимізація задоволення клієнта) і ітераціям для його уточнення, турагент може створити індивідуальний та оптимізований маршрут подорожі для клієнта. Такий підхід гарантує, що план подорожі з початку відповідає вподобанням і бюджету клієнта та покращується з кожною ітерацією.

### Використання LLM для перевпорядкування та оцінювання

Великі мовні моделі (LLM) можна використовувати для перевпорядкування та оцінювання, оцінюючи релевантність і якість витягнутих документів або згенерованих відповідей. Ось як це працює:

**Пошук:** Початковий крок витягує набір кандидатів-документів або відповідей на основі запиту.

**Перевпорядкування:** LLM оцінює ці кандидати та перевпорядковує їх на основі релевантності та якості. Цей крок забезпечує, що найрелевантніша та найякісніша інформація подається першою.

**Оцінювання:** LLM призначає бали кожному кандидату, що відображають їхню релевантність і якість. Це допомагає обрати найкращу відповідь або документ для користувача.

Використовуючи LLM для перевпорядкування та оцінювання, система може надавати більш точну та контекстно релевантну інформацію, покращуючи загальний досвід користувача.

Ось приклад того, як турагент може використовувати Велику мовну модель (LLM) для перевпорядкування та оцінювання напрямків подорожей на основі вподобань користувача на Python:

#### Сценарій - Подорож на основі вподобань

Турагент хоче рекомендувати найкращі напрямки подорожей клієнту на основі його вподобань. LLM допоможе перевпорядкувати та оцінити напрямки, щоб найрелевантніші варіанти були представлені першими.

#### Кроки:

1. Зібрати вподобання користувача.
2. Отримати список потенційних напрямків подорожі.
3. Використати LLM для перевпорядкування та оцінення напрямків на основі вподобань користувача.

Ось як можна оновити попередній приклад для використання Azure OpenAI Services:

#### Вимоги

1. Потрібно мати підписку Azure.
2. Створіть ресурс Azure OpenAI і отримайте свій API-ключ.

#### Приклад коду на Python

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Згенерувати підказку для Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # Визначити заголовки та тіло запиту
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # Викликати API Azure OpenAI, щоб отримати переранжовані та оцінені пункти призначення
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # Витягти та повернути рекомендації
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# Приклад використання
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### Пояснення коду - Preference Booker

1. **Ініціалізація**: Клас `TravelAgent` ініціалізується зі списком потенційних напрямків подорожі, кожен із яких має атрибути, як-от назва та опис.

2. **Отримання рекомендацій (`get_recommendations` method)**: Цей метод генерує промпт для служби Azure OpenAI на основі вподобань користувача і робить HTTP POST-запит до API Azure OpenAI, щоб отримати перевпорядковані та оцінені напрямки.

3. **Генерація промпту (`generate_prompt` method)**: Цей метод будує промпт для Azure OpenAI, включаючи вподобання користувача та список напрямків. Промпт направляє модель перевпорядкувати та оцінити напрямки на основі наданих вподобань.

4. **API виклик**: Бібліотека `requests` використовується для виконання HTTP POST-запиту до кінцевої точки API Azure OpenAI. У відповіді містяться перевпорядковані та оцінені напрямки.

5. **Приклад використання**: Турагент збирає вподобання користувача (наприклад, інтерес до огляду пам'яток і різноманітної культури) і використовує службу Azure OpenAI для отримання перевпорядкованих та оцінених рекомендацій напрямків для подорожей.

Переконайтеся, що ви замінили `your_azure_openai_api_key` на свій фактичний API-ключ Azure OpenAI та `https://your-endpoint.com/...` на реальну URL-адресу вашого розгортання Azure OpenAI.

Завдяки використанню LLM для перевпорядкування та оцінювання турагент може надавати більш персоналізовані та релевантні рекомендації щодо подорожей клієнтам, покращуючи їхній загальний досвід.

### RAG: Техніка промптингу проти інструмента

Retrieval-Augmented Generation (RAG) може виступати як технікою промптингу, так і інструментом у розробці AI-агентів. Розуміння різниці між ними допоможе ефективніше використовувати RAG у ваших проєктах.

#### RAG як техніка промптингу

**Що це?**

- Як техніка промптингу, RAG полягає у формуванні конкретних запитів або промптів для спрямування пошуку релевантної інформації з великого корпусу або бази даних. Ця інформація потім використовується для генерації відповідей або дій.

**Як це працює:**

1. **Формулювання промптів**: Створюйте добре структуровані промпти або запити на основі завдання або вводу користувача.
2. **Отримання інформації**: Використовуйте промпти для пошуку релевантних даних у наявній базі знань або наборі даних.
3. **Генерація відповіді**: Поєднуйте отриману інформацію з генеративними AI-моделями для вироблення об’ємної та послідовної відповіді.

**Приклад у Travel Agent**:

- Ввід користувача: "I want to visit museums in Paris."
- Промпт: "Find top museums in Paris."
- Отримана інформація: Деталі про Louvre Museum, Musée d'Orsay тощо.
- Згенерована відповідь: "Here are some top museums in Paris: Louvre Museum, Musée d'Orsay, and Centre Pompidou."

#### RAG як інструмент

**Що це?**

- Як інструмент, RAG — це інтегрована система, яка автоматизує процес отримання і генерації, полегшуючи розробникам реалізацію складних AI-функціональностей без вручну створюваних промптів для кожного запиту.

**Як це працює:**

1. **Інтеграція**: Вбудуйте RAG в архітектуру AI-агента, дозволяючи йому автоматично обробляти завдання з отримання та генерації.
2. **Автоматизація**: Інструмент керує всім процесом — від прийому вводу користувача до генерації остаточної відповіді — без необхідності явних промптів на кожному кроці.
3. **Ефективність**: Підвищує продуктивність агента, оптимізуючи процес отримання і генерації, що дозволяє швидше й точніше відповідати.

**Приклад у Travel Agent**:

- Ввід користувача: "I want to visit museums in Paris."
- RAG інструмент: Автоматично отримує інформацію про музеї та генерує відповідь.
- Згенерована відповідь: "Here are some top museums in Paris: Louvre Museum, Musée d'Orsay, and Centre Pompidou."

### Порівняння

| Aspect                 | Prompting Technique                                        | Tool                                                  |
|------------------------|-------------------------------------------------------------|-------------------------------------------------------|
| **Manual vs Automatic**| Ручне формування підказок для кожного запиту.               | Автоматизований процес отримання та генерації.        |
| **Control**            | Надає більше контролю над процесом отримання інформації.    | Оптимізує та автоматизує процес отримання й генерації.|
| **Flexibility**        | Дозволяє налаштовувати промпти відповідно до конкретних потреб.| Більш ефективний для масштабних впроваджень.       |
| **Complexity**         | Вимагає створення та підлаштування промптів.                | Легше інтегрується в архітектуру AI-агента.           |

### Практичні приклади

**Приклад техніки промптингу:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**Приклад інструмента:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### Оцінювання релевантності

Оцінювання релевантності є критично важливим аспектом роботи AI-агента. Воно гарантує, що інформація, яку витягає та генерує агент, є доречною, точною та корисною для користувача. Розглянемо, як оцінювати релевантність у AI-агентах, включаючи практичні приклади та методики.

#### Ключові поняття в оцінюванні релевантності

1. **Урахування контексту**:
   - Агент повинен розуміти контекст запиту користувача, щоб витягувати та генерувати релевантну інформацію.
   - Приклад: Якщо користувач запитує "best restaurants in Paris", агент має врахувати вподобання користувача, такі як тип кухні та бюджет.

2. **Точність**:
   - Інформація, яку надає агент, має бути фактично правильною та актуальною.
   - Приклад: Рекомендувати відкриті ресторани з хорошими відгуками, а не застарілі або закриті варіанти.

3. **Намір користувача**:
   - Агент має виводити намір користувача за запитом, щоб надати максимально релевантну інформацію.
   - Приклад: Якщо користувач просить "budget-friendly hotels", агент має пріоритезувати доступні варіанти.

4. **Зворотний зв'язок**:
   - Постійний збір та аналіз відгуків користувачів допомагає агенту вдосконалювати процес оцінювання релевантності.
   - Приклад: Інтегрування оцінок користувачів та зворотного зв'язку щодо попередніх рекомендацій для покращення майбутніх відповідей.

#### Практичні методики для оцінювання релевантності

1. **Оцінювання релевантності (Relevance Scoring)**:
   - Призначайте бал релевантності кожному витягнутому елементу на основі того, наскільки добре він відповідає запиту та вподобанням користувача.
   - Приклад:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **Фільтрація та ранжування**:
   - Відфільтруйте нерелевантні елементи та ранжуйте залишені за їхніми балами релевантності.
   - Приклад:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # Повернути 10 найбільш релевантних елементів
     ```

3. **Обробка природної мови (NLP)**:
   - Використовуйте методи NLP для розуміння запиту користувача та витягування релевантної інформації.
   - Приклад:

     ```python
     def process_query(query):
         # Використовуйте NLP, щоб витягти ключову інформацію з запиту користувача
         processed_query = nlp(query)
         return processed_query
     ```

4. **Інтеграція зворотного зв'язку від користувача**:
   - Збирайте відгуки про надані рекомендації й використовуйте їх для коригування майбутніх оцінок релевантності.
   - Приклад:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### Приклад: Оцінювання релевантності в Travel Agent

Ось практичний приклад того, як Travel Agent може оцінювати релевантність рекомендацій подорожей:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # Повернути 10 найвідповідніших елементів

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# Приклад використання
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### Пошук з урахуванням наміру

Пошук з урахуванням наміру включає розуміння та інтерпретацію підґрунтя або мети запиту користувача, щоб витягнути та згенерувати найбільш релевантну та корисну інформацію. Такий підхід виходить за межі простого співпадіння ключових слів і зосереджується на розумінні реальних потреб та контексту користувача.

#### Ключові поняття у пошуку з урахуванням наміру

1. **Розуміння наміру користувача**:
   - Наміри користувача можна розділити на три основні типи: інформаційний, навігаційний та транзакційний.
     - **Інформаційний намір**: користувач шукає інформацію про тему (наприклад, "What are the best museums in Paris?").
     - **Навігаційний намір**: користувач хоче перейти на певний вебсайт або сторінку (наприклад, "Louvre Museum official website").
     - **Транзакційний намір**: користувач має намір виконати дію, таку як бронювання квитка або покупка (наприклад, "Book a flight to Paris").

2. **Урахування контексту**:
   - Аналіз контексту запиту користувача допомагає точно визначити його намір. Це включає попередні взаємодії, вподобання користувача та деталі поточного запиту.

3. **Обробка природної мови (NLP)**:
   - Техніки NLP використовуються для розуміння та інтерпретації природномовних запитів користувачів. Це включає задачі розпізнавання сутностей, аналізу настроїв та розбору запиту.

4. **Персоналізація**:
   - Персоналізація результатів пошуку на основі історії користувача, вподобань і зворотного зв'язку підвищує релевантність витягнутої інформації.

#### Практичний приклад: Пошук з урахуванням наміру в Travel Agent

Візьмемо Travel Agent як приклад, щоб побачити, як можна реалізувати пошук з урахуванням наміру.

1. **Збір вподобань користувача**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Розуміння наміру користувача**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **Урахування контексту**
   ```python
   def analyze_context(query, user_history):
       # Поєднати поточний запит з історією користувача, щоб зрозуміти контекст
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **Пошук та персоналізація результатів**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # Приклад логіки пошуку для інформаційного наміру
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # Приклад логіки пошуку для навігаційного наміру
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # Приклад логіки пошуку для транзакційного наміру
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # Приклад логіки персоналізації
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # Повернути топ-10 персоналізованих результатів
   ```

5. **Приклад використання**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. Генерація коду як інструмент

Агенти, що генерують код, використовують AI-моделі для написання та виконання коду, вирішуючи складні проблеми та автоматизуючи завдання.

### Агенти, що генерують код

Агенти, що генерують код, використовують генеративні AI-моделі для написання та виконання коду. Такі агенти можуть вирішувати складні задачі, автоматизувати процеси та надавати цінні інсайти шляхом генерації та запуску коду різними мовами програмування.

#### Практичні застосування

1. **Автоматизована генерація коду**: Генерація фрагментів коду для конкретних завдань, таких як аналіз даних, веб-скрейпінг або машинне навчання.
2. **SQL як RAG**: Використання SQL-запитів для отримання та маніпуляції даними з баз даних.
3. **Вирішення задач**: Створення та виконання коду для розв’язання конкретних проблем, наприклад оптимізації алгоритмів або аналізу даних.

#### Приклад: агент, що генерує код для аналізу даних

Уявіть, що ви проєктуєте агента, який генерує код. Ось як це може працювати:

1. **Завдання**: Проаналізувати набір даних, щоб виявити тенденції та закономірності.
2. **Кроки**:
   - Завантажити набір даних у засіб для аналізу даних.
   - Згенерувати SQL-запити для фільтрації та агрегування даних.
   - Виконати запити та отримати результати.
   - Використати результати для створення візуалізацій та інсайтів.
3. **Необхідні ресурси**: Доступ до набору даних, інструменти для аналізу даних і можливості роботи з SQL.
4. **Досвід**: Використовувати попередні результати аналізу для підвищення точності та релевантності майбутніх аналізів.

### Приклад: агент, що генерує код для агента подорожей

У цьому прикладі ми проєктуємо агента, що генерує код, — Агент подорожей, який допомагає користувачам планувати подорожі шляхом генерації та виконання коду. Цей агент може виконувати завдання, такі як отримання варіантів подорожей, фільтрація результатів та складання маршруту, використовуючи генеративний AI.

#### Огляд агента, що генерує код

1. **Збирання вподобань користувача**: Збирає введення користувача, таке як напрямок, дати подорожі, бюджет та інтереси.
2. **Генерація коду для отримання даних**: Генерує фрагменти коду для отримання даних про рейси, готелі та визначні місця.
3. **Виконання згенерованого коду**: Запускає згенерований код для отримання актуальної інформації.
4. **Генерація маршруту**: Компонує отримані дані в персоналізований план подорожі.
5. **Коригування на основі зворотного зв'язку**: Отримує відгуки від користувача і за необхідності генерує код заново для уточнення результатів.

#### Покрокова реалізація

1. **Збирання вподобань користувача**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генерація коду для отримання даних**

   ```python
   def generate_code_to_fetch_data(preferences):
       # Приклад: Згенерувати код для пошуку рейсів на основі уподобань користувача
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # Приклад: Згенерувати код для пошуку готелів
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **Виконання згенерованого коду**

   ```python
   def execute_code(code):
       # Виконайте згенерований код за допомогою exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **Генерація маршруту**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **Коригування на основі зворотного зв'язку**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # Налаштувати параметри на основі відгуків користувача
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # Перегенерувати та виконати код із оновленими налаштуваннями
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### Використання усвідомлення середовища та міркування

Урахування схеми таблиці дійсно може покращити процес генерації запитів, використовуючи усвідомлення середовища та міркування.

Ось приклад того, як це можна зробити:

1. **Розуміння схеми**: Система розуміє схему таблиці й використовує цю інформацію, щоб грунтувати генерацію запитів.
2. **Коригування на основі зворотного зв'язку**: Система коригує вподобання користувача на основі відгуків і міркує, які поля у схемі потрібно оновити.
3. **Генерація та виконання запитів**: Система генерує та виконує запити для отримання оновлених даних про рейси та готелі на основі нових вподобань.

Ось оновлений приклад коду на Python, що враховує ці концепції:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # Коригувати налаштування на основі відгуків користувача
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # Міркування на основі схеми для коригування інших пов'язаних налаштувань
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # Спеціальна логіка для коригування налаштувань на основі схеми та відгуків
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # Згенерувати код для отримання даних про рейси на основі оновлених налаштувань
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # Згенерувати код для отримання даних про готелі на основі оновлених налаштувань
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # Симулювати виконання коду та повернути заглушкові дані
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # Згенерувати маршрут на основі рейсів, готелів і визначних пам'яток
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# Приклад схеми
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# Приклад використання
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# Перегенерувати та виконати код з оновленими налаштуваннями
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### Пояснення - бронювання на основі зворотного зв'язку

1. **Усвідомлення схеми**: Словник `schema` визначає, як вподобання слід коригувати на основі відгуків. Він містить поля, такі як `favorites` та `avoid`, з відповідними коригуваннями.
2. **Коригування вподобань (`adjust_based_on_feedback` method)**: Цей метод коригує вподобання на основі відгуків користувача та схеми.
3. **Коригування на основі середовища (`adjust_based_on_environment` method)**: Цей метод налаштовує коригування залежно від схеми та відгуків.
4. **Генерація та виконання запитів**: Система генерує код для отримання оновлених даних про рейси та готелі на основі відкоригованих вподобань і симулює виконання цих запитів.
5. **Генерація маршруту**: Система створює оновлений маршрут на основі нових даних про рейси, готелі та визначні місця.

Зробивши систему усвідомленою щодо середовища та застосувавши міркування на основі схеми, вона може генерувати більш точні та релевантні запити, що призводить до кращих рекомендацій щодо подорожей і персоналізованого досвіду користувача.

### Використання SQL як техніки Retrieval-Augmented Generation (RAG)

SQL (Structured Query Language) — потужний інструмент для взаємодії з базами даних. Коли його використовують як частину підходу Retrieval-Augmented Generation (RAG), SQL може витягувати релевантні дані з баз даних, щоб інформувати та генерувати відповіді або дії в AI-агентах. Розглянемо, як SQL можна використовувати як техніку RAG у контексті Агента подорожей.

#### Ключові концепції

1. **Взаємодія з базою даних**:
   - SQL використовується для запитів до баз даних, отримання релевантної інформації та маніпуляції даними.
   - Приклад: отримання деталей рейсів, інформації про готелі та визначні місця з бази даних подорожей.

2. **Інтеграція з RAG**:
   - SQL-запити генеруються на основі вводу користувача та вподобань.
   - Отримані дані використовуються для генерації персоналізованих рекомендацій або дій.

3. **Динамічна генерація запитів**:
   - AI-агент генерує динамічні SQL-запити залежно від контексту та потреб користувача.
   - Приклад: налаштування SQL-запитів для фільтрації результатів за бюджетом, датами та інтересами.

#### Застосування

- **Автоматизована генерація коду**: Генерація фрагментів коду для конкретних завдань.
- **SQL як RAG**: Використання SQL-запитів для маніпуляції даними.
- **Вирішення задач**: Створення та виконання коду для розв’язання проблем.

**Приклад**:
Агент з аналізу даних:

1. **Завдання**: Проаналізувати набір даних, щоб знайти тенденції.
2. **Кроки**:
   - Завантажити набір даних.
   - Згенерувати SQL-запити для фільтрації даних.
   - Виконати запити та отримати результати.
   - Створити візуалізації та інсайти.
3. **Ресурси**: Доступ до набору даних, можливості роботи з SQL.
4. **Досвід**: Використовувати попередні результати для покращення майбутніх аналізів.

#### Практичний приклад: використання SQL в Агенті подорожей

1. **Збирання вподобань користувача**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генерація SQL-запитів**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **Виконання SQL-запитів**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **Генерація рекомендацій**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### Приклад SQL-запитів

1. **Запит для рейсів**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **Запит для готелів**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **Запит для визначних місць**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

Використовуючи SQL як частину техніки Retrieval-Augmented Generation (RAG), AI-агенти, такі як Агент подорожей, можуть динамічно отримувати та використовувати релевантні дані для надання точних і персоналізованих рекомендацій.

### Приклад метакогніції

Щоб продемонструвати реалізацію метакогніції, створимо простого агента, який відображає свій процес прийняття рішень під час вирішення задачі. У цьому прикладі ми побудуємо систему, де агент намагається оптимізувати вибір готелю, а потім оцінює власне міркування й коригує стратегію, коли робить помилки або приймає субоптимальні рішення.

Ми симулюватимемо це на базовому прикладі, де агент обирає готелі на основі поєднання ціни та якості, але потім «рефлексує» над своїми рішеннями та коригує їх відповідно.

#### Як це ілюструє метакогніцію:

1. **Початкове рішення**: Агент обирає найдешевший готель, не враховуючи вплив якості.
2. **Рефлексія та оцінка**: Після початкового вибору агент перевіряє, чи був готель «поганим» вибором за відгуками користувача. Якщо з'ясовується, що якість готелю була занадто низькою, агент рефлексує над своїм міркуванням.
3. **Коригування стратегії**: Агент коригує свою стратегію на основі рефлексії — переключається з «найдешевший» на «найвища_якість», покращуючи процес прийняття рішень у майбутніх ітераціях.

Ось приклад:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # Зберігає раніше обрані готелі
        self.corrected_choices = []  # Зберігає скориговані вибори
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # Доступні стратегії

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # Припустимо, у нас є відгук користувача, який повідомляє, чи був останній вибір вдалим чи ні
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # Скоригувати стратегію, якщо попередній вибір був незадовільним
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# Зімітувати список готелів (ціна та якість)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# Створити агента
agent = HotelRecommendationAgent()

# Крок 1: Агент рекомендує готель, використовуючи "найдешевшу" стратегію
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# Крок 2: Агент аналізує вибір і за потреби коригує стратегію
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# Крок 3: Агент знову рекомендує, цього разу використовуючи скориговану стратегію
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### Здібності агента до метакогніції

Ключове тут — здатність агента:
- Оцінювати свої попередні вибори та процес прийняття рішень.
- Коригувати свою стратегію на основі цієї рефлексії, тобто метакогніція в дії.

Це проста форма метакогніції, де система здатна коригувати свій процес міркування на основі внутрішнього зворотного зв'язку.

### Висновок

Метакогніція — потужний інструмент, який може значно підвищити можливості AI-агентів. Інтегруючи метакогнітивні процеси, ви можете проєктувати агентів, які більш інтелектуальні, адаптивні та ефективні. Скористайтеся додатковими ресурсами, щоб далі досліджувати захопливий світ метакогніції в AI-агентах.

### Є ще питання щодо шаблону проєктування метакогніції?

Приєднуйтесь до [Discord спільноти Microsoft Foundry](https://aka.ms/ai-agents/discord), щоб зустрітися з іншими учнями, відвідати години консультацій і отримати відповіді на свої питання щодо AI-агентів.

## Попередній урок

[Шаблон мультиагентного проєктування](../08-multi-agent/README.md)

## Наступний урок

[AI-агенти у продакшені](../10-ai-agents-production/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**Відмова від відповідальності**:
Цей документ було перекладено з використанням сервісу перекладу на базі ШІ [Co-op Translator](https://github.com/Azure/co-op-translator). Хоча ми прагнемо до точності, просимо врахувати, що автоматичні переклади можуть містити помилки або неточності. Оригінальний документ мовою оригіналу слід вважати авторитетним джерелом. Для критично важливої інформації рекомендується звертатися до професійного перекладу, виконаного людиною. Ми не несемо відповідальності за будь-які непорозуміння або неправильні тлумачення, що виникли внаслідок використання цього перекладу.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->