[![کثیر ایجنٹ ڈیزائن](../../../translated_images/ur/lesson-9-thumbnail.38059e8af1a5b71d.webp)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(اوپر والی تصویر پر کلک کریں تاکہ اس سبق کی ویڈیو دیکھ سکیں)_
# AI ایجنٹس میں میٹاگنیشن

## تعارف

خوش آمدید اس سبق میں جو AI ایجنٹس میں میٹاگنیشن پر مبنی ہے! یہ باب اُن مبتدیوں کے لیے تیار کیا گیا ہے جو جاننا چاہتے ہیں کہ AI ایجنٹس اپنی سوچ کے عمل کے بارے میں کیسے سوچ سکتے ہیں۔ اس سبق کے اختتام تک، آپ کلیدی تصورات سمجھ سکیں گے اور عملی مثالوں کے ساتھ خود میٹاگنیشن کو AI ایجنٹ ڈیزائن میں نافذ کرنے کے قابل ہوں گے۔

## سیکھنے کے مقاصد

اس سبق کو مکمل کرنے کے بعد، آپ قابل ہو جائیں گے:

1. ایجنٹ تعریفوں میں استدلالی لوپس کے مضمرات کو سمجھنا۔
2. خود درست کرنے والے ایجنٹس کی مدد کے لیے منصوبہ بندی اور تشخیص تکنیکوں کا استعمال کرنا۔
3. ایسے ایجنٹس بنانا جو کام مکمل کرنے کے لیے کوڈ میں تبدیلیاں کر سکیں۔

## میٹاگنیشن کا تعارف

میٹاگنیشن سے مراد اعلیٰ درجے کے ادراکی عمل ہیں جو کسی کی اپنی سوچ کے بارے میں سوچنے سے متعلق ہوتے ہیں۔ AI ایجنٹس کے لیے، اس کا مطلب یہ ہے کہ وہ اپنی خود آگاہی اور ماضی کے تجربات کی بنیاد پر اپنے اعمال کا اندازہ لگا کر انہیں ایڈجسٹ کرسکیں۔ میٹاگنیشن، یا "سوچ کے بارے میں سوچنا"، ایجنٹک AI نظاموں کی ترقی میں ایک اہم تصور ہے۔ اس سے مراد AI نظاموں کا اپنے اندرونی عمل سے واقف ہونا اور اپنے طرز عمل کی نگرانی، نظم و ضبط، اور تطبیق کرنے کی صلاحیت رکھنا ہے۔ بالکل اسی طرح جیسے ہم کسی مسئلے کو دیکھتے یا ماحول کا جائزہ لیتے ہیں۔ یہ خود آگاہی AI نظاموں کو بہتر فیصلے کرنے، غلطیوں کی نشاندہی کرنے، اور وقت کے ساتھ اپنی کارکردگی بہتر بنانے میں مدد دیتی ہے — اور یہ دوبارہ Turing test اور اس بحث سے منسلک ہوتی ہے کہ آیا AI قابو حاصل کرے گا یا نہیں۔

ایجنٹک AI نظاموں کے سیاق میں، میٹاگنیشن متعدد چیلنجز کو حل کرنے میں مدد کر سکتی ہے، جیسے:
- Transparency: یہ یقینی بنانا کہ AI نظام اپنے استدلال اور فیصلوں کی وضاحت کر سکیں۔
- Reasoning: AI نظاموں کی معلومات کو ترکیب کرنے اور معقول فیصلے کرنے کی صلاحیت کو بہتر بنانا۔
- Adaptation: AI نظاموں کو نئے ماحول اور تبدیل ہوتے حالات کے مطابق ڈھالنے کی اجازت دینا۔
- Perception: ماحول سے ڈیٹا کو پہچاننے اور تشریح کرنے میں AI نظاموں کی درستگی کو بہتر بنانا۔

### میٹاگنیشن کیا ہے؟

میٹاگنیشن، یا "سوچ کے بارے میں سوچنا"، ایک اعلیٰ درجے کا ادراکی عمل ہے جو کسی کے ادراکی عمل کی خود آگاہی اور خود نظم و ضبط پر مشتمل ہوتا ہے۔ AI کے دائرے میں، میٹاگنیشن ایجنٹس کو اپنی حکمتِ عملیاں اور اعمال کا جائزہ لینے اور انہیں ایڈجسٹ کرنے کے قابل بناتی ہے، جس سے مسئلہ حل کرنے اور فیصلہ سازی کی صلاحیتوں میں بہتری آتی ہے۔ میٹاگنیشن کو سمجھ کر، آپ ایسے AI ایجنٹس ڈیزائن کر سکتے ہیں جو نہ صرف زیادہ ہوشیار بلکہ زیادہ مطابقت پذیر اور موثر ہوں۔ حقیقی میٹاگنیشن میں، آپ AI کو واضح طور پر اپنے اپنے استدلال کے بارے میں استدلال کرتے ہوئے دیکھیں گے۔

مثال: “میں نے سستی پروازوں کو ترجیح دی کیونکہ… شاید میں بذریعہ پروازوں سے محروم ہوں، اس لیے مجھے دوبارہ چیک کرنا چاہیے۔”  
کسی مخصوص روٹ کو منتخب کرنے کے طریقے یا وجہ کو ٹریک کرنا۔  
- اس بات کو نوٹ کرنا کہ اس نے غلطیاں اس لیے کیں کیونکہ وہ پچھلی بار صارف کی ترجیحات پر زیادہ انحصار کر رہا تھا، لہٰذا وہ صرف آخری سفارش نہیں بلکہ اپنے فیصلہ سازی کے طریقے میں تبدیلی کرتا ہے۔  
- ایسے نمونوں کی تشخیص کرنا جیسے، “جب بھی میں صارف کو 'بہت بھیڑ ہے' کہتے ہوئے دیکھتا ہوں، مجھے نہ صرف کچھ سیاحتی مقامات ہٹانے چاہئیں بلکہ یہ بھی غور کرنا چاہیے کہ اگر میں ہمیشہ مقبولیت کے مطابق درجہ بندی کرتا ہوں تو 'سر فہرست مقامات' کا انتخاب کرنے کا میرا طریقہ غلط ہے۔”

### AI ایجنٹس میں میٹاگنیشن کی اہمیت

میٹاگنیشن AI ایجنٹ ڈیزائن میں کئی وجوہات کی بنا پر اہم کردار ادا کرتی ہے:

![میٹاگنیشن کی اہمیت](../../../translated_images/ur/importance-of-metacognition.b381afe9aae352f7.webp)

- Self-Reflection: ایجنٹس اپنی کارکردگی کا اندازہ لگا سکتے ہیں اور بہتری کے لئے شعبوں کی نشاندہی کر سکتے ہیں۔
- Adaptability: ایجنٹس ماضی کے تجربات اور بدلتے ہوئے ماحول کی بنیاد پر اپنی حکمت عملیوں میں تبدیلی کر سکتے ہیں۔
- Error Correction: ایجنٹس خود مختار طور پر غلطیوں کا پتہ لگا کر انہیں درست کر سکتے ہیں، جس کے نتیجے میں زیادہ درست نتائج حاصل ہوتے ہیں۔
- Resource Management: ایجنٹس وسائل جیسے وقت اور حسابی طاقت کے استعمال کو منصوبہ بندی اور تشخیص کرکے بہتر بنا سکتے ہیں۔

## AI ایجنٹ کے اجزاء

میٹاگنیشن کے عمل میں داخل ہونے سے پہلے، AI ایجنٹ کے بنیادی اجزاء کو سمجھنا ضروری ہے۔ ایک AI ایجنٹ عام طور پر مشتمل ہوتا ہے:

- Persona: ایجنٹ کی شخصیت اور خصوصیات، جو بتاتی ہیں کہ وہ صارفین کے ساتھ کیسے بات چیت کرتا ہے۔
- Tools: وہ صلاحیتیں اور افعال جو ایجنٹ انجام دے سکتا ہے۔
- Skills: وہ علم اور مہارتیں جو ایجنٹ کے پاس ہیں۔

یہ اجزاء مل کر ایک "expertise unit" بناتے ہیں جو مخصوص کام انجام دے سکتی ہے۔

**Example**:  
ایک ٹریول ایجنٹ کا تصور کریں، ایسی ایجنٹ خدمات جو نہ صرف آپ کی چھٹی منصوبہ بندی کرتی ہیں بلکہ حقیقی وقت کے ڈیٹا اور ماضی کے کسٹمر سفر کے تجربات کی بنیاد پر اپنا راستہ بھی ایڈجسٹ کرتی ہیں۔

### مثال: ایک ٹریول ایجنٹ سروس میں میٹاگنیشن

تصور کریں کہ آپ ایک AI سے چلنے والی ٹریول ایجنٹ سروس ڈیزائن کر رہے ہیں۔ یہ ایجنٹ، "Travel Agent"، صارفین کو ان کی تعطیلات کی منصوبہ بندی میں مدد کرتا ہے۔ میٹاگنیشن شامل کرنے کے لیے، Travel Agent کو اپنی خود آگاہی اور ماضی کے تجربات کی بنیاد پر اپنے اعمال کا جائزہ لے کر انہیں ایڈجسٹ کرنے کی ضرورت ہے۔ یہاں میٹاگنیشن کس طرح کردار ادا کر سکتی ہے:

#### موجودہ کام

موجودہ کام صارف کی پیرس کی سفر کی منصوبہ بندی میں مدد کرنا ہے۔

#### کام مکمل کرنے کے مراحل

1. **صارف کی ترجیحات اکٹھی کریں**: صارف سے ان کی سفر کی تاریخیں، بجٹ، دلچسپیاں (مثلاً عجائب گھر، ذائقہ، خریداری) اور کوئی خاص ضروریات پوچھیں۔  
2. **معلومات حاصل کریں**: پروازوں کے اختیارات، رہائش، مقامات، اور ریستوران تلاش کریں جو صارف کی ترجیحات سے میل کھاتے ہوں۔  
3. **سفارشات تیار کریں**: فلائٹ کی تفصیلات، ہوٹل کی بکنگ، اور مجوزہ سرگرمیوں کے ساتھ ایک ذاتی روٹین فراہم کریں۔  
4. **تبصرے کی بنیاد پر ایڈجسٹ کریں**: سفارشات پر صارف کی رائے لیں اور ضروری تبدیلیاں کریں۔

#### درکار وسائل

- فلائٹ اور ہوٹل بکنگ ڈیٹا بیس تک رسائی۔  
- پیرس کے مقامات اور ریستورانوں کی معلومات۔  
- پچھلی تعاملات سے صارف فیڈبیک ڈیٹا۔

#### تجربہ اور خود انعکاس

Travel Agent اپنی کارکردگی کا جائزہ لینے اور ماضی کے تجربات سے سیکھنے کے لیے میٹاگنیشن استعمال کرتا ہے۔ مثال کے طور پر:

1. **صارف کے فیڈبیک کا تجزیہ**: Travel Agent صارف کے فیڈبیک کا جائزہ لیتا ہے تاکہ پتہ چل سکے کون سی سفارشات پسند کی گئیں اور کون سی نہیں۔ وہ اپنی مستقبل کی تجاویز کو اسی کے مطابق ایڈجسٹ کرتا ہے۔  
2. **مطابقت پذیری**: اگر کسی صارف نے پہلے بھیڑ والے مقامات سے نفرت ظاہر کی ہے، تو Travel Agent مستقبل میں مصروف اوقات میں مقبول سیاحتی جگہوں کی سفارش کرنے سے گریز کرے گا۔  
3. **غلطی کی اصلاح**: اگر Travel Agent نے ماضی کی بکنگ میں غلطی کی، جیسے ایسا ہوٹل تجویز کیا جو مکمل بک تھا، تو وہ سفارشات کرنے سے پہلے دستیابی کو زیادہ سختی سے چیک کرنا سیکھتا ہے۔

#### عملی ڈویلپر مثال

یہاں ایک سادہ مثال ہے کہ جب Travel Agent میں میٹاگنیشن شامل کی جاتی ہے تو اس کا کوڈ کیسا دکھ سکتا ہے:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # اپنی ترجیحات کی بنیاد پر پروازوں، ہوٹلوں اور سیاحتی مقامات کی تلاش کریں
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # رائے کا تجزیہ کریں اور مستقبل کی سفارشات کو ایڈجسٹ کریں
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# استعمال کی مثال
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### میٹاگنیشن کیوں اہم ہے

- **Self-Reflection**: ایجنٹس اپنی کارکردگی کا تجزیہ کر سکتے ہیں اور بہتری کے شعبوں کی شناخت کر سکتے ہیں۔  
- **Adaptability**: ایجنٹس فیڈبیک اور بدلتے ہوئے حالات کی بنیاد پر حکمت عملیوں میں تبدیلی کر سکتے ہیں۔  
- **Error Correction**: ایجنٹس خود مختار طور پر غلطیوں کا پتہ لگا کر انہیں درست کر سکتے ہیں۔  
- **Resource Management**: ایجنٹس وسائل کے استعمال کو بہتر بنا سکتے ہیں، جیسے وقت اور حسابی طاقت۔

میٹاگنیشن کو شامل کر کے، Travel Agent زیادہ ذاتی نوعیت اور درست سفر کی سفارشات فراہم کر سکتا ہے، جس سے مجموعی صارف تجربہ بہتر ہوتا ہے۔

---

## 2. ایجنٹس میں منصوبہ بندی

منصوبہ بندی AI ایجنٹ کے طرز عمل کا ایک اہم جزو ہے۔ اس میں کسی ہدف کے حصول کے لیے درکار اقدامات کا خاکہ شامل ہوتا ہے، موجودہ حالت، وسائل، اور ممکنہ رکاوٹوں کو مدنظر رکھتے ہوئے۔

### منصوبہ بندی کے عناصر

- **Current Task**: کام کو واضح طور پر متعین کریں۔  
- **Steps to Complete the Task**: کام کو قابلِ انتظام مرحلوں میں تقسیم کریں۔  
- **Required Resources**: ضروری وسائل کی نشاندہی کریں۔  
- **Experience**: منصوبہ بندی کو مطلع کرنے کے لیے ماضی کے تجربات کا استعمال کریں۔

**Example**:  
یہاں وہ مراحل ہیں جو Travel Agent کو صارف کی مدد کے لیے موثر طور پر پورے سفر کی منصوبہ بندی میں اٹھانے چاہئیں:

### ٹریول ایجنٹ کے لیے اقدامات

1. **صارف کی ترجیحات اکٹھی کریں**  
   - صارف سے ان کی سفر کی تاریخوں، بجٹ، دلچسپیوں، اور کسی مخصوص ضرورت کے بارے میں پوچھیں۔  
   - مثالیں: "آپ کب سفر کرنے کا ارادہ رکھتے ہیں؟" "آپ کا بجٹ کیا حد ہے؟" "سیر کے دوران آپ کن سرگرمیوں سے لطف اندوز ہوتے ہیں؟"

2. **معلومات حاصل کریں**  
   - صارف کی ترجیحات کی بنیاد پر متعلقہ سفری اختیارات تلاش کریں۔  
   - **Flights**: صارف کے بجٹ اور پسندیدہ سفر کی تاریخوں کے اندر دستیاب پروازیں تلاش کریں۔  
   - **Accommodations**: ایسی ہوٹلز یا کرایے کی جائدادیں تلاش کریں جو مقام، قیمت، اور سہولیات کے لحاظ سے صارف کی ترجیحات سے میل کھاتی ہوں۔  
   - **Attractions and Restaurants**: مقبول مقامات، سرگرمیاں، اور کھانے پینے کے اختیارات شناخت کریں جو صارف کی دلچسپیوں سے مطابقت رکھتے ہوں۔

3. **سفارشات تیار کریں**  
   - حاصل کردہ معلومات کو ذاتی روٹین میں مرتب کریں۔  
   - ایسی تفصیلات فراہم کریں جیسے فلائٹ کے اختیارات، ہوٹل کی بکنگز، اور مجوزہ سرگرمیاں، یہ یقینی بناتے ہوئے کہ سفارشات صارف کی ترجیحات کے مطابق ہوں۔

4. **روٹین صارف کو پیش کریں**  
   - مجوزہ روٹین کو صارف کے جائزے کے لیے شیئر کریں۔  
   - مثال: "یہ آپ کے پیرس کے سفر کے لیے مجوزہ روٹین ہے۔ اس میں فلائٹ کی تفصیلات، ہوٹل کی بکنگ، اور مجوزہ سرگرمیوں اور ریستورانوں کی فہرست شامل ہے۔ اپنی رائے بتائیں!"

5. **فیڈبیک جمع کریں**  
   - مجوزہ روٹین پر صارف سے فیڈبیک طلب کریں۔  
   - مثالیں: "کیا آپ کو فلائٹ کے اختیارات پسند ہیں؟" "کیا ہوٹل آپ کی ضروریات کے مطابق ہے؟" "کیا ایسی کوئی سرگرمیاں ہیں جنہیں آپ شامل یا خارج کرنا چاہتے ہیں؟"

6. **فیڈبیک کی بنیاد پر ایڈجسٹ کریں**  
   - صارف کے فیڈبیک کی بنیاد پر روٹین میں تبدیلیاں کریں۔  
   - فلائٹ، رہائش، اور سرگرمیوں کی سفارشات کو صارف کی ترجیحات کے مطابق بہتر بنائیں۔

7. **حتمی تصدیق**  
   - اپڈیٹ شدہ روٹین کو حتمی تصدیق کے لیے صارف کے سامنے رکھیں۔  
   - مثال: "میں نے آپ کی فیڈبیک کی بنیاد پر تبدیلیاں کر دی ہیں۔ یہاں اپڈیٹ شدہ روٹین ہے۔ کیا سب ٹھیک لگ رہا ہے؟"

8. **بکنگ اور تصدیق کریں**  
   - جب صارف روٹین کی منظوری دے دے، تو فلائٹس، رہائش، اور کسی پیشگی منصوبہ بند سرگرمیوں کی بکنگ کریں۔  
   - صارف کو تصدیقی تفصیلات ارسال کریں۔

9. **مسلسل مدد فراہم کریں**  
   - سفر سے پہلے اور دورانِ سفر کسی بھی تبدیلی یا اضافی درخواست میں صارف کی مدد کے لیے دستیاب رہیں۔  
   - مثال: "اگر آپ کو سفر کے دوران مزید مدد کی ضرورت ہو تو کسی بھی وقت مجھ سے رابطہ کریں!"

### مثال تعامل

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# بو کرنے کی درخواست کے اندر استعمال کی مثال
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. اصلاحی RAG نظام

سب سے پہلے آئیے RAG Tool اور Pre-emptive Context Load کے درمیان فرق کو سمجھنے سے آغاز کریں

![RAG بمقابلہ سیاق و سباق لوڈنگ](../../../translated_images/ur/rag-vs-context.9eae588520c00921.webp)

### Retrieval-Augmented Generation (RAG)

RAG ایک retrieval سسٹم کو generative ماڈل کے ساتھ ملا دیتا ہے۔ جب کوئی سوال کیا جاتا ہے، تو retrieval سسٹم بیرونی ماخذ سے متعلقہ دستاویزات یا ڈیٹا لاتا ہے، اور یہ بازیافت شدہ معلومات جنریٹو ماڈل کے ان پٹ کو تقویت دینے کے لیے استعمال ہوتی ہیں۔ اس سے ماڈل کو زیادہ درست اور سیاق و سباق کے مطابق جوابات پیدا کرنے میں مدد ملتی ہے۔

ایک RAG نظام میں، ایجنٹ متعلقہ معلومات کو ایک علم کے ذخیرے سے بازیافت کرتا ہے اور مناسب جوابات یا اعمال پیدا کرنے کے لیے اس کا استعمال کرتا ہے۔

### اصلاحی RAG طریقۂ کار

اصلاحی RAG طریقہ کار RAG تکنیکس کو غلطیوں کی اصلاح اور AI ایجنٹس کی درستگی بہتر بنانے کے لیے استعمال کرنے پر مرکوز ہے۔ اس میں شامل ہے:

1. **Prompting Technique**: مخصوص پرامپٹس کا استعمال کر کے ایجنٹ کو متعلقہ معلومات بازیافت کرنے کی رہنمائی کرنا۔  
2. **Tool**: الگورتھم اور میکنزم نافذ کرنا جو ایجنٹ کو بازیافت شدہ معلومات کی مطابقت کا اندازہ لگانے اور درست جوابات پیدا کرنے کے قابل بنائیں۔  
3. **Evaluation**: ایجنٹ کی کارکردگی کا مستقل جائزہ لینا اور اس کی درستگی اور کارکردگی کو بہتر بنانے کے لیے ایڈجسٹمنٹ کرنا۔

#### مثال: سرچ ایجنٹ میں اصلاحی RAG

ایک سرچ ایجنٹ پر غور کریں جو صارف کے سوالات کا جواب دینے کے لیے ویب سے معلومات بازیافت کرتا ہے۔ اصلاحی RAG طریقہ کار میں شامل ہو سکتا ہے:

1. **Prompting Technique**: صارف کے ان پٹ کی بنیاد پر تلاش کے سوالات تیار کرنا۔  
2. **Tool**: نیچرل لینگویج پروسیسنگ اور مشین لرننگ الگورتھم کا استعمال کر کے تلاش کے نتائج کو درجہ بندی اور فلٹر کرنا۔  
3. **Evaluation**: بازیافت شدہ معلومات کی غلطیوں کی شناخت اور درستگی کے لیے صارف کے فیڈبیک کا تجزیہ کرنا۔

### ٹریول ایجنٹ میں اصلاحی RAG

اصلاحی RAG (Retrieval-Augmented Generation) AI کی بازیافت اور تولیدی صلاحیتوں کو بہتر بناتا ہے جبکہ کسی بھی غلطی کو درست بھی کرتا ہے۔ آئیے دیکھتے ہیں کہ Travel Agent اصلاحی RAG طریقہ کار کو کیسے استعمال کر سکتا ہے تاکہ زیادہ درست اور متعلقہ سفری سفارشات فراہم کی جا سکیں۔

اس میں شامل ہے:

- **Prompting Technique:** مخصوص پرامپٹس کا استعمال کر کے ایجنٹ کو متعلقہ معلومات بازیافت کرنے کی رہنمائی کرنا۔  
- **Tool:** الگورتھم اور میکنزم نافذ کرنا جو ایجنٹ کو بازیافت شدہ معلومات کی مطابقت کا اندازہ لگانے اور درست جوابات پیدا کرنے کے قابل بنائیں۔  
- **Evaluation:** ایجنٹ کی کارکردگی کا مستقل جائزہ لینا اور اس کی درستگی اور کارکردگی کو بہتر بنانے کے لیے ایڈجسٹمنٹ کرنا۔

#### ٹریول ایجنٹ میں اصلاحی RAG نافذ کرنے کے اقدامات

1. **ابتدائی صارف تعامل**  
   - Travel Agent صارف سے ابتدائی ترجیحات جمع کرتا ہے، جیسے منزل، سفر کی تاریخیں، بجٹ، اور دلچسپیاں۔  
   - مثال:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **معلومات کی بازیافت**  
   - Travel Agent صارف کی ترجیحات کی بنیاد پر فلائٹس، رہائش، مقامات، اور ریستورانوں کے بارے میں معلومات بازیافت کرتا ہے۔  
   - مثال:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **ابتدائی سفارشات تیار کرنا**  
   - Travel Agent بازیافت شدہ معلومات استعمال کر کے ایک ذاتی روٹین تیار کرتا ہے۔  
   - مثال:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **صارف سے فیڈبیک جمع کرنا**  
   - Travel Agent ابتدائی سفارشات پر صارف سے فیڈبیک مانگتا ہے۔  
   - مثال:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **اصلاحی RAG عمل**  
   - **Prompting Technique**: Travel Agent صارف کے فیڈبیک کی بنیاد پر نئے تلاش کے سوالات تیار کرتا ہے۔  
     - مثال:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **Tool**: Travel Agent نئے تلاش کے نتائج کو درجہ بندی اور فلٹر کرنے کے لیے الگورتھم استعمال کرتا ہے، اور صارف کے فیڈبیک کی بنیاد پر مطابقت کو اہمیت دیتا ہے۔  
     - مثال:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **Evaluation**: Travel Agent اپنے سفارشات کی مطابقت اور درستگی کا مسلسل اندازہ صارف کے فیڈبیک کا تجزیہ کر کے اور ضروری تبدیلیاں کر کے لگاتا ہے۔  
     - مثال:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### عملی مثال

یہاں Travel Agent میں اصلاحی RAG طریقہ کار شامل کرنے کی ایک سادہ Python کوڈ مثال ہے:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# استعمال کی مثال
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### پیشگی سیاق و سباق لوڈ
‏Pre-emptive Context Load کا مطلب ہے کہ ماڈل کو کسی سوال کو پروسیس کرنے سے پہلے متعلقہ سیاق و سباق یا پس منظر کی معلومات لوڈ کر دی جائیں۔ اس کا مطلب یہ ہے کہ ماڈل شروع سے ہی ان معلومات تک رسائی رکھتا ہے، جو اسے عمل کے دوران اضافی ڈیٹا بازیافت کیے بغیر زیادہ باخبر جوابات تیار کرنے میں مدد دیتی ہے۔

ذیل میں ایک سادہ مثال ہے کہ ایک ٹریول ایجنٹ ایپلیکیشن کے لیے پری-امپٹیو کانٹیکسٹ لوڈ Python میں کس طرح دکھائی دے سکتی ہے:

```python
class TravelAgent:
    def __init__(self):
        # مقبول مقامات اور ان کی معلومات کو پہلے سے لوڈ کریں
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # پہلے سے لوڈ کیے گئے سیاق و سباق سے منزل کی معلومات حاصل کریں
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# استعمال کی مثال
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### وضاحت

1. **Initialization (`__init__` method)**: کلاس `TravelAgent` پہلے سے ایک ڈکشنری لوڈ کرتی ہے جس میں مقبول منزلوں جیسے Paris، Tokyo، New York، اور Sydney کے بارے میں معلومات شامل ہیں۔ اس ڈکشنری میں ہر منزل کے لیے ملک، کرنسی، زبان، اور اہم سیاحتی مقامات جیسی تفصیلات شامل ہیں۔

2. **Retrieving Information (`get_destination_info` method)**: جب کوئی صارف کسی مخصوص منزل کے بارے میں پوچھتا ہے، تو `get_destination_info` طریقہ پہلے سے لوڈ شدہ کانٹیکسٹ ڈکشنری سے متعلقہ معلومات حاصل کرتا ہے۔

کانٹیکسٹ کو پہلے سے لوڈ کر کے، ٹریول ایجنٹ ایپلیکیشن صارف کے سوالات کے جوابات تیزی سے دے سکتی ہے بغیر یہ کہ عمل کے دوران بیرونی ذرائع سے معلومات بازیافت کرنے کی ضرورت ہو۔ اس سے ایپلیکیشن زیادہ موثر اور فوری ہو جاتی ہے۔

### دہرائی سے پہلے مقصد کے ساتھ منصوبہ شروعات کرنا

مقصد کے ساتھ ایک منصوبہ شروعات کرنا اس میں شامل ہے کہ ایک واضح ہدف یا متوقع نتیجہ ذہن میں رکھ کر آغاز کیا جائے۔ اس مقصد کو پہلے سے متعین کر کے، ماڈل اسے دہرائی کے پورے عمل میں رہنما اصول کے طور پر استعمال کر سکتا ہے۔ اس سے ہر تکرار اس مقررہ نتیجے کے حصول کے قریب جاتی ہے، جس سے عمل زیادہ مؤثر اور مرکوز بنتا ہے۔

ذیل میں ایک مثال ہے کہ آپ کس طرح ایک ٹریول پلان کو مقصد کے ساتھ شروعات کر کے دہرائی کر سکتے ہیں (Python میں):

### منظر نامہ

ایک ٹریول ایجنٹ اپنے کلائنٹ کے لیے ایک حسبِ ضرورت تعطیلات کا منصوبہ بنانا چاہتا ہے۔ مقصد یہ ہے کہ کلائنٹ کی ترجیحات اور بجٹ کی بنیاد پر ایک سفر کا شیڈول بنایا جائے جو کلائنٹ کی اطمینان کو زیادہ سے زیادہ کرے۔

### مراحل

1. کلائنٹ کی ترجیحات اور بجٹ کی تعریف کریں۔
2. ان ترجیحات کی بنیاد پر ابتدائی منصوبہ شروعات کریں۔
3. منصوبے کو بہتر بنانے کے لیے تَکرار کریں، اور کلائنٹ کی اطمینان کو بہتر بنائیں۔

#### Python Code

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# استعمال کی مثال
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### کوڈ کی وضاحت

1. **Initialization (`__init__` method)**: کلاس `TravelAgent` ممکنہ منزلوں کی ایک فہرست کے ساتھ شروع ہوتی ہے، ہر ایک میں نام، قیمت، اور سرگرمی کی قسم جیسی خصوصیات شامل ہوتی ہیں۔

2. **Bootstrapping the Plan (`bootstrap_plan` method)**: یہ طریقہ کلائنٹ کی ترجیحات اور بجٹ کی بنیاد پر ایک ابتدائی سفر کا منصوبہ بناتا ہے۔ یہ منزلوں کی فہرست پر تَکرار کرتا ہے اور انہیں منصوبے میں شامل کرتا ہے اگر وہ کلائنٹ کی ترجیحات سے میل کھاتے ہوں اور بجٹ کے اندر fit ہوں۔

3. **Matching Preferences (`match_preferences` method)**: یہ طریقہ چیک کرتا ہے کہ آیا کوئی منزل کلائنٹ کی ترجیحات سے میل کھاتی ہے۔

4. **Iterating the Plan (`iterate_plan` method)**: یہ طریقہ ابتدائی منصوبے کو بہتر بناتا ہے، ہر منزل کو بہتر متبادل کے ساتھ تبدیل کرنے کی کوشش کرتا ہے، کلائنٹ کی ترجیحات اور بجٹ کی حدود کو مدِنظر رکھتے ہوئے۔

5. **Calculating Cost (`calculate_cost` method)**: یہ طریقہ موجودہ منصوبے کی کل لاگت کا حساب لگاتا ہے، ایک ممکنہ نئی منزل کو شامل کرنے کے ساتھ۔

#### مثال استعمال

- **Initial Plan**: ٹریول ایجنٹ کلائنٹ کی سیر و سیاحت کی ترجیحات اور $2000 کے بجٹ کی بنیاد پر ابتدائی منصوبہ بناتا ہے۔
- **Refined Plan**: ٹریول ایجنٹ منصوبے میں تکرار کر کے کلائنٹ کی ترجیحات اور بجٹ کے مطابق اسے بہتر بناتا ہے۔

مقصد (مثلاً کلائنٹ کی اطمینان کو زیادہ سے زیادہ کرنا) کے ساتھ منصوبہ bootstrap کرنے اور پھر منصوبے کو بہتر بنانے کے لیے تکرار کرنے سے، ٹریول ایجنٹ کلائنٹ کے لیے ایک حسبِ ضرورت اور بہتر شدہ سفر نامہ بنا سکتا ہے۔ اس طریقہ کار سے یقینی بنتا ہے کہ سفر کا منصوبہ شروع سے ہی کلائنٹ کی ترجیحات اور بجٹ کے مطابق ہو اور ہر تکرار کے ساتھ بہتر ہو۔

### LLM کا فائدہ اٹھانا برائے ری-رینکنگ اور سکورنگ

Large Language Models (LLMs) ری-رینکنگ اور سکورنگ کے لیے استعمال کیے جا سکتے ہیں تاکہ بازیافت شدہ دستاویزات یا تخلیق شدہ جوابات کی مطابقت اور معیار کا اندازہ لگایا جا سکے۔ طریقہ کار کچھ یوں ہے:

**Retrieval:** ابتدائی بازیافت کا مرحلہ سوال کی بنیاد پر ممکنہ امیدوار دستاویزات یا جوابات کا مجموعہ حاصل کرتا ہے۔

**Re-ranking:** LLM ان امیدواروں کا جائزہ لیتا ہے اور انہیں ان کی مطابقت اور معیار کی بنیاد پر دوبارہ درجہ بندی کرتا ہے۔ اس مرحلے سے یہ یقینی بنتا ہے کہ سب سے زیادہ متعلقہ اور اعلیٰ معیار کی معلومات پہلے پیش کی جائیں۔

**Scoring:** LLM ہر امیدوار کو اسکور تفویض کرتا ہے جو ان کی مطابقت اور معیار کی عکاسی کرتا ہے۔ اس سے بہترین جواب یا دستاویز منتخب کرنے میں مدد ملتی ہے۔

LLMs کو ری-رینکنگ اور سکورنگ کے لیے استعمال کر کے، سسٹم زیادہ درست اور سیاق و سباق کے مطابق معلومات فراہم کر سکتا ہے، جس سے مجموعی صارف تجربہ بہتر ہوتا ہے۔

ذیل میں ایک مثال ہے کہ کس طرح ایک ٹریول ایجنٹ صارف کی ترجیحات کی بنیاد پر سفر کی منزلوں کو دوبارہ درجہ بندی اور سکور دے سکتا ہے (Python میں):

#### منظر نامہ - ترجیحات کی بنیاد پر سفر

ایک ٹریول ایجنٹ صارف کی ترجیحات کی بنیاد پر بہترین سفر مقامات کی تجویز دینا چاہتا ہے۔ LLM منزلوں کو دوبارہ درجہ بندی اور سکور دے کر یہ یقینی بنائے گا کہ سب سے زیادہ متعلقہ آپشنز پیش کیے جائیں۔

#### مراحل:

1. صارف کی ترجیحات جمع کریں۔
2. ممکنہ سفر مقامات کی فہرست بازیافت کریں۔
3. صارف کی ترجیحات کی بنیاد پر منزلوں کو دوبارہ درجہ بندی اور سکور دینے کے لیے LLM استعمال کریں۔

Here’s how you can update the previous example to use Azure OpenAI Services:

#### Requirements

1. آپ کے پاس Azure سبسکرپشن ہونا چاہیے۔
2. ایک Azure OpenAI resource بنائیں اور اپنا API key حاصل کریں۔

#### Example Python Code

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Azure OpenAI کے لیے ایک پرامپٹ تیار کریں
        prompt = self.generate_prompt(preferences)
        
        # درخواست کے لیے ہیڈرز اور پے لوڈ متعین کریں
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # دوبارہ درجہ بندی شدہ اور اسکور شدہ مقامات حاصل کرنے کے لیے Azure OpenAI API کو کال کریں
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # تجاویز نکال کر واپس کریں
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# استعمال کی مثال
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### کوڈ کی وضاحت - Preference Booker

1. **Initialization**: کلاس `TravelAgent` ممکنہ سفر مقامات کی ایک فہرست کے ساتھ شروع ہوتی ہے، ہر ایک میں نام اور تفصیل جیسی خصوصیات شامل ہیں۔

2. **Getting Recommendations (`get_recommendations` method)**: یہ طریقہ صارف کی ترجیحات کی بنیاد پر Azure OpenAI سروس کے لیے ایک پرامپٹ تیار کرتا ہے اور ری-رینکڈ اور سکور کیے گئے منزلوں کے لیے Azure OpenAI API کو HTTP POST درخواست بھیجتا ہے۔

3. **Generating Prompt (`generate_prompt` method)**: یہ طریقہ Azure OpenAI کے لیے ایک پرامپٹ تیار کرتا ہے، جس میں صارف کی ترجیحات اور منزلوں کی فہرست شامل ہوتی ہے۔ یہ پرامپٹ ماڈل کو رہنمائی کرتا ہے کہ فراہم کردہ ترجیحات کی بنیاد پر منزلوں کو دوبارہ درجہ بندی اور سکور کرے۔

4. **API Call**: `requests` لائبریری Azure OpenAI API endpoint کو HTTP POST درخواست کرنے کے لیے استعمال کی جاتی ہے۔ جواب میں ری-رینکڈ اور سکور کیے گئے منزلیں ملتی ہیں۔

5. **Example Usage**: ٹریول ایجنٹ صارف کی ترجیحات (مثلاً سیر و سیاحت اور متنوع ثقافت میں دلچسپی) جمع کرتا ہے اور ری-رینکڈ اور سکور شدہ سفر کی سفارشات حاصل کرنے کے لیے Azure OpenAI سروس استعمال کرتا ہے۔

یقینی بنائیں کہ `your_azure_openai_api_key` کو اپنے حقیقی Azure OpenAI API کلید سے تبدیل کریں اور `https://your-endpoint.com/...` کو اپنے Azure OpenAI ڈپلائمنٹ کے حقیقی endpoint URL سے بدل دیں۔

LLM کو ری-رینکنگ اور سکورنگ کے لیے استعمال کر کے، ٹریول ایجنٹ اپنے صارفین کو زیادہ شخصی اور متعلقہ سفر کی سفارشات دے سکتا ہے، جس سے ان کا مجموعی تجربہ بہتر ہوتا ہے۔

### RAG: پرامپٹنگ تکنیک بمقابلہ ٹول

Retrieval-Augmented Generation (RAG) دونوں صورتوں میں استعمال ہو سکتا ہے: ایک پرامپٹنگ تکنیک اور ایک ٹول، AI ایجنٹس کی ترقی میں۔ دونوں کے درمیان فرق کو سمجھنا آپ کو اپنے پروجیکٹس میں RAG کا زیادہ مؤثر استعمال کرنے میں مدد دے گا۔

#### RAG بطور پرامپٹنگ تکنیک

**یہ کیا ہے؟**

- بطور پرامپٹنگ تکنیک، RAG مخصوص سوالات یا پرامپٹس کا فارمولا تیار کرنے میں شامل ہوتا ہے تاکہ بڑے کارپس یا ڈیٹا بیس سے متعلقہ معلومات بازیافت کی جا سکیں۔ پھر یہ معلومات جوابات یا اقدامات تیار کرنے کے لیے استعمال ہوتی ہیں۔

**یہ کیسے کام کرتا ہے:**

1. **پرامپٹس تیار کریں**: کام یا صارف کے ان پٹ کی بنیاد پر اچھی طرح ساختہ پرامپٹس یا سوالات بنائیں۔
2. **معلومات بازیافت کریں**: متعلقہ ڈیٹا بیس یا علمی بنیاد سے مواد تلاش کرنے کے لیے پرامپٹس استعمال کریں۔
3. **جواب تیار کریں**: بازیافت شدہ معلومات کو جنریٹو AI ماڈلز کے ساتھ ملا کر ایک مربوط اور جامع جواب تیار کریں۔

**ٹریول ایجنٹ میں مثال**:

- User Input: "میں پیرس میں میوزیم دیکھنا چاہتا/چاہتی ہوں۔"
- Prompt: "پیرس کے بہترین میوزیم تلاش کریں۔"
- Retrieved Information: Louvre Museum، Musée d'Orsay وغیرہ کے بارے میں تفصیلات۔
- Generated Response: "یہاں پیرس کے کچھ بہترین میوزیم ہیں: Louvre Museum، Musée d'Orsay، اور Centre Pompidou۔"

#### RAG بطور ٹول

**یہ کیا ہے؟**

- بطور ٹول، RAG ایک مربوط سسٹم ہے جو بازیافت اور جنریشن کے عمل کو خودکار بناتا ہے، جس سے ڈویلپرز کے لیے پیچیدہ AI فیچرز کو نافذ کرنا آسان ہو جاتا ہے بغیر ہر سوال کے لیے دستی طور پر پرامپٹس تیار کیے۔

**یہ کیسے کام کرتا ہے:**

1. **انٹیگریشن**: RAG کو AI ایجنٹ کی آرکیٹیکچر میں شامل کریں تاکہ یہ بازیافت اور جنریشن کے کام خودکار طور پر سنبھال سکے۔
2. **آٹو میشن**: یہ ٹول پورے عمل کو منجمد کرتا ہے، صارف ان پٹ وصول کرنے سے لے کر حتمی جواب تیار کرنے تک، ہر قدم کے لیے واضح پرامپٹس کی ضرورت نہیں۔
3. **کفایت**: یہ ایجنٹ کی کارکردگی کو بہتر بناتا ہے اور بازیافت و جنریشن کے عمل کو ہموار کر کے تیز اور درست جوابات فراہم کرتا ہے۔

**ٹریول ایجنٹ میں مثال**:

- User Input: "میں پیرس میں میوزیم دیکھنا چاہتا/چاہتی ہوں۔"
- RAG Tool: خود بخود میوزیم کے بارے میں معلومات بازیافت کرتا ہے اور جواب تیار کرتا ہے۔
- Generated Response: "یہاں پیرس کے کچھ بہترین میوزیم ہیں: Louvre Museum، Musée d'Orsay، اور Centre Pompidou۔"

### موازنہ

| Aspect                 | Prompting Technique                                        | Tool                                                  |
|------------------------|-------------------------------------------------------------|-------------------------------------------------------|
| **Manual vs Automatic**| ہر سوال کے لیے پرامپٹس کی دستی تیاری۔                       | بازیافت اور جنریشن کے لیے خودکار عمل۔                 |
| **Control**            | بازیافت کے عمل پر زیادہ کنٹرول فراہم کرتا ہے۔                | بازیافت اور جنریشن کو ہموار اور خودکار بناتا ہے۔       |
| **Flexibility**        | مخصوص ضروریات کی بنیاد پر حسبِ ضرورت پرامپٹس کی اجازت دیتا ہے۔| بڑے پیمانے پر نفاذ کے لیے زیادہ موثر۔                 |
| **Complexity**         | پرامپٹس کی تشکیل اور ایڈجسٹمنٹ کی ضرورت ہوتی ہے۔             | AI ایجنٹ کی آرکیٹیکچر میں ضم کرنا آسان تر۔             |

### عملی مثالیں

**Prompting Technique Example:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**Tool Example:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### مطابقت (Relevancy) کا اندازہ

مناسبیت کا اندازہ AI ایجنٹ کی کارکردگی کا ایک اہم پہلو ہے۔ یہ یقینی بناتا ہے کہ ایجنٹ کے ذریعے بازیافت اور تیار کی گئی معلومات صارف کے لیے مناسب، درست، اور مفید ہوں۔ آئیے دیکھتے ہیں کہ AI ایجنٹس میں مناسبیت کا اندازہ کیسے کیا جاتا ہے، بشمول عملی مثالیں اور تکنیکیں۔

#### مناسبیت کے اندازے میں کلیدی تصورات

1. **سیاق و سباق کی آگاہی**:
   - ایجنٹ کو صارف کے سوال کے سیاق و سباق کو سمجھنا چاہیے تاکہ متعلقہ معلومات بازیافت اور تیار کی جا سکیں۔
   - مثال: اگر صارف پوچھتا ہے "پیرس میں بہترین ریستوراں کون سے ہیں؟" تو ایجنٹ کو صارف کی ترجیحات جیسے کھانے کی قسم اور بجٹ کو مدِنظر رکھنا چاہیے۔

2. **درستگی**:
   - ایجنٹ کی فراہم کردہ معلومات حقائق کے مطابق اور تازہ ہونی چاہئیں۔
   - مثال: ایسے ریستوراں کی سفارش کرنا جو اس وقت کھلے ہیں اور اچھے ریویوز رکھتے ہیں، منسوخ شدہ یا بند شدہ آپشنز کے بجائے۔

3. **صارف کا ارادہ**:
   - ایجنٹ کو سوال کے پیچھے صارف کا ارادہ سمجھنا چاہیے تاکہ وہ زیادہ متعلقہ معلومات فراہم کر سکے۔
   - مثال: اگر صارف "بجٹ فرینڈلی ہوٹلز" مانگتا ہے، تو ایجنٹ کو سستی آپشنز کو ترجیح دینی چاہیے۔

4. **فیڈ بیک لوپ**:
   - صارف کی رائے مسلسل جمع کر کے اور تجزیہ کر کے ایجنٹ اپنے مناسبیت کے اندازے کو بہتر بنا سکتا ہے۔
   - مثال: پچھلی سفارشات پر صارف کی درجہ بندی اور تاثرات کو شامل کر کے مستقبل کے جوابات میں بہتری لانا۔

#### مناسبیت کے اندازے کے لیے عملی تکنیکیں

1. **Relevance Scoring**:
   - ہر بازیافت شدہ آئٹم کو ایک مطابقت اسکور تفویض کریں جو بتاتا ہو کہ وہ صارف کے سوال اور ترجیحات سے کتنی مطابقت رکھتا ہے۔
   - مثال:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **Filtering and Ranking**:
   - غیر متعلقہ آئٹمز کو فلٹر کریں اور باقی آئٹمز کو ان کے مطابقت اسکور کی بنیاد پر درجہ بندی کریں۔
   - مثال:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # اوپر کے ۱۰ متعلقہ اشیاء واپس کریں
     ```

3. **Natural Language Processing (NLP)**:
   - صارف کے سوال کو سمجھنے اور متعلقہ معلومات بازیافت کرنے کے لیے NLP تکنیکوں کا استعمال کریں۔
   - مثال:

     ```python
     def process_query(query):
         # NLP استعمال کریں تاکہ صارف کے استفسار سے کلیدی معلومات نکالی جائیں
         processed_query = nlp(query)
         return processed_query
     ```

4. **User Feedback Integration**:
   - فراہم کردہ سفارشات پر صارف کی رائے جمع کریں اور اسے مستقبل کے مناسبیت کے اندازوں کو ایڈجسٹ کرنے کے لیے استعمال کریں۔
   - مثال:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### مثال: ٹریول ایجنٹ میں مناسبیت کا اندازہ

یہاں ایک عملی مثال ہے کہ کس طرح Travel Agent سفر کی سفارشات کی مناسبیت کا اندازہ کر سکتا ہے:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # سب سے متعلقہ 10 اشیاء واپس کریں

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# استعمال کی مثال
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### ارادے کے ساتھ تلاش

ارادے کے ساتھ تلاش میں صارف کے سوال کے پیچھے چھپے ہوئے مقصد یا ہدف کو سمجھنا اور تشریح کرنا شامل ہے تاکہ سب سے زیادہ متعلقہ اور مفید معلومات بازیافت اور تیار کی جا سکیں۔ یہ طریقہ صرف کلیدی الفاظ کے ملاپ سے آگے بڑھ کر صارف کی حقیقی ضروریات اور سیاق و سباق کو سمجھنے پر زور دیتا ہے۔

#### ارادے کے ساتھ تلاش میں کلیدی تصورات

1. **صارف کے ارادے کو سمجھنا**:
   - صارف کے ارادے کو تین بنیادی اقسام میں درجہ بندی کیا جا سکتا ہے: اطلاعاتی، نیویگیشنل، اور تجارتی۔
     - **اطلاعاتی ارادہ**: صارف کسی موضوع کے بارے میں معلومات حاصل کرنا چاہتا ہے (مثلاً، "پیرس میں بہترین میوزیم کون سے ہیں؟")۔
     - **نیویگیشنل ارادہ**: صارف کسی مخصوص ویب سائٹ یا صفحے تک جانا چاہتا ہے (مثلاً، "Louvre Museum کی سرکاری ویب سائٹ")۔
     - **تجارتی ارادہ**: صارف کوئی لین دین کرنا چاہتا ہے، جیسے فلائٹ بک کرنا یا خریداری کرنا (مثلاً، "پیرس کے لیے فلائٹ بک کریں")۔

2. **سیاق و سباق کی آگاہی**:
   - صارف کے سوال کے سیاق و سباق کا تجزیہ ارادے کی صحیح شناخت میں مدد کرتا ہے۔ اس میں پچھلی تعاملات، صارف کی ترجیحات، اور موجودہ سوال کی مخصوص تفصیلات شامل ہیں۔

3. **قدرتی زبان پروسسنگ (NLP)**:
   - صارفین کے ذریعہ دیے گئے قدرتی زبان کے سوالات کو سمجھنے اور تشریح کرنے کے لیے NLP تکنیکیں استعمال کی جاتی ہیں۔ اس میں entity recognition، sentiment analysis، اور query parsing جیسے کام شامل ہیں۔

4. **شخصی بنانا**:
   - صارف کی تاریخ، ترجیحات، اور فیڈبیک کی بنیاد پر تلاش کے نتائج کو ذاتی بنانا معلومات کی مناسبیت کو بڑھاتا ہے۔

#### عملی مثال: Travel Agent میں ارادے کے ساتھ تلاش

آئیے Travel Agent کی مثال لے کر دیکھتے ہیں کہ ارادے کے ساتھ تلاش کس طرح نافذ کی جا سکتی ہے۔

1. **صارف کی ترجیحات جمع کرنا**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **صارف کے ارادے کو سمجھنا**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **سیاق و سباق کی آگاہی**
   ```python
   def analyze_context(query, user_history):
       # سیاق و سباق کو سمجھنے کے لیے موجودہ استفسار کو صارف کی تاریخ کے ساتھ جوڑیں
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **تلاش اور نتائج کو حسبِ ذوق بنائیں**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # اطلاعاتی ارادے کے لیے تلاش کی مثال
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # نیویگیشنل ارادے کے لیے تلاش کی مثال
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # لین دین کے ارادے کے لیے تلاش کی مثال
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # شخصی کرنے کی منطق کی مثال
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # اوپر کے 10 ذاتی نتائج واپس کریں
   ```

5. **مثالی استعمال**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. بطورِ ٹول کوڈ تیار کرنا

کوڈ جنریٹ کرنے والے ایجنٹس AI ماڈلز کا استعمال کرتے ہیں کوڈ لکھنے اور چلانے کے لیے، پیچیدہ مسائل حل کرنے اور کاموں کو خودکار بنانے کے لیے۔

### کوڈ جنریٹ کرنے والے ایجنٹس

کوڈ جنریٹ کرنے والے ایجنٹس جنریٹو AI ماڈلز کا استعمال کرتے ہیں کوڈ لکھنے اور چلانے کے لیے۔ یہ ایجنٹس پیچیدہ مسائل حل کر سکتے ہیں، کاموں کو خودکار بنا سکتے ہیں، اور مختلف پروگرامنگ زبانوں میں کوڈ بنا کر چلانے کے ذریعے قیمتی بصیرت فراہم کر سکتے ہیں۔

#### عملی اطلاقات

1. **خودکار کوڈ جنریشن**: مخصوص کاموں کے لیے کوڈ کے ٹکڑے جنریٹ کریں، جیسے ڈیٹا اینالیسِس، ویب سکرَپنگ، یا مشین لرننگ۔
2. **SQL بطور RAG**: ڈیٹا بیس سے ڈیٹا نکالنے اور تبدیل کرنے کے لیے SQL کو استعمال کریں۔
3. **مسئلہ حل کرنا**: مخصوص مسائل حل کرنے کے لیے کوڈ بنائیں اور چلائیں، جیسے الگورتھمز کو بہتر بنانا یا ڈیٹا کا تجزیہ کرنا۔

#### مثال: ڈیٹا اینالیسِس کے لیے کوڈ جنریٹ کرنے والا ایجنٹ

فرض کریں آپ ایک کوڈ جنریٹ کرنے والا ایجنٹ ڈیزائن کر رہے ہیں۔ یہ اس طرح کام کر سکتا ہے:

1. **ٹاسک**: ایک ڈیٹاسیٹ کا تجزیہ کریں تاکہ رجحانات اور پیٹرنز کی نشاندہی ہو سکے۔
2. **قدم بہ قدم**:
   - ڈیٹاسیٹ کو کسی ڈیٹا اینالیسِس ٹول میں لوڈ کریں۔
   - ڈیٹا کو فلٹر اور ایگریگیٹ کرنے کے لیے SQL کوئریز جنریٹ کریں۔
   - کوئریز اجرا کریں اور نتائج حاصل کریں۔
   - نتائج کا استعمال کر کے ویژولائزیشنز اور بصیرتیں بنائیں۔
3. **درکار وسائل**: ڈیٹاسیٹ تک رسائی، ڈیٹا اینالیسِس ٹولز، اور SQL صلاحیتیں۔
4. **تجربہ**: ماضی کے تجزیاتی نتائج کا استعمال مستقبل کے تجزیات کی درستگی اور متعلقہّت بہتر بنانے کے لیے کریں۔

### مثال: ٹریول ایجنٹ کے لیے کوڈ جنریٹ کرنے والا ایجنٹ

اس مثال میں، ہم ایک کوڈ جنریٹ کرنے والا ایجنٹ، Travel Agent، ڈیزائن کریں گے تاکہ صارفین کی سفر کی منصوبہ بندی میں مدد کی جا سکے، اور یہ کوڈ بنا کر چلا سکے۔ یہ ایجنٹ پروازوں کے آپشنز حاصل کرنے، نتائج کو فلٹر کرنے، اور جنریٹو AI کا استعمال کرتے ہوئے سفری پروگرام مرتب کرنے جیسے کام سنبھال سکتا ہے۔

#### کوڈ جنریٹ کرنے والے ایجنٹ کا جائزہ

1. **صارف کی ترجیحات جمع کرنا**: منزل، سفر کی تاریخیں، بجٹ، اور دلچسپیوں جیسی صارف کی ان پٹ جمع کرتا ہے۔
2. **ڈیٹا حاصل کرنے کے لیے کوڈ بنانا**: پروازوں، ہوٹلوں، اور سیاحتی مقامات کے بارے میں ڈیٹا حاصل کرنے کے لیے کوڈ کے ٹکڑے جنریٹ کرتا ہے۔
3. **جنریٹ کردہ کوڈ چلانا**: حقیقی وقت کی معلومات حاصل کرنے کے لیے بنے ہوئے کوڈ کو چلاتا ہے۔
4. **سفر نامہ بنانا**: حاصل کیے گئے ڈیٹا کو ایک شخصی سفر منصوبے میں مرتب کرتا ہے۔
5. **فیڈبیک کی بنیاد پر ایڈجسٹ کرنا**: صارف کے فیڈبیک کو وصول کرتا ہے اور نتائج کو بہتر بنانے کے لیے درکار صورتوں میں کوڈ دوبارہ جنریٹ کرتا ہے۔

#### قدم بہ قدم نفاذ

1. **صارف کی ترجیحات جمع کرنا**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **ڈیٹا حاصل کرنے کے لیے کوڈ جنریٹ کرنا**

   ```python
   def generate_code_to_fetch_data(preferences):
       # مثال: صارف کی ترجیحات کی بنیاد پر پروازیں تلاش کرنے کے لیے کوڈ تیار کریں
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # مثال: ہوٹلز تلاش کرنے کے لیے کوڈ تیار کریں
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **جنریٹ کردہ کوڈ چلانا**

   ```python
   def execute_code(code):
       # تخلیق شدہ کوڈ کو exec کے ذریعے چلائیں
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **سفر نامہ بنانا**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **فیڈبیک کی بنیاد پر ایڈجسٹ کرنا**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # صارف کے تاثرات کی بنیاد پر ترجیحات کو ایڈجسٹ کریں
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # اپ ڈیٹ شدہ ترجیحات کے ساتھ کوڈ کو دوبارہ تیار کریں اور چلائیں
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### ماحولیاتی آگاہی اور استدلال سے فائدہ اٹھانا

ٹیبل کے اسکیمہ کی بنیاد پر واقعی کوئری جنریشن کے عمل کو ماحولیاتی آگاہی اور استدلال کے ذریعے بہتر کیا جا سکتا ہے۔

یہاں ایک مثال ہے کہ یہ کیسے کیا جا سکتا ہے:

1. **اسکیمہ کو سمجھنا**: نظام ٹیبل کے اسکیمہ کو سمجھے گا اور اس معلومات کو کوئری جنریشن میں گراؤنڈ کرنے کے لیے استعمال کرے گا۔
2. **فیڈبیک کی بنیاد پر ایڈجسٹ کرنا**: نظام فیڈبیک کی بنیاد پر صارف کی ترجیحات کو ایڈجسٹ کرے گا اور یہ دلیل کرے گا کہ اسکیمہ کے کن فیلڈز کو اپ ڈیٹ کرنے کی ضرورت ہے۔
3. **کوئری جنریٹ اور اجرا کرنا**: نظام اپ ڈیٹ شدہ ترجیحات کی بنیاد پر فلائٹ اور ہوٹل کے ڈیٹا کو حاصل کرنے کے لیے کوئریز جنریٹ اور اجرا کرے گا۔

یہاں ایک اپڈیٹ شدہ Python کوڈ کی مثال ہے جو ان تصورات کو شامل کرتی ہے:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # صارف کی رائے کی بنیاد پر ترجیحات کو ایڈجسٹ کریں
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # اسکیما کی بنیاد پر استدلال تاکہ دیگر متعلقہ ترجیحات کو ایڈجسٹ کیا جا سکے
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # اسکیما اور تاثرات کی بنیاد پر ترجیحات کو ایڈجسٹ کرنے کے لیے مخصوص منطق
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # اپڈیٹ شدہ ترجیحات کی بنیاد پر فلائٹ ڈیٹا حاصل کرنے کے لیے کوڈ تیار کریں
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # اپڈیٹ شدہ ترجیحات کی بنیاد پر ہوٹل کا ڈیٹا حاصل کرنے کے لیے کوڈ تیار کریں
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # کوڈ کے اجرا کی نقل کریں اور فرضی ڈیٹا واپس کریں
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # پروازوں، ہوٹلوں اور تفریحی مقامات کی بنیاد پر سفرنامہ تیار کریں
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# مثالی اسکیما
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# استعمال کی مثال
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# اپڈیٹ شدہ ترجیحات کے ساتھ کوڈ کو دوبارہ تیار کریں اور چلائیں
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### تشریح - فیڈبیک کی بنیاد پر بکنگ

1. **اسکیمہ آگاہی**: `schema` ڈکشنری بتاتی ہے کہ فیڈبیک کی بنیاد پر ترجیحات کو کیسے ایڈجسٹ کیا جانا چاہیے۔ اس میں `favorites` اور `avoid` جیسے فیلڈز شامل ہیں، جن کے مطابق ایڈجسٹمنٹس کیے جاتے ہیں۔
2. **فیڈبیک کی بنیاد پر ترجیحات ایڈجسٹ کرنا (`adjust_based_on_feedback` میتھڈ)**: یہ میتھڈ صارف کے فیڈبیک اور اسکیمہ کی بنیاد پر ترجیحات کو ایڈجسٹ کرتا ہے۔
3. **ماحول کی بنیاد پر ایڈجسٹمنٹس (`adjust_based_on_environment` میتھڈ)**: یہ میتھڈ اسکیمہ اور فیڈبیک کی بنیاد پر ایڈجسٹمنٹس کو حسبِ ماحول کسٹمائز کرتا ہے۔
4. **کوئریز جنریٹ اور اجرا کرنا**: نظام ایڈجسٹ کی گئی ترجیحات کی بنیاد پر اپڈیٹ شدہ فلائٹ اور ہوٹل کے ڈیٹا کو حاصل کرنے کے لیے کوڈ جنریٹ کرتا اور ان کوئریز کا اجرا فرضی طور پر سمِولیٹ کرتا ہے۔
5. **سفر نامہ جنریٹ کرنا**: نظام نئے فلائٹ، ہوٹل، اور پرکشش مقامات کے ڈیٹا کی بنیاد پر اپڈیٹ شدہ سفر نامہ بناتا ہے۔

نظام کو ماحولیاتی آگاہ اور اسکیمہ کی بنیاد پر استدلال کرنے کے قابل بنا کر، یہ زیادہ درست اور متعلقہ کوئریز جنریٹ کر سکتا ہے، جس سے بہتر سفر کی سفارشات اور زیادہ شخصی صارف تجربہ حاصل ہوتا ہے۔

### SQL کو Retrieval-Augmented Generation (RAG) تکنیک کے طور پر استعمال کرنا

SQL (Structured Query Language) ڈیٹا بیس کے ساتھ تعامل کے لیے ایک طاقتور ٹول ہے۔ جب اسے Retrieval-Augmented Generation (RAG) اپروچ کے حصے کے طور پر استعمال کیا جائے، تو SQL ڈیٹا بیس سے متعلقہ ڈیٹا نکال سکتا ہے تاکہ AI ایجنٹس میں جوابات یا ایکشنز کی ہدایت یا جنریشن کے لیے معلومات فراہم کی جا سکیں۔ آئیے دیکھتے ہیں کہ Travel Agent کے سیاق و سباق میں SQL کو RAG تکنیک کے طور پر کیسے استعمال کیا جا سکتا ہے۔

#### کلیدی تصورات

1. **ڈیٹا بیس کے ساتھ تعامل**:
   - SQL ڈیٹا بیس کو کوئری کرنے، متعلقہ معلومات نکالنے، اور ڈیٹا کو تبدیل کرنے کے لیے استعمال ہوتا ہے۔
   - مثال: سفر کے ڈیٹا بیس سے فلائٹ کی تفصیلات، ہوٹل کی معلومات، اور پرکشش مقامات حاصل کرنا۔

2. **RAG کے ساتھ انضمام**:
   - SQL کوئریز صارف کی ان پٹ اور ترجیحات کی بنیاد پر جنریٹ کی جاتی ہیں۔
   - حاصل شدہ ڈیٹا پھر شخصی سفارشات یا اقدامات جنریٹ کرنے کے لیے استعمال ہوتا ہے۔

3. **متحرک کوئری جنریشن**:
   - AI ایجنٹ سیاق و سباق اور صارف کی ضروریات کی بنیاد پر متحرک SQL کوئریز جنریٹ کرتا ہے۔
   - مثال: بجٹ، تاریخوں، اور دلچسپیوں کی بنیاد پر نتائج کو فلٹر کرنے کے لیے SQL کوئریز کو حسبِ ضرورت بنانا۔

#### اطلاقات

- **خودکار کوڈ جنریشن**: مخصوص کاموں کے لیے کوڈ کے ٹکڑے جنریٹ کریں۔
- **SQL بطور RAG**: ڈیٹا کو تبدیل کرنے کے لیے SQL کوئریز کا استعمال کریں۔
- **مسئلہ حل کرنا**: مسائل حل کرنے کے لیے کوڈ بنائیں اور چلائیں۔

**مثال**:
ایک ڈیٹا اینالسِس ایجنٹ:

1. **ٹاسک**: رجحانات معلوم کرنے کے لیے ایک ڈیٹاسیٹ کا تجزیہ کریں۔
2. **قدم**:
   - ڈیٹاسیٹ لوڈ کریں۔
   - ڈیٹا فلٹر کرنے کے لیے SQL کوئریز جنریٹ کریں۔
   - کوئریز اجرا کریں اور نتائج حاصل کریں۔
   - ویژولائزیشنز اور بصیرتیں جنریٹ کریں۔
3. **وسائل**: ڈیٹاسیٹ تک رسائی، SQL صلاحیتیں۔
4. **تجربہ**: مستقبل کے تجزیات بہتر بنانے کے لیے ماضی کے نتائج کا استعمال کریں۔

#### عملی مثال: Travel Agent میں SQL کا استعمال

1. **صارف کی ترجیحات جمع کرنا**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **SQL کوئریز جنریٹ کرنا**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **SQL کوئریز اجرا کرنا**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **سفارشات تیار کرنا**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### مثالی SQL کوئریز

1. **فلائٹ کوئری**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **ہوٹل کوئری**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **پرکشش مقامات کی کوئری**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

SQL کو Retrieval-Augmented Generation (RAG) تکنیک کے حصے کے طور پر استعمال کر کے، AI ایجنٹس جیسے Travel Agent متحرک طور پر متعلقہ ڈیٹا نکال سکتے ہیں اور درست اور شخصی سفارشات فراہم کرنے کے لیے اس کا استعمال کر سکتے ہیں۔

### میٹا کگنیشن کی مثال

تو میٹا کگنیشن کے نفاذ کی ایک مثال دکھانے کے لیے، آئیے ایک سادہ ایجنٹ بنائیں جو مسئلہ حل کرتے ہوئے اپنے فیصلہ سازی کے عمل پر غور کرتا ہے۔ اس مثال میں، ہم ایک سسٹم بنائیں گے جہاں ایجنٹ ہوٹل کے انتخاب کو بہتر بنانے کی کوشش کرتا ہے، پھر اپنے استدلال کا جائزہ لیتا ہے اور جب وہ غلطیاں یا غیر مثالی انتخابات کرے تو اپنی حکمتِ عملی کو ایڈجسٹ کرتا ہے۔

ہم اسے ایک بنیادی مثال کے ذریعے سمِولیٹ کریں گے جہاں ایجنٹ قیمت اور معیار کے امتزاج کی بنیاد پر ہوٹلز کا انتخاب کرتا ہے، مگر پھر وہ اپنے فیصلوں پر "غور" کرے گا اور اسی کے مطابق اپنی حکمتِ عملی تبدیل کرے گا۔

#### یہ کیسے میٹا کگنیشن کی عکاسی کرتا ہے:

1. **ابتدائی فیصلہ**: ایجنٹ سب سے سستا ہوٹل منتخب کرے گا، بغیر معیار کے اثر کو سمجھے۔
2. **عکاسی اور جائزہ**: ابتدائی انتخاب کے بعد، ایجنٹ یہ چیک کرے گا کہ آیا صارف کے فیڈبیک کی بنیاد پر ہوٹل ایک "خراب" انتخاب تھا۔ اگر اسے پتا چلتا ہے کہ ہوٹل کا معیار بہت کم تھا، تو وہ اپنے استدلال پر غور کرے گا۔
3. **حکمتِ عملی میں ایڈجسٹمنٹ**: ایجنٹ اپنے عکاسی کی بنیاد پر حکمتِ عملی ایڈجسٹ کرے گا — مثلاً "سب سے سستا" سے "اعلیٰ معیار" کی طرف سوئچ کرے گا — اس طرح مستقبل میں فیصلوں کی کارکردگی بہتر ہو جائے گی۔

یہاں ایک مثال ہے:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # پہلے منتخب کیے گئے ہوٹلز کو محفوظ کرتا ہے
        self.corrected_choices = []  # درست کیے گئے انتخاب کو محفوظ کرتا ہے
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # دستیاب حکمتِ عملیاں

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # فرض کریں کہ ہمارے پاس کچھ صارف کی آراء ہیں جو بتاتی ہیں کہ آخری انتخاب اچھا تھا یا نہیں
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # اگر پچھلا انتخاب اطمینان بخش نہ تھا تو حکمتِ عمل تبدیل کریں
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# ہوٹلز کی ایک فہرست کی نقالی کریں (قیمت اور معیار)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# ایک ایجنٹ بنائیں
agent = HotelRecommendationAgent()

# مرحلہ 1: ایجنٹ "سب سے سستا" حکمتِ عملی استعمال کرکے ایک ہوٹل کی سفارش کرتا ہے
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# مرحلہ 2: ایجنٹ انتخاب پر غور کرتا ہے اور اگر ضروری ہو تو حکمتِ عملی تبدیل کرتا ہے
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# مرحلہ 3: ایجنٹ دوبارہ سفارش کرتا ہے، اس بار ترمیم شدہ حکمتِ عملی استعمال کرتے ہوئے
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### ایجنٹس کی میٹا کگنیشن صلاحیتیں

اہم بات یہاں ایجنٹ کی صلاحیت ہے کہ وہ:
- اپنے پچھلے انتخاب اور فیصلہ سازی کے عمل کا جائزہ لے۔
- اس عکاسی کی بنیاد پر اپنی حکمتِ عملی ایڈجسٹ کرے، یعنی میٹا کگنیشن عمل میں لائی جائے۔

یہ میٹا کگنیشن کی ایک سادہ شکل ہے جہاں نظام اندرونی فیڈبیک کی بنیاد پر اپنے استدلالی عمل کو ایڈجسٹ کرنے کے قابل ہوتا ہے۔

### نتیجہ

میٹا کگنیشن ایک طاقتور آلہ ہے جو AI ایجنٹس کی صلاحیتوں کو نمایاں طور پر بہتر بنا سکتا ہے۔ میٹا کگنیشن کے عمل کو شامل کر کے، آپ ایسے ایجنٹس ڈیزائن کر سکتے ہیں جو زیادہ ذہین، مطابقت پذیر، اور مؤثر ہوں۔ میٹا کگنیشن کے بارے میں مزید جاننے کے لیے اضافی وسائل کا استعمال کریں اور اس دلچسپ دنیا کو مزید دریافت کریں۔

### کیا میٹا کگنیشن ڈیزائن پیٹرن کے بارے میں مزید سوالات ہیں؟

دیگر سیکھنے والوں سے ملنے، آفس آورز میں شرکت کرنے، اور اپنے AI ایجنٹس کے سوالات کے جواب حاصل کرنے کے لیے [Microsoft Foundry Discord](https://aka.ms/ai-agents/discord) میں شامل ہوں۔

## پچھلا سبق

[ملٹی ایجنٹ ڈیزائن پیٹرن](../08-multi-agent/README.md)

## اگلا سبق

[AI ایجنٹس پروڈکشن میں](../10-ai-agents-production/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
دستبرداری:
یہ دستاویز AI ترجمہ سروس Co‑op Translator (https://github.com/Azure/co-op-translator) کے ذریعے ترجمہ کی گئی ہے۔ ہم درستگی کے لیے کوشاں ہیں، تاہم براہِ کرم نوٹ کریں کہ خودکار تراجم میں غلطیاں یا عدم درستیاں ہو سکتی ہیں۔ اصل دستاویز اس کی مادری زبان میں موثق ماخذ سمجھی جانی چاہیے۔ اہم معلومات کے لیے پیشہ ورانہ انسانی ترجمہ کی سفارش کی جاتی ہے۔ اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تعبیر کے لیے ہم ذمہ دار نہیں ہیں۔
<!-- CO-OP TRANSLATOR DISCLAIMER END -->